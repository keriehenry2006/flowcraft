<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowCraft - Interactive Process Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="config.js"></script>
    <script src="flowcraft-error-handler.js"></script>
    
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self' https://*.supabase.co;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta name="csrf-token" content=""><!-- CSRF token will be set by JavaScript -->
    <style>
        :root {
            /* FlowCraft 2025 Futuristic Palette */
            --flowcraft-primary: #00D4FF;
            --flowcraft-primary-dark: #0099CC;
            --flowcraft-secondary: #FF006E;
            --flowcraft-secondary-dark: #CC0055;
            --flowcraft-accent: #8B5CF6;
            --flowcraft-success: #39FF14;
            --flowcraft-danger: #FF006E;
            --flowcraft-warning: #FFBE0B;
            --flowcraft-dark: #0A0A0F;
            --flowcraft-grey: #6B7280;
            --flowcraft-light-grey: #1A1A2E;
            --flowcraft-white: #FFFFFF;
            
            /* 2025 Design Variables */
            --fc-dark-primary: #0A0A0F;
            --fc-dark-secondary: #1A1A2E;
            --fc-dark-accent: #16213E;
            --fc-neon-primary: #00D4FF;
            --fc-neon-secondary: #FF006E;
            --fc-neon-accent: #8B5CF6;
            --fc-neon-warning: #FFBE0B;
            --fc-neon-success: #39FF14;
            --fc-text-primary: #FFFFFF;
            --fc-text-secondary: #B4B4B8;
            --fc-text-muted: #6B7280;
            --fc-surface: rgba(26, 26, 46, 0.8);
            --fc-surface-light: rgba(255, 255, 255, 0.1);
            --fc-border: rgba(0, 212, 255, 0.3);
            
            /* Gradient Variables */
            --flowcraft-gradient-primary: linear-gradient(135deg, #00D4FF 0%, #8B5CF6 100%);
            --flowcraft-gradient-secondary: linear-gradient(135deg, #FF006E 0%, #8B5CF6 100%);
            --flowcraft-gradient-accent: linear-gradient(135deg, #8B5CF6 0%, #00D4FF 100%);
            --flowcraft-gradient-bg: linear-gradient(135deg, #0A0A0F 0%, #1A1A2E 25%, #16213E 75%, #0A0A0F 100%);
            
            /* Shadow Variables - 2025 Neon Effects */
            --flowcraft-shadow-sm: 0 0 10px rgba(0, 212, 255, 0.1);
            --flowcraft-shadow-md: 0 0 20px rgba(0, 212, 255, 0.2), 0 4px 6px rgba(0, 0, 0, 0.3);
            --flowcraft-shadow-lg: 0 0 30px rgba(0, 212, 255, 0.3), 0 10px 15px rgba(0, 0, 0, 0.4);
            --flowcraft-shadow-xl: 0 0 40px rgba(0, 212, 255, 0.4), 0 20px 25px rgba(0, 0, 0, 0.5);
            
            /* Advanced 2025 Effects */
            --fc-glow-primary: 0 0 20px rgba(0, 212, 255, 0.5);
            --fc-glow-secondary: 0 0 30px rgba(255, 0, 110, 0.3);
            --fc-shadow-brutal: 8px 8px 0px rgba(0, 212, 255, 0.2);
            --fc-shadow-deep: 0 25px 50px -12px rgba(0, 0, 0, 0.8);
            
                    /* Legacy compatibility variables */
        --bridgestone-red: var(--fc-neon-secondary);
        --bridgestone-red-darker: var(--flowcraft-secondary-dark);
        --bridgestone-black: var(--fc-dark-primary);
        --bridgestone-grey: var(--fc-text-muted);

        /* ============================================
           FLOWCRAFT 2025 UNIFIED BUTTON SYSTEM
           ============================================ */
        
        /* Base FlowCraft Button */
        .btn-fc {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 20px;
            border: 2px solid var(--fc-border);
            border-radius: 0; /* Brutalist */
            font-size: 14px;
            font-weight: 600;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            gap: 8px;
            background: var(--fc-dark-secondary);
            color: var(--fc-text-primary);
            position: relative;
            overflow: hidden;
            box-shadow: var(--flowcraft-shadow-sm);
            user-select: none;
        }

        .btn-fc::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn-fc:hover::before {
            left: 100%;
        }

        .btn-fc:hover {
            transform: translateY(-2px);
            box-shadow: var(--fc-glow-primary), var(--flowcraft-shadow-lg);
            border-color: var(--fc-neon-primary);
        }

        .btn-fc:active {
            transform: translateY(0);
            box-shadow: var(--flowcraft-shadow-sm);
        }

        .btn-fc:focus {
            outline: none;
            box-shadow: var(--fc-glow-primary), 0 0 0 3px rgba(0, 212, 255, 0.3);
        }

        .btn-fc:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: var(--fc-dark-secondary) !important;
            color: var(--fc-text-muted) !important;
            border-color: var(--fc-border) !important;
            transform: none !important;
            box-shadow: var(--flowcraft-shadow-sm) !important;
        }

        .btn-fc:disabled:hover {
            transform: none !important;
        }

        /* Primary Button - Main Actions */
        .btn-fc.btn-fc-primary {
            background: linear-gradient(135deg, var(--fc-neon-primary) 0%, var(--fc-neon-secondary) 100%);
            border-color: var(--fc-neon-primary);
            color: var(--fc-dark-primary);
            font-weight: 700;
            box-shadow: var(--fc-shadow-brutal);
        }

        .btn-fc.btn-fc-primary::before {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        }

        .btn-fc.btn-fc-primary:hover {
            transform: translateY(-3px);
            box-shadow: 12px 12px 0px rgba(0, 212, 255, 0.3), var(--fc-glow-primary);
        }

        /* Secondary Button - Supporting Actions */
        .btn-fc.btn-fc-secondary {
            background: var(--fc-dark-secondary);
            border-color: var(--fc-border);
            color: var(--fc-text-secondary);
        }

        .btn-fc.btn-fc-secondary:hover {
            background: var(--fc-border);
            color: var(--fc-text-primary);
            border-color: var(--fc-neon-primary);
        }

        /* Danger Button - Destructive Actions */
        .btn-fc.btn-fc-danger {
            background: linear-gradient(135deg, var(--fc-neon-secondary) 0%, #DC2626 100%);
            border-color: var(--fc-neon-secondary);
            color: var(--fc-text-primary);
            box-shadow: 4px 4px 0px rgba(255, 0, 110, 0.3);
        }

        .btn-fc.btn-fc-danger::before {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }

        .btn-fc.btn-fc-danger:hover {
            transform: translateY(-3px);
            box-shadow: 8px 8px 0px rgba(255, 0, 110, 0.4), var(--fc-glow-secondary);
        }

        /* Success Button - Confirmation Actions */
        .btn-fc.btn-fc-success {
            background: linear-gradient(135deg, var(--fc-neon-success) 0%, #059669 100%);
            border-color: var(--fc-neon-success);
            color: var(--fc-dark-primary);
            box-shadow: 4px 4px 0px rgba(57, 255, 20, 0.3);
        }

        .btn-fc.btn-fc-success::before {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }

        .btn-fc.btn-fc-success:hover {
            transform: translateY(-3px);
            box-shadow: 8px 8px 0px rgba(57, 255, 20, 0.4), 0 0 20px rgba(57, 255, 20, 0.5);
        }

        /* Warning Button - Caution Actions */
        .btn-fc.btn-fc-warning {
            background: linear-gradient(135deg, var(--fc-neon-warning) 0%, #D97706 100%);
            border-color: var(--fc-neon-warning);
            color: var(--fc-dark-primary);
            box-shadow: 4px 4px 0px rgba(255, 190, 11, 0.3);
        }

        .btn-fc.btn-fc-warning::before {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }

        .btn-fc.btn-fc-warning:hover {
            transform: translateY(-3px);
            box-shadow: 8px 8px 0px rgba(255, 190, 11, 0.4), 0 0 20px rgba(255, 190, 11, 0.5);
        }

        /* Accent Button - Special Actions */
        .btn-fc.btn-fc-accent {
            background: linear-gradient(135deg, var(--fc-neon-accent) 0%, #7C3AED 100%);
            border-color: var(--fc-neon-accent);
            color: var(--fc-text-primary);
            box-shadow: 4px 4px 0px rgba(139, 92, 246, 0.3);
        }

        .btn-fc.btn-fc-accent::before {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }

        .btn-fc.btn-fc-accent:hover {
            transform: translateY(-3px);
            box-shadow: 8px 8px 0px rgba(139, 92, 246, 0.4), 0 0 20px rgba(139, 92, 246, 0.5);
        }

        /* Outline Variants */
        .btn-fc.btn-fc-outline {
            background: transparent;
            border-width: 2px;
        }

        .btn-fc.btn-fc-outline.btn-fc-primary {
            background: transparent;
            border-color: var(--fc-neon-primary);
            color: var(--fc-neon-primary);
            box-shadow: none;
        }

        .btn-fc.btn-fc-outline.btn-fc-primary:hover {
            background: var(--fc-neon-primary);
            color: var(--fc-dark-primary);
            box-shadow: var(--fc-glow-primary);
        }

        .btn-fc.btn-fc-outline.btn-fc-danger {
            background: transparent;
            border-color: var(--fc-neon-secondary);
            color: var(--fc-neon-secondary);
            box-shadow: none;
        }

        .btn-fc.btn-fc-outline.btn-fc-danger:hover {
            background: var(--fc-neon-secondary);
            color: var(--fc-text-primary);
            box-shadow: var(--fc-glow-secondary);
        }

        /* Ghost Variants */
        .btn-fc.btn-fc-ghost {
            background: transparent;
            border: 2px solid transparent;
            color: var(--fc-text-secondary);
        }

        .btn-fc.btn-fc-ghost:hover {
            background: var(--fc-surface);
            border-color: var(--fc-border);
            color: var(--fc-text-primary);
        }

        /* Size Variants */
        .btn-fc.btn-fc-sm {
            padding: 8px 16px;
            font-size: 12px;
            gap: 6px;
        }

        .btn-fc.btn-fc-md {
            padding: 12px 20px;
            font-size: 14px;
            gap: 8px;
        }

        .btn-fc.btn-fc-lg {
            padding: 16px 32px;
            font-size: 16px;
            gap: 10px;
            font-weight: 700;
        }

        .btn-fc.btn-fc-xl {
            padding: 20px 40px;
            font-size: 18px;
            gap: 12px;
            font-weight: 700;
        }

        /* Width Variants */
        .btn-fc.btn-fc-full {
            width: 100%;
        }

        .btn-fc.btn-fc-auto {
            width: auto;
        }

        /* Close Button Variants */
        .btn-fc.btn-fc-close {
            padding: 8px;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 0, 110, 0.1);
            border-color: var(--fc-neon-secondary);
            color: var(--fc-neon-secondary);
            font-size: 18px;
            font-weight: 700;
            text-transform: none;
            letter-spacing: 0;
        }

        .btn-fc.btn-fc-close:hover {
            background: var(--fc-neon-secondary);
            color: var(--fc-text-primary);
            transform: scale(1.1);
        }

        /* Icon Button Variants */
        .btn-fc.btn-fc-icon {
            padding: 10px;
            width: 44px;
            height: 44px;
        }

        .btn-fc.btn-fc-icon.btn-fc-sm {
            padding: 6px;
            width: 32px;
            height: 32px;
        }

        .btn-fc.btn-fc-icon.btn-fc-lg {
            padding: 14px;
            width: 52px;
            height: 52px;
        }
        }

        body { 
            font-family: 'JetBrains Mono', 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            margin: 0; 
            padding: 20px; 
            /* 2025 Futuristic Dark Background */
            background: var(--flowcraft-gradient-bg);
            background-attachment: fixed;
            min-height: 100vh; 
            overflow-x: hidden; 
            box-sizing: border-box; 
            position: relative;
            color: var(--fc-text-primary);
        }
        
        /* 2025 Futuristic Grid Background Pattern */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(rgba(0, 212, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.03) 1px, transparent 1px),
                radial-gradient(circle at 25% 25%, rgba(0, 212, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(255, 0, 110, 0.03) 0%, transparent 50%);
            background-size: 50px 50px, 50px 50px, 200px 200px, 200px 200px;
            pointer-events: none;
            z-index: -1;
        }



        /* App Logo Header Styles */
        #app-logo-header {
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        #app-logo-header:hover {
            background: rgba(0, 212, 255, 0.1);
        }

        #app-logo-header:hover img {
            filter: drop-shadow(0 0 12px rgba(0, 212, 255, 0.6));
            transform: scale(1.05);
        }

        #app-logo-header:hover span {
            color: var(--fc-neon-primary);
        }

        #app-logo-header:active {
            transform: scale(0.98);
            background: rgba(0, 212, 255, 0.2);
        }
        .top-bar { 
            width: 100%; 
            max-width: none; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 15px;
            margin-top: 20px;
            box-sizing: border-box; 
            position: relative; 
            z-index: 1000; 
            /* 2025 Futuristic Glassmorphism */
            background: var(--fc-surface);
            backdrop-filter: blur(20px);
            border: 2px solid var(--fc-border);
            border-radius: 0; /* Brutalist */
            padding: 15px 25px;
            margin-bottom: 20px;
            box-shadow: var(--fc-shadow-brutal), var(--fc-shadow-deep);
        }
        .main-controls { 
            /* 2025 Futuristic Controls Container */
            background: var(--fc-surface);
            backdrop-filter: blur(20px);
            border: 2px solid var(--fc-border);
            padding: 15px 20px; 
            border-radius: 0; /* Brutalist */ 
            box-shadow: var(--fc-shadow-brutal), var(--flowcraft-shadow-md);
            display: flex; 
            gap: 12px; 
            align-items: center; 
            flex-wrap: wrap; 
            flex-grow: 1;
            position: relative;
        }
        
        /* === ANIMACJE ŁADOWANIA DLA KONTENERÓW === */
        @keyframes containerSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes containerFloating {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-2px);
            }
        }
        
        .top-bar, .main-controls, #diagram-container, .colors-toggle-bar, .visual-controls {
            animation: containerSlideIn 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Tylko dolne kontrolki mogą "latać" - całe górne paski pozostają stabilne */
        .colors-toggle-bar:hover, .visual-controls:hover {
            animation: containerFloating 2s ease-in-out infinite;
        }
        
        /* 2025 Futuristic Button Styles */
        .main-controls button, .main-controls input[type="search"] { 
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            padding: 10px 16px;
            border: 2px solid var(--fc-border);
            border-radius: 0; /* Brutalist */ 
            cursor: pointer; 
            background: var(--fc-dark-secondary);
            font-size: 0.9em; 
            font-weight: 600;
            color: var(--fc-text-primary);
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--flowcraft-shadow-sm);
            position: relative;
            overflow: hidden;
        }
        
        .main-controls button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.3), transparent);
            transition: left 0.6s;
        }
        
        .main-controls button:hover::before {
            left: 100%;
        }
        
        .main-controls button:hover, .main-controls input[type="search"]:hover,
        #shortcut-show-dependencies-button:hover:not(:disabled),
        #shortcut-simulate-impact-button:hover:not(:disabled) { 
            background: var(--fc-dark-accent);
            border-color: var(--fc-neon-primary);
            transform: translateY(-2px);
            box-shadow: var(--fc-glow-primary), var(--flowcraft-shadow-lg);
            color: var(--fc-text-primary);
        }
        
        .main-controls button:active, .main-controls input[type="search"]:active {
            transform: translateY(0);
            box-shadow: var(--flowcraft-shadow-sm);
        }

        /* === FLOWCRAFT 2025 SHORTCUT BUTTONS === */
        #shortcut-show-dependencies-button, #shortcut-simulate-impact-button {
            /* Use FlowCraft unified button system */
        }


        .menu-container { 
            position: relative; 
            display: inline-block; 
        }
        
        #menu-button {
            /* Use FlowCraft unified button system - will be applied via classes */
            min-width: 100px;
            justify-content: center;
        }

        #menu-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.1),
                0 8px 16px rgba(0, 0, 0, 0.06),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            z-index: 1001;
            padding: 20px;
            border-radius: 12px;
            margin-top: 8px;
            min-width: 280px;
            max-height: 75vh;
            overflow-y: auto;
            animation: menuSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: top left;
        }
        
        @keyframes menuSlideIn {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        #menu-content::-webkit-scrollbar {
            width: 6px;
        }
        
        #menu-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
        }
        
        #menu-content::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }
        
        #menu-content::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
        
        #menu-content button, #menu-content label#json-file-input-label {
            /* Use FlowCraft unified button system - will be applied via classes */
            width: 100%;
            margin-bottom: 8px;
            text-align: left;
            justify-content: flex-start;
        }
        #menu-content span#json-file-name { 
            display: block; 
            margin-top: -4px; 
            margin-bottom: 12px; 
            font-size: 0.8em;
            color: #6c757d;
            font-style: italic;
            padding: 4px 8px;
            background: rgba(108, 117, 125, 0.1);
            border-radius: 4px;
        }
        
        #json-file-input { 
            display: none; 
        }

        #menu-content h4 {
            margin-top: 20px;
            margin-bottom: 12px;
            font-size: 0.75em;
            color: var(--bridgestone-red);
            text-transform: uppercase;
            border-bottom: 2px solid rgba(218, 41, 28, 0.2);
            padding-bottom: 8px;
            font-weight: 700;
            letter-spacing: 0.5px;
            position: relative;
        }
        
        #menu-content h4::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 30px;
            height: 2px;
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        
        #menu-content h4:first-of-type {
            margin-top: 0;
        }
        
        #menu-content hr {
            border: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.1), transparent);
            margin: 16px 0;
        }
        .menu-item-group {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 12px;
            background: rgba(248, 249, 250, 0.5);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .menu-item-group label {
            font-size: 0.9em;
            white-space: nowrap;
            margin-bottom: 0;
            font-weight: 500;
            color: #495057;
            min-width: 80px;
        }
        
        .menu-item-group select, 
        .menu-item-group .delete-view-config-container button {
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 6px;
            cursor: pointer;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            font-size: 0.85em;
            flex-grow: 1;
            transition: all 0.2s ease;
            color: #495057;
        }
        
        .menu-item-group select:hover,
        .menu-item-group .delete-view-config-container button:hover {
            border-color: rgba(218, 41, 28, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .menu-item-group .delete-view-config-container button {
            padding: 8px 10px;
            font-size: 0.8em;
            flex-grow: 0;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
            border: none;
            min-width: 40px;
        }
        
        .menu-item-group .delete-view-config-container button:hover {
            background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%);
            transform: scale(1.05);
        }

        .sheet-multi-select-container, 
        .delete-view-config-container {
            position: relative;
            display: inline-block;
        }
        
        #menu-content .sheet-multi-select-container button {
            width: auto;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            font-weight: 500;
        }
        
        #menu-content .sheet-multi-select-container button:hover {
            background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
        }

        #sheet-multi-select-dropdown,
        #top-sheet-multi-select-dropdown {
            display: none;
            position: absolute;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.1),
                0 5px 15px rgba(0, 0, 0, 0.07);
            z-index: 1002;
            padding: 12px;
            border-radius: 8px;
            margin-top: 8px;
            min-width: 200px;
            max-height: 250px;
            overflow-y: auto;
            left: 0;
            animation: dropdownSlideIn 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes dropdownSlideIn {
            from {
                opacity: 0;
                transform: translateY(-5px) scale(0.98);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        #sheet-multi-select-options label,
        #top-sheet-multi-select-options label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 500; 
            font-size: 0.9em;
            color: #495057;
            padding: 6px 8px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }
        
        #sheet-multi-select-options label:hover,
        #top-sheet-multi-select-options label:hover {
            background: rgba(0, 123, 255, 0.1);
        }
        
        #sheet-multi-select-options input[type="checkbox"],
        #top-sheet-multi-select-options input[type="checkbox"] { 
            margin-right: 8px; 
        }

        #delete-view-config-dropdown {
            display: none;
            position: absolute;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.1),
                0 5px 15px rgba(0, 0, 0, 0.07);
            z-index: 1003;
            border-radius: 8px;
            margin-top: 8px;
            min-width: 180px;
            max-height: 200px;
            overflow-y: auto;
            right: 0;
            animation: dropdownSlideIn 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #delete-view-config-dropdown .delete-item {
            padding: 10px 14px;
            cursor: pointer;
            font-size: 0.9em;
            display: block;
            white-space: nowrap;
            color: #495057;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        #delete-view-config-dropdown .delete-item:last-child {
            border-bottom: none;
        }
        
        #delete-view-config-dropdown .delete-item:hover {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
            transform: translateX(4px);
        }

        #diagram-container { 
            width: 100%; 
            max-width: none; 
            height: 75vh; 
            /* NOWOCZESNE OBRAMOWANIE Z GRADIENTEM */
            border: 3px solid;
            border-image: linear-gradient(135deg, var(--bridgestone-red) 0%, #e74c3c 50%, var(--bridgestone-red-darker) 100%) 1;
            border-radius: 16px;
            position: relative; 
            overflow: auto; 
            /* GRADIENT TŁO ZAMIAST PŁASKIEGO BIAŁEGO */
            background: linear-gradient(135deg, #ffffff 0%, #fafbfc 50%, #f8f9fa 100%);
            margin-bottom: 20px; 
            cursor: grab; 
            box-sizing: border-box;
            /* NOWOCZESNE CIENIE 3D */
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.1),
                0 8px 16px rgba(0, 0, 0, 0.06),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.05);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* SUBTLE ANIMATION ON HOVER */
        #diagram-container:hover {
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.15),
                0 10px 20px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        }
        #diagram-container:active { cursor: grabbing; }
        #diagram-zoom-pane { position: relative; width: 100%; height: 100%; transform-origin: 0 0; min-width: 100%; min-height: 100%; }
        #simulation-ghost-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 4;
        }
        
        #welcome-message-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(255, 255, 255, 0.97);
            z-index: 50;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 30px;
            box-sizing: border-box;
            font-size: 1.1em;
            color: #333;
        }
        #welcome-message-overlay h2 {
            color: var(--bridgestone-red);
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        #welcome-message-overlay p {
            margin-bottom: 15px;
            line-height: 1.7;
            max-width: 650px;
        }
        #welcome-message-overlay strong {
            color: var(--bridgestone-red-darker);
            font-weight: 600;
        }
         #welcome-message-overlay .highlight-path {
            font-weight: bold;
            color: #0056b3;
        }
        #welcome-message-overlay .tutorial-prompt {
            margin-top: 25px;
            font-size: 0.95em;
            color: #555;
        }
        #welcome-message-overlay .tutorial-prompt .highlight-path {
            cursor: pointer;
            text-decoration: underline;
        }

        /* ===== CZĘŚĆ D: NOWOCZESNE AXIS I LABELS ===== */
        .axis { 
            position: absolute; 
            font-size: 11px; 
            color: #2c3e50; 
            z-index: 1; 
            padding: 5px 8px; 
            border-radius: 6px; 
            box-sizing: border-box;
            font-weight: 500;
            /* GLASSMORPHISM EFFECT */
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 249, 250, 0.8) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #sticky-y-axis, #sticky-x-axis { 
            position: fixed; 
            /* NOWOCZESNE GLASSMORPHISM CONTAINER */
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.92) 100%);
            backdrop-filter: blur(15px);
            z-index: 20; 
            overflow: hidden; 
            box-sizing: border-box; 
            border: 1px solid rgba(0, 0, 0, 0.08);
            /* SUBTLE CONTAINER SHADOW */
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.08),
                0 1px 4px rgba(0, 0, 0, 0.04),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        #sticky-y-axis .axis, #sticky-x-axis .axis { 
            /* ENHANCED GLASSMORPHISM LABELS */
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 249, 250, 0.85) 100%);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 0, 0, 0.08); 
            color: #2c3e50; 
            white-space: nowrap; 
            cursor: pointer !important; 
            pointer-events: auto !important; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            /* SUBTLE DEPTH SHADOW */
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.1),
                0 1px 3px rgba(0, 0, 0, 0.06),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        /* SHIMMER EFFECT dla axis labels */
        #sticky-y-axis .axis::before, #sticky-x-axis .axis::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s;
        }
        
        #sticky-x-axis .axis { text-align: center; }
        
        /* NOWOCZESNE HOVER EFFECTS */
        #sticky-y-axis .axis:hover, #sticky-x-axis .axis:hover { 
            background: linear-gradient(135deg, rgba(248, 249, 250, 0.95) 0%, rgba(233, 236, 239, 0.9) 100%);
            border-color: rgba(218, 41, 28, 0.3);
            color: #1a202c;
            transform: scale(1.02);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.15),
                0 2px 6px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        #sticky-y-axis .axis:hover::before, #sticky-x-axis .axis:hover::before {
            left: 100%;
        }
        
        /* SELECTED/ACTIVE STATE z Bridgestone Red accent */
        #sticky-y-axis .axis.active-axis-filter, #sticky-x-axis .axis.active-axis-filter { 
            background: linear-gradient(135deg, rgba(218, 41, 28, 0.1) 0%, rgba(218, 41, 28, 0.05) 100%);
            border: 2px solid var(--bridgestone-red);
            color: var(--bridgestone-red-darker);
            font-weight: 600;
            box-shadow: 
                0 0 20px rgba(218, 41, 28, 0.2),
                0 4px 16px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .process-node {
            position: absolute; background-color: #aedff7; border: 1px solid #5da9d4; padding: 5px 7px;
            font-size: 9px; text-align: center; cursor: pointer; border-radius: 4px;
            white-space: nowrap; box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
            transition: transform 0.15s ease-out, box-shadow 0.15s ease-out, background-color 0.3s, border-color 0.3s, opacity 0.3s, top 0.2s ease-out, left 0.2s ease-out;
            z-index: 5; box-sizing: border-box;
        }
        .process-node.can-hover:hover { transform: scale(1.05); box-shadow: 2px 2px 5px rgba(0,0,0,0.2); z-index: 10; }
        .process-node.selected { border-width: 2px !important; z-index: 11 !important; }
        .process-node.dependent-input { border-width: 2px; }
        .process-node.dependent-output { border-width: 2px; }
        .process-node.filtered-out-general, .process-node.filtered-out-axis { opacity: 0.1 !important; z-index: 3 !important; pointer-events: none !important; }
        .process-node.dimmed-selection { opacity: 0.25 !important; z-index: 4 !important; }
        .process-node.search-highlight { border: 2px solid #ff8c00 !important; background-color: #ffe0b3 !important; z-index: 12 !important; }
        .process-node.search-dimmed { opacity: 0.15 !important; z-index: 2 !important; pointer-events: none !important; }
        .process-node.tree-highlight-dimmed { opacity: 0.1 !important; z-index: 1 !important; pointer-events: none !important; }
        .process-node .node-type-symbol {
            position: absolute;
            top: 1px;
            right: 2px;
            font-size: 7px;
            font-weight: bold;
            color: #333;
            background-color: rgba(255, 255, 255, 0.6);
            padding: 0px 2px;
            border-radius: 2px;
            line-height: 1;
            user-select: none;
        }

        /* === STYL DLA STANDARD-BLOCKING - TYLKO PRZERYWANĄ RAMKA === */
        .process-node.standard-blocking {
            border-width: 2px !important;
            border-style: dashed !important;
            /* Kolory tła i obramowania są ustawiane dynamicznie w JavaScript */
        }

    .process-node.simulation-target-node {
        box-shadow: 0 0 8px 2px gold !important;
        z-index: 25 !important;
    }
    .process-node.simulation-new-node {
        border: 2px dashed #17a2b8 !important;
        background-color: #e0f7fa !important;
        z-index: 26 !important;
    }
    .process-node.simulation-new-node::after {
        content: "➕";
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        font-size: 14px;
        color: #17a2b8;
    }
    .process-node.simulation-removed {
        opacity: 0.4 !important;
        border-style: dashed !important;
        border-color: #dc3545 !important;
        background-color: #f8d7da !important;
    }
     .process-node.simulation-removed::after {
        content: "🚫";
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        font-size: 14px;
        color: #dc3545;
    }
    .process-node.simulation-shifted {
         border-color: #fd7e14 !important;
    }
    .process-node.simulation-shifted::after {
        content: "↔️";
        position: absolute;
        bottom: -12px; left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
    }

    /* Ogólne style dla węzłów w symulacji */
    .process-node.simulation-output-at-risk,
    .process-node.simulation-input-conflict,
    .process-node.simulation-ok-input,
    .process-node.simulation-ok-output {
        opacity: 1 !important;
        z-index: 20 !important;
    }
    .process-node.simulation-output-at-risk::before,
    .process-node.simulation-input-conflict::before,
    .process-node.simulation-ok-input::before,
    .process-node.simulation-ok-output::before {
        position: absolute;
        top: -12px; left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
    }

    /* --- NOWE, SZCZEGÓŁOWE STYLE --- */
    
    /* Wejście z problemem (jasnoczerwony) */
    .process-node.simulation-input-conflict {
        background-color: #f8d7da !important;
        border: 2px solid #dc3545 !important;
    }
    .process-node.simulation-input-conflict::before {
        content: "❗";
        color: #dc3545;
    }
    
    /* Wyjście z problemem (ciemnoczerwony) */
    .process-node.simulation-output-at-risk {
        background-color: #e4a1a6 !important;
        border: 2px solid #a71005 !important;
    }
    .process-node.simulation-output-at-risk::before {
        content: "⏳";
        color: #a71005;
    }

	/* Poprawne wejście w symulacji (jasnozielony) */
    .process-node.simulation-ok-input {
        background-color: #d4edda !important;
        border: 2px solid #155724 !important;
    }
    .process-node.simulation-ok-input::before {
        content: "✓";
        font-size: 12px;
        color: #155724;
    }

    /* Poprawne wyjście w symulacji (ciemnozielony) */
    .process-node.simulation-ok-output {
        background-color: #a3d9b1 !important;
        border: 2px solid #0c3c16 !important;
    }
    .process-node.simulation-ok-output::before {
        content: "✓";
        font-size: 12px;
        color: #0c3c16;
    }

        .process-node.simulation-dimmed-others {
            opacity: 0.2 !important;
            pointer-events: none !important;
            z-index: 2 !important;
        }
        .process-node.simulation-temporary-node {
            filter: grayscale(30%) opacity(80%);
            border-style: dotted !important;
        }
        .simulation-ghost-node {
            position: absolute;
            opacity: 0.35;
            border-style: dashed !important;
            border-color: #777 !important;
            background-color: rgba(174, 223, 247, 0.3) !important;
            pointer-events: none;
            z-index: 3;
            transition: none !important;
        }
        #dependency-svg .simulation-impact-path-arrow {
            stroke-width: 3.5px !important;
        }


        #dependency-svg .simulation-arrow {
            stroke-width: 2.5px;
        }
        #dependency-svg .simulation-arrow-broken {
            stroke-width: 2.5px;
            stroke: #dc3545;
            stroke-dasharray: 4, 4;
        }


        .bottom-controls-container { 
            width: 100%; 
            max-width: none; 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            box-sizing: border-box; 
        }
        .colors-toggle-bar { 
            /* NOWOCZESNY GRADIENT KONTENER */
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            padding: 15px 20px; 
            border-radius: 12px; 
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 2px 6px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.1); 
        }
        #toggle-colors-button { padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #e9e9e9; font-size: 0.9em; width: 100%; text-align: left;}
        #toggle-colors-button:hover { background-color: #ddd; }
		/* DODAJ TEN FRAGMENT */
		#reset-colors-button {
		/* ZAKTUALIZUJ TE SELEKTORY */
		#reset-colors-button, #generate-theme-button { /* <--- DODANO ID */
		padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px;
		cursor: pointer; background-color: #e9e9e9; font-size: 0.9em;
		margin-top: 10px; flex-basis: 48%; /* Zmieniamy na 48% by się zmieściły obok siebie */
		margin-left: 1%; margin-right: 1%;
		}
		#reset-colors-button:hover, #generate-theme-button:hover { /* <--- DODANO ID */
		background-color: #ddd; 
		}
		padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px;
		cursor: pointer; background-color: #e9e9e9; font-size: 0.9em;
		margin-top: 10px; flex-basis: 100%; /* Rozciągnij na całą szerokość */
		}
		#reset-colors-button:hover { background-color: #ddd; }
        .visual-controls { 
            /* NOWOCZESNY GRADIENT KONTENER */
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            padding: 20px; 
            border-radius: 12px; 
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.12),
                0 2px 6px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: flex; 
            gap: 20px; 
            align-items: center; 
            flex-wrap: wrap; 
            margin-top: 0;
        }
        .visual-controls label { font-size: 0.9em; }
        .visual-controls input[type="color"] { padding: 0; width: 30px; height: 30px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
        /* === BASIC FALLBACK STYLES FOR PROCESS DETAILS (replaced by advanced styles below) === */
        #process-details { 
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(0, 0, 0, 0.08);
        }
        #process-details h3 { 
            color: #2c3e50;
            font-weight: 600;
        }
        #process-details p { 
            margin: 6px 0; 
            font-size: 0.9em; 
            line-height: 1.5; 
            color: #495057;
        }
        #process-details strong { 
            color: #2c3e50; 
            min-width: 150px; 
            display: inline-block; 
            font-weight: 600;
        }
        #process-details button { 
            padding: 10px 16px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            background: linear-gradient(135deg, var(--bridgestone-red) 0%, #e74c3c 100%);
            color: white; 
            margin-top: 10px; 
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(218, 41, 28, 0.3);
        }
        #process-details button:hover { 
            background: linear-gradient(135deg, var(--bridgestone-red-darker) 0%, #c0392b 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(218, 41, 28, 0.4);
        }
        #dependency-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        
        #dependency-svg line { stroke-width: 2px; }
        #dependency-svg .flow-dot { }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .modal-content h3 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 20px; }
        .modal-content label { display: block; margin-top: 12px; margin-bottom: 5px; font-weight: bold; font-size: 0.9em; color: #555; }
        .modal-content input[type="text"], .modal-content input[type="time"], .modal-content textarea, .modal-content input[type="number"], .modal-content select { width: calc(100% - 16px); padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9em; box-sizing: border-box; }
        .modal-content textarea { min-height: 60px; resize: vertical; }
        .modal-content .button-group { margin-top: 25px; text-align: right; }
        .modal-content button { 
            /* Use FlowCraft unified button system - will be applied via classes */
            margin-left: 0;
        }
        .modal-content .save-button { 
            /* Will use btn-fc btn-fc-success classes */
        }
        .modal-content .cancel-button { 
            /* Will use btn-fc btn-fc-secondary classes */
            margin-left: 10px; 
        }
        .modal-content .delete-button { 
            /* Will use btn-fc btn-fc-danger classes */
            margin-right: auto; 
            float: left; 
        }
        .modal-content input.invalid, .modal-content textarea.invalid, .modal-content select.invalid { border-color: red; }
        .modal-content .error-message { color: red; font-size: 0.8em; margin-top: 2px; display: block; min-height: 1em; }
        
        #converter-panel, #tutorial-panel {
            position: fixed; top: 0;
            width: 350px;
            height: 100%;
            background-color: #f8f9fa;
            padding: 20px; box-sizing: border-box; overflow-y: auto;
            transition: transform 0.3s ease-in-out; z-index: 999;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        }
        #filter-panel, #simulation-panel, #tutorial-panel, #colors-panel { 
            position: fixed; top: 0; height: 100%; 
            box-sizing: border-box; overflow-y: auto; z-index: 999;
            right: 0; transform: translateX(100%); 
        }
        #filter-panel.open, #simulation-panel.open, #tutorial-panel.open, #colors-panel.open { transform: translateX(0); }
        
        #converter-panel { left: 0; transform: translateX(-100%); }
        #converter-panel.open { transform: translateX(0); }
        
        /* === NOWOCZESNE STYLE DLA PANELU FILTERS === */
        #filter-panel {
            width: 380px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 
                -5px 0 25px rgba(0, 0, 0, 0.1),
                -2px 0 10px rgba(0, 0, 0, 0.06),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            padding: 25px;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #filter-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        #filter-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        
        #filter-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        #filter-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
        
        #filter-panel h3 { 
            margin-top: 0; 
            margin-bottom: 25px; 
            border-bottom: 3px solid var(--bridgestone-red);
            padding-bottom: 15px;
            font-size: 1.4em;
            font-weight: 700;
            color: #2c3e50;
            position: relative;
        }
        
        #filter-panel h3::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 50px;
            height: 3px;
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        
        #filter-panel h4 { 
            margin-top: 20px; 
            margin-bottom: 12px; 
            color: var(--bridgestone-red); 
            border-bottom: 2px solid rgba(218, 41, 28, 0.2); 
            padding-bottom: 8px;
            font-size: 1.1em;
            font-weight: 600;
            position: relative;
        }
        
        #filter-panel h4::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 30px;
            height: 2px;
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        
        #filter-panel p, #filter-panel li, #filter-panel label { 
            font-size: 0.95em; 
            line-height: 1.6; 
            margin-bottom: 10px; 
            color: #495057;
        }
        
        #filter-panel select, #filter-panel input[type="time"], #filter-panel input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-radius: 6px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            font-size: 0.9em;
            color: #495057;
            box-sizing: border-box;
            margin-bottom: 12px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        #filter-panel select:hover, #filter-panel input[type="time"]:hover, #filter-panel input[type="text"]:hover {
            border-color: rgba(218, 41, 28, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        #filter-panel select:focus, #filter-panel input[type="time"]:focus, #filter-panel input[type="text"]:focus {
            outline: none;
            border-color: var(--bridgestone-red);
            box-shadow: 0 0 0 3px rgba(218, 41, 28, 0.1);
        }
        
        #filter-panel .close-panel-button { 
            /* Use FlowCraft unified button system with btn-fc-close class */
            position: absolute; 
            top: 20px; 
            right: 20px; 
            font-size: 1.8em; 
            width: 45px;
            height: 45px;
            z-index: 1001;
            user-select: none;
            pointer-events: auto;
        }
        
        #apply-filters-button {
            /* Use FlowCraft unified button system with btn-fc btn-fc-primary btn-fc-full classes */
            margin-top: 20px;
        }
        
        /* === NOWOCZESNE STYLE DLA PANELU SIMULATION === */
        #simulation-panel {
            width: 400px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 
                -5px 0 25px rgba(0, 0, 0, 0.1),
                -2px 0 10px rgba(0, 0, 0, 0.06),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            padding: 25px;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #simulation-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        #simulation-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        
        #simulation-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        #simulation-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
        
        #simulation-panel h3 { 
            margin-top: 0; 
            margin-bottom: 25px; 
            border-bottom: 3px solid var(--bridgestone-red);
            padding-bottom: 15px;
            font-size: 1.4em;
            font-weight: 700;
            color: #2c3e50;
            position: relative;
        }
        
        #simulation-panel h3::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 50px;
            height: 3px;
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        
        #simulation-panel h4 { 
            margin-top: 20px; 
            margin-bottom: 12px; 
            color: var(--bridgestone-red); 
            border-bottom: 2px solid rgba(218, 41, 28, 0.2); 
            padding-bottom: 8px;
            font-size: 1.1em;
            font-weight: 600;
            position: relative;
        }
        
        #simulation-panel h4::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 30px;
            height: 2px;
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        
        #simulation-panel p, #simulation-panel li, #simulation-panel label { 
            font-size: 0.95em; 
            line-height: 1.6; 
            margin-bottom: 10px; 
            color: #495057;
        }
        
        #simulation-panel select, #simulation-panel input[type="text"], #simulation-panel input[type="number"] {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-radius: 6px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            font-size: 0.9em;
            color: #495057;
            box-sizing: border-box;
            margin-bottom: 12px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        #simulation-panel select:hover, #simulation-panel input[type="text"]:hover, #simulation-panel input[type="number"]:hover {
            border-color: rgba(218, 41, 28, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        #simulation-panel select:focus, #simulation-panel input[type="text"]:focus, #simulation-panel input[type="number"]:focus {
            outline: none;
            border-color: var(--bridgestone-red);
            box-shadow: 0 0 0 3px rgba(218, 41, 28, 0.1);
        }
        
        #simulation-panel button {
            /* Use FlowCraft unified button system - will be applied via classes */
            margin-bottom: 8px;
        }
        
        #simulation-panel .close-panel-button { 
            /* Use FlowCraft unified button system with btn-fc-close class */
            position: absolute; 
            top: 20px; 
            right: 20px; 
            font-size: 1.8em; 
            width: 45px;
            height: 45px;
            z-index: 1001;
            user-select: none;
            pointer-events: auto;
            margin: 0;
        }
        
        /* Style dla kart symulacji */
        #simulation-targets-list .sim-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        #simulation-targets-list .sim-card.active-card {
            border-color: var(--bridgestone-red);
            box-shadow: 0 4px 16px rgba(218, 41, 28, 0.2);
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
        }
        
        #simulation-targets-list .sim-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            font-weight: 600;
            color: #2c3e50;
        }
        
        #simulation-targets-list .sim-card-header .sim-card-title {
            font-size: 0.95em;
            flex-grow: 1;
            padding-right: 10px;
        }
        
        #simulation-targets-list .sim-card-header .sim-card-remove-btn {
            padding: 4px 8px;
            font-size: 1.1em;
            line-height: 1;
            color: #dc3545;
            border: 1px solid transparent;
            background-color: transparent;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        #simulation-targets-list .sim-card-header .sim-card-remove-btn:hover {
            border-color: #dc3545;
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        }
        
        /* Nowoczesne style dla panelu tutorial */
        #tutorial-panel {
            width: 400px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 
                -5px 0 25px rgba(0, 0, 0, 0.1),
                -2px 0 10px rgba(0, 0, 0, 0.06),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            padding: 25px;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #tutorial-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        #tutorial-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        
        #tutorial-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        #tutorial-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
        
        #tutorial-panel h3 { 
            margin-top: 0; 
            margin-bottom: 25px; 
            border-bottom: 3px solid var(--bridgestone-red);
            padding-bottom: 15px;
            font-size: 1.4em;
            font-weight: 700;
            color: #2c3e50;
            position: relative;
        }
        
        #tutorial-panel h3::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 50px;
            height: 3px;
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        
        #tutorial-panel h4 { 
            margin-top: 25px; 
            margin-bottom: 12px; 
            color: var(--bridgestone-red); 
            border-bottom: 2px solid rgba(218, 41, 28, 0.2); 
            padding-bottom: 8px;
            font-size: 1.1em;
            font-weight: 600;
            position: relative;
        }
        
        #tutorial-panel h4::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 30px;
            height: 2px;
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        
        #tutorial-panel p, #tutorial-panel li { 
            font-size: 0.95em; 
            line-height: 1.7; 
            margin-bottom: 12px; 
            color: #495057;
        }
        
        #tutorial-panel ul { 
            padding-left: 25px; 
            list-style-type: none;
        }
        
        #tutorial-panel ul li {
            position: relative;
            margin-bottom: 8px;
        }
        
        #tutorial-panel ul li::before {
            content: '▶';
            position: absolute;
            left: -20px;
            color: var(--bridgestone-red);
            font-size: 0.8em;
            top: 2px;
        }
        
        #tutorial-panel ol {
            padding-left: 25px;
        }
        
        #tutorial-panel ol li {
            margin-bottom: 8px;
            position: relative;
        }
        
        #tutorial-panel ol li::marker {
            color: var(--bridgestone-red);
            font-weight: 600;
        }
        
        #tutorial-panel .code-like { 
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 4px 8px; 
            border-radius: 6px; 
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace; 
            color: var(--bridgestone-red-darker);
            font-weight: 600;
            border: 1px solid rgba(218, 41, 28, 0.2);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        #tutorial-panel strong {
            color: #2c3e50;
            font-weight: 600;
        }
        
        #tutorial-panel .close-panel-button { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            border: none; 
            font-size: 1.8em; 
            cursor: pointer; 
            line-height: 1; 
            width: 45px;
            height: 45px;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(238, 90, 82, 0.3);
            z-index: 1001;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            padding: 0;
            margin: 0;
            min-width: 45px;
            min-height: 45px;
            pointer-events: auto;
        }
        
        #tutorial-panel .close-panel-button:hover {
            background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(238, 90, 82, 0.4);
        }
        
        #tutorial-panel .close-panel-button:active {
            transform: scale(0.95);
        }
        
        #tutorial-panel .close-panel-button:focus {
            outline: 2px solid rgba(255, 255, 255, 0.5);
            outline-offset: 2px;
        }

        #converter-panel pre { background-color: #eee; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; max-height: 200px; overflow-y: auto; font-size: 0.8em; margin-top: 10px; }
        
        /* Pozostałe style specjalne dla simulation-panel */
        .simulation-type-selector-group { 
            display: flex; 
            justify-content: space-around; 
            margin-bottom: 15px; 
            gap: 8px;
        }
        .simulation-type-button {
            padding: 10px 12px; 
            border: 1px solid rgba(0, 0, 0, 0.12); 
            border-radius: 6px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); 
            cursor: pointer; 
            font-size: 0.9em;
            flex-grow: 1; 
            text-align: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            font-weight: 500;
            color: #495057;
        }
        .simulation-type-button.active { 
            background: linear-gradient(135deg, var(--bridgestone-red) 0%, #e74c3c 100%); 
            color: white; 
            border-color: var(--bridgestone-red);
            box-shadow: 0 2px 8px rgba(218, 41, 28, 0.3);
        }
        .simulation-type-button:hover:not(.active) { 
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            border-color: rgba(218, 41, 28, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .simulation-scenario-management { 
            margin-top: 20px; 
            padding-top: 15px; 
            border-top: 2px solid rgba(218, 41, 28, 0.2); 
        }
        .simulation-scenario-management label { 
            font-size: 0.95em; 
            display: block; 
            margin-bottom: 8px;
            color: #495057;
            font-weight: 500;
        }
        .simulation-scenario-management select { 
            width: calc(100% - 110px); 
            margin-right: 10px;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            border-radius: 6px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            font-size: 0.9em;
            color: #495057;
        }
        .simulation-scenario-management button { 
            width: auto; 
            padding: 8px 12px; 
            font-size: 0.9em; 
            margin-left: 5px;
        }

        #simulation-impact-info h4 { 
            margin-top: 20px; 
            margin-bottom: 12px; 
            font-size: 1.1em; 
            border-top: 2px solid rgba(218, 41, 28, 0.2); 
            padding-top: 15px;
            color: var(--bridgestone-red);
            font-weight: 600;
        }
        #simulation-impact-list { 
            list-style-type: none; 
            padding-left: 0; 
            font-size: 0.9em; 
            max-height: 180px; 
            overflow-y: auto;
        }
        #simulation-impact-list li { 
            margin-bottom: 8px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 6px;
            border-left: 3px solid var(--bridgestone-red);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }


        #dynamic-fields-container { margin-top: 15px; border-top: 1px dashed #ccc; padding-top: 15px; }
        .page-footer { 
            text-align: center; 
            margin-top: 25px;
            padding: 10px; 
            padding-top: 15px;
            font-size: 0.8em; 
            color: #333;
            border-top: 1px solid var(--bridgestone-red);
        }

        body.presentation-mode { padding: 0; overflow: hidden; }
        body.presentation-mode .top-bar { position: fixed; top: 0; left: 0; width: 100%; z-index: 1001; padding: 5px 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); justify-content: space-between; }
        body.presentation-mode .main-controls { background-color: transparent; box-shadow: none; padding: 0; flex-grow: 0; order: 1; }
        
        body.presentation-mode .menu-container { display: none !important; }
        body.presentation-mode #toggle-presentation-mode-button { display: inline-block !important; }
        body.presentation-mode #search-process-input { display: inline-block !important; }
        body.presentation-mode #reset-button { display: inline-block !important; }
        body.presentation-mode #shortcut-show-dependencies-button,
        body.presentation-mode #shortcut-simulate-impact-button {
            display: inline-block !important;
        }
        body.presentation-mode #toggle-filter-panel-button { display: inline-block !important; margin-left: 10px !important; order: 0 !important; }
        body.presentation-mode #toggle-mini-map-button { display: inline-block !important; order: 2; margin-left: auto; }

        body.presentation-mode #diagram-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; padding-top: 45px; box-sizing: border-box; border: none; margin: 0; }

        body.presentation-mode .colors-toggle-bar,
        body.presentation-mode .visual-controls,
        body.presentation-mode #process-details,
        body.presentation-mode #converter-panel,
        body.presentation-mode #simulation-panel,
        body.presentation-mode #tutorial-panel,
        body.presentation-mode .modal,
        body.presentation-mode .page-footer, 
        body.presentation-mode #link-handle-trigger,    
        body.presentation-mode .unlink-handle,           
        body.presentation-mode #dependency-panel-container
         { display: none !important; }


        #mini-map-wrapper { 
            position: fixed; 
            top: 70px; 
            right: 15px; 
            width: 220px; 
            height: 165px; 
            border: 1px solid rgba(0, 0, 0, 0.12); 
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.9) 100%); 
            backdrop-filter: blur(15px);
            box-shadow: 
                0 12px 32px rgba(0, 0, 0, 0.15),
                0 4px 16px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2); 
            z-index: 1005; 
            overflow: hidden; 
            display: none; 
            border-radius: 12px;
            border-top: 3px solid var(--bridgestone-red);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #mini-map-wrapper:hover {
            transform: scale(1.02);
            box-shadow: 
                0 16px 40px rgba(0, 0, 0, 0.2),
                0 6px 20px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        #mini-map-svg { width: 100%; height: 100%; display: block; }
        #mini-map-viewport-rect { 
            fill: rgba(218, 41, 28, 0.15); 
            stroke: rgba(218, 41, 28, 0.8); 
            stroke-width: 2px; 
            rx: 2; 
            ry: 2;
        }
        .mini-map-node { 
            stroke: #495057; 
            stroke-width: 0.8px; 
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        /* === NOWOCZESNE STYLE DLA PANELU DEPENDENCIES === */
        #dependency-panel-container {
            position: fixed;
            top: 60px;
            width: 50vw;
            min-width: 450px;
            max-width: 900px;
            right: -50vw;
			display: flex; 
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            height: calc(100vh - 80px);
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-left: 3px solid var(--bridgestone-red);
            box-shadow: 
                -8px 0 40px rgba(0, 0, 0, 0.15),
                -4px 0 16px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
            z-index: 1010;
            flex-direction: column;
        }
        
        #dependency-panel-container.visible {
            right: 0;
			display: flex; 
        }
        
        #dependency-panel-title-bar { 
            padding: 20px 25px; 
            border-bottom: 3px solid rgba(218, 41, 28, 0.2);
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            flex-shrink: 0; 
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            position: relative;
        }
        
        #dependency-panel-title-bar::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 25px;
            width: 60px;
            height: 3px;
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        
        #dependency-panel-title-bar h3 { 
            margin: 0; 
            font-size: 1.3em; 
            font-weight: 600;
            color: #2c3e50;
            flex-grow: 1; 
        }
        
        #highlight-tree-nodes-button {
            padding: 10px 16px; 
            font-size: 0.9em; 
            margin-left: 15px; 
            background: linear-gradient(135deg, var(--bridgestone-red) 0%, #e74c3c 100%);
            color: white; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(218, 41, 28, 0.3);
        }
        
        #highlight-tree-nodes-button:hover { 
            background: linear-gradient(135deg, var(--bridgestone-red-darker) 0%, #c0392b 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(218, 41, 28, 0.4);
        }
        
        .close-dependency-panel-button { 
            font-size: 1.8em; 
            border: none; 
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
            cursor: pointer; 
            line-height: 1; 
            margin-left: 15px; 
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(238, 90, 82, 0.3);
        }
        
        .close-dependency-panel-button:hover {
            background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(238, 90, 82, 0.4);
        }
        
        .close-dependency-panel-button:active {
            transform: scale(0.95);
        }

        #dependency-tree-content { 
            flex-grow: 1; 
            overflow: auto; 
            padding: 25px; 
            background: linear-gradient(135deg, #fdfdfd 0%, #f8f9fa 100%);
        }
        
        #dependency-tree-content::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        #dependency-tree-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        
        #dependency-tree-content::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        #dependency-tree-content::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
        
        #dependency-tree-svg { 
            display: block; 
            min-width: 100%; 
        }
        
        /* Nowoczesne style dla węzłów drzewa zależności */
        .dep-tree-node rect { 
            fill: #ffffff;
            stroke: var(--bridgestone-red); 
            stroke-width: 2px; 
            rx: 6; 
            ry: 6; 
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .dep-tree-node.selected-root rect { 
            fill: #fff5f5;
            stroke: var(--bridgestone-red-darker); 
            stroke-width: 3px; 
            filter: drop-shadow(0 4px 8px rgba(218, 41, 28, 0.2));
        }
        
        .dep-tree-node.not-in-view rect { 
            fill: #e9ecef; 
            stroke: #adb5bd; 
            stroke-dasharray: 4,4; 
            opacity: 0.8;
        }
        
        .dep-tree-node text { 
            font-size: 10px; 
            text-anchor: middle; 
            dominant-baseline: middle; 
            fill: #212529; 
            pointer-events: none; 
            font-weight: 600;
        }
        
        .dep-tree-node text.toggle-text { 
            font-size: 13px; 
            text-anchor: start; 
            cursor: pointer; 
            fill: #343a40; 
            font-weight: 600;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .dep-tree-node text.toggle-text:hover { 
            fill: var(--bridgestone-red); 
            transform: scale(1.05);
        }
        
        .dep-tree-link { 
            stroke: #495057; 
            stroke-width: 2px; 
            fill: none; 
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .dep-tree-node.clickable { 
            cursor: pointer; 
        }
        
        .dep-tree-node.clickable:hover rect { 
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.15)) brightness(102%);
            transform: scale(1.02);
        }
        
        /* Hover effect for dark mode */
        body.dark-mode .dep-tree-node.clickable:hover rect {
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5)) brightness(110%);
            transform: scale(1.02);
        }
        
        .dep-tree-node.path-highlight rect { 
            fill: #fef5e7;
            stroke: #d69e2e; 
            stroke-width: 3px; 
            filter: drop-shadow(0 4px 8px rgba(214, 158, 46, 0.3));
        }
        
        .dep-tree-link.path-highlight { 
            stroke: #d69e2e; 
            stroke-width: 3px; 
            filter: drop-shadow(0 1px 3px rgba(214, 158, 46, 0.3));
        }
        
        /* Kolory dla różnych typów procesów w dependency tree są teraz ustawiane dynamicznie w JavaScript */

        /* Style dla przycisku show dependencies w menu */
        #menu-dependency-panel-trigger.disabled { 
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #e9ecef !important;
            color: #6c757d !important;
        }
        
        #menu-dependency-panel-trigger.disabled:hover {
            background-color: #e9ecef !important;
            transform: none !important;
            box-shadow: none !important;
        }
        
        #menu-dependency-panel-trigger svg {
            vertical-align: middle; 
            margin-right: 5px;
        }


        #link-handle-trigger, .unlink-handle
         {
            position: absolute;
            width: 14px;
            height: 14px;
            color: white;
            border-radius: 50%;
            display: none; 
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            z-index: 15;
            user-select: none;
            line-height: 14px;
        }
        #link-handle-trigger { background-color: #28a745; cursor: grab; }
        #link-handle-trigger:hover { background-color: #218838; }

        .unlink-handle { background-color: #f44336; cursor: pointer; }
        .unlink-handle:hover { background-color: #d32f2f; }

        .temp-link-line { 
		stroke: #28a745; 
		stroke-width: 2.5px; 
		stroke-dasharray: 5,5; 
		pointer-events: none; /* <-- TO JEST KLUCZOWA DODANA WŁAŚCIWOŚĆ */
	}
        .process-node.link-target-hover { outline: 2px dashed #28a745; outline-offset: 2px; }
        #toggle-mini-map-button:hover { background-color: #ddd; }



        .modal-content {
            border-top: 4px solid var(--bridgestone-red);
        }

        .page-footer {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bridgestone-footer-symbol {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            fill: var(--bridgestone-red);
        }
		.context-menu {
            display: none;
            position: absolute;
            z-index: 1010;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            padding: 5px 0;
            min-width: 150px;
        }
        .context-menu-item {
            padding: 8px 12px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .context-menu-item:hover {
            background-color: #f0f0f0;
        }

        #notification-bar {
            display: none;
            position: fixed; 
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            max-width: calc(100% - 40px);
            min-width: 320px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            color: #2c3e50;
            padding: 16px 20px;
            text-align: left;
            z-index: 2000;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.15),
                0 4px 15px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(0, 0, 0, 0.05);
            font-size: 0.9em;
            line-height: 1.5;
            box-sizing: border-box;
            border-radius: 12px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            backdrop-filter: blur(10px);
            animation: notificationSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes notificationSlideIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
        }
        
        @keyframes notificationSlideOut {
            from {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateX(-50%) translateY(20px) scale(0.95);
            }
        }
        
        #notification-message {
            display: inline-block;
            max-width: calc(100% - 50px);
            text-align: left;
            vertical-align: middle;
            font-weight: 500;
        }
        #notification-message pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: rgba(0,0,0,0.1);
            padding: 5px;
            border-radius: 3px;
            margin-top: 5px;
            font-size: 0.95em;
            max-height: 100px;
            overflow-y: auto; 
        }
        /* === NOWOCZESNY STYL DLA NOTIFICATION CLOSE BUTTON === */
        #notification-close {
            float: right;
            background: linear-gradient(135deg, rgba(44, 62, 80, 0.1) 0%, rgba(44, 62, 80, 0.05) 100%);
            border: 1px solid rgba(44, 62, 80, 0.2);
            border-radius: 8px;
            color: #2c3e50;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            line-height: 1;
            padding: 8px 12px;
            margin-left: 15px;
            min-width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        #notification-close::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }
        
        #notification-close:hover::before {
            left: 100%;
        }
        
        #notification-close:hover {
            background: linear-gradient(135deg, rgba(44, 62, 80, 0.15) 0%, rgba(44, 62, 80, 0.1) 100%);
            border-color: rgba(218, 41, 28, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        #notification-close:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }
        /* Style dla resizer dependency panel */
        #dependency-panel-resizer {
            position: absolute;
            left: 0;
            top: 0;
            width: 8px;
            height: 100%;
            cursor: col-resize;
            z-index: 1000;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(90deg, transparent 0%, rgba(218, 41, 28, 0.1) 50%, transparent 100%);
        }
        
        #dependency-panel-resizer:hover {
            background: linear-gradient(90deg, transparent 0%, rgba(218, 41, 28, 0.3) 50%, transparent 100%);
            box-shadow: inset -2px 0 4px rgba(218, 41, 28, 0.2);
        }
	/* === POCZĄTEK NOWEGO, POPRAWIONEGO BLOKU CSS DLA KART SYMULACJI === */

#simulation-targets-list .sim-card {
    background-color: #f9f9f9;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 10px;
    margin-bottom: 10px;
    transition: all 0.2s ease-in-out;
}

#simulation-targets-list .sim-card.active-card {
    border-color: #007bff;
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
    background-color: #fff;
}

#simulation-targets-list .sim-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    font-weight: bold;
}

#simulation-targets-list .sim-card-header .sim-card-title {
    font-size: 0.95em;
    flex-grow: 1;
    padding-right: 10px;
}

#simulation-targets-list .sim-card-header .sim-card-remove-btn {
    padding: 2px 6px;
    font-size: 1.2em;
    line-height: 1;
    color: #dc3545;
    border: 1px solid transparent;
    background-color: transparent;
    cursor: pointer;
    border-radius: 3px;
}

#simulation-targets-list .sim-card-header .sim-card-remove-btn:hover {
    border-color: #dc3545;
    background-color: #f8d7da;
}

/* KLUCZOWE STYLE DO POKAZYWANIA KONTROLEK */
#simulation-targets-list .sim-card-controls {
    display: none; /* Domyślnie ukryte */
    padding-top: 10px;
    margin-top: 10px;
    border-top: 1px dashed #ccc;
}

.sim-card.active-card .sim-card-controls {
    display: block; /* Pokazywane dla aktywnej karty */
}

.sim-card-controls .sim-type-group {
    display: flex;
    gap: 5px;
    margin-bottom: 10px;
}

/* === NOWOCZESNE STYLE DLA SIM-CARD CONTROLS BUTTONS === */
.sim-card-controls .sim-type-group button {
    flex-grow: 1;
    padding: 8px 12px;
    font-size: 0.85em;
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    color: #2c3e50;
    border: 1px solid rgba(0, 0, 0, 0.08);
    cursor: pointer;
    border-radius: 6px;
    font-weight: 500;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
    position: relative;
    overflow: hidden;
}

.sim-card-controls .sim-type-group button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
    transition: left 0.5s;
}

.sim-card-controls .sim-type-group button:hover::before {
    left: 100%;
}

.sim-card-controls .sim-type-group button:hover {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-color: rgba(218, 41, 28, 0.3);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.sim-card-controls .sim-type-group button.active {
    background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
    color: white;
    border-color: #0056b3;
    box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
    transform: none;
}

.sim-card-controls .sim-type-group button.active:hover {
    background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
    box-shadow: 0 6px 16px rgba(0, 123, 255, 0.4);
}

.sim-card-controls .sim-param-group label {
    font-size: 0.85em;
    margin-bottom: 3px;
    display: block;
    color: #333;
}

.sim-card-controls .sim-param-group input {
    width: 100%;
    padding: 6px;
    font-size: 0.9em;
    box-sizing: border-box;
    border: 1px solid #ccc;
    border-radius: 3px;
}
#simulation-targets-list .sim-card {
    background-color: #f9f9f9;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 10px;
    margin-bottom: 10px;
    transition: all 0.2s ease-in-out;
}

/* Styl dla aktywnej (rozwiniętej) karty */
#simulation-targets-list .sim-card.active-card {
    border-color: #007bff;
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
    background-color: #fff;
}

/* Nagłówek karty (zawsze widoczny) */
#simulation-targets-list .sim-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    font-weight: bold;
}

#simulation-targets-list .sim-card-header .sim-card-title {
    font-size: 0.95em;
    flex-grow: 1;
    padding-right: 10px;
}

/* Przycisk usuwania procesu z symulacji */
#simulation-targets-list .sim-card-header .sim-card-remove-btn {
    padding: 2px 6px;
    font-size: 1.2em;
    line-height: 1;
    color: #dc3545;
    border: 1px solid transparent;
    background-color: transparent;
    cursor: pointer;
    border-radius: 3px;
}

#simulation-targets-list .sim-card-header .sim-card-remove-btn:hover {
    border-color: #dc3545;
    background-color: #f8d7da;
}

/* Kontener na kontrolki (przyciski i pola input), DOMYŚLNIE UKRYTY */
#simulation-targets-list .sim-card-controls {
    display: none;
    padding-top: 10px;
    margin-top: 10px;
    border-top: 1px dashed #ccc;
}

/* KLUCZOWA REGUŁA: Pokaż kontrolki, gdy karta ma klasę .active-card */
#simulation-targets-list .sim-card.active-card .sim-card-controls {
    display: block;
}

/* Kontener na przyciski "Shift" / "Remove" */
.sim-card-controls .sim-type-group {
    display: flex;
    gap: 5px;
    margin-bottom: 10px;
}

.sim-card-controls .sim-type-group button {
    flex-grow: 1;
    padding: 8px 12px;
    font-size: 0.85em;
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    color: #2c3e50;
    border: 1px solid rgba(0, 0, 0, 0.08);
    cursor: pointer; 
    border-radius: 6px;
    font-weight: 500;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
    position: relative;
    overflow: hidden;
}

.sim-card-controls .sim-type-group button.active {
    background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
    color: white;
    border-color: #0056b3;
    box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
    transform: none;
}

/* Kontener na pola do edycji WD i czasu */
.sim-card-controls .sim-param-group label {
    font-size: 0.85em;
    margin-bottom: 3px;
    display: block;
    color: #333;
}

.sim-card-controls .sim-param-group input {
    width: 100%;
    padding: 6px;
    font-size: 0.9em;
    box-sizing: border-box;
    border: 1px solid #ccc;
    border-radius: 3px;
}

/* START NOWYCH STYLI DLA GÓRNEGO PASKA I DOLNEGO PANELU */

.visual-shortcut-buttons {
            display: flex;
            align-items: center;
    gap: 5px; /* Dodaje odstęp między ikonami */
}

        /* === NOWOCZESNE STYLE DLA VISUAL SHORTCUT BUTTONS === */
        .visual-shortcut-buttons button {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            color: #2c3e50;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
            padding: 10px 14px;
            font-weight: 500;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
            position: relative;
            overflow: hidden;
        }

        .visual-shortcut-buttons button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }

        .visual-shortcut-buttons button:hover::before {
            left: 100%;
        }

        .visual-shortcut-buttons button:hover {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-color: rgba(218, 41, 28, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .visual-shortcut-buttons button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

#theme-toggle-button .sun-icon,
#theme-toggle-button .moon-icon {
    vertical-align: middle;
}

body:not(.dark-mode) #theme-toggle-button .moon-icon {
    display: none;
}

body.dark-mode #theme-toggle-button .sun-icon {
    display: none;
}

        /* Ukrycie starego panelu, ponieważ został zastąpiony nowym bocznym panelem */
        .colors-toggle-bar { display: none !important; }
        .visual-controls { display: none !important; }

        /* Usunięcie przycisków Reset/Generate z manualnego panelu kolorów */
        #reset-colors-button, #generate-theme-button { display: none !important; }

        /* === STYLE DLA MENU SUBSECTIONS === */
        .menu-subsection {
            margin-bottom: 8px;
        }
        
        .menu-subsection-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #2c3e50;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 6px;
            padding: 10px 12px;
            font-weight: 600;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
            position: relative;
            overflow: hidden;
        }
        
        .menu-subsection-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }
        
        .menu-subsection-header:hover::before {
            left: 100%;
        }
        
        .menu-subsection-header:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            border-color: rgba(218, 41, 28, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .menu-arrow {
            font-size: 0.8em;
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .menu-subsection-header.expanded .menu-arrow {
            transform: rotate(180deg);
        }
        
        .menu-subsection-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 0 0 6px 6px;
            margin-top: 2px;
        }
        
        .menu-subsection-content.expanded {
            max-height: 300px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-top: none;
            padding: 8px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.03);
        }
        
        .menu-subsection-content button,
        .menu-subsection-content label {
            margin-bottom: 6px;
            width: 100%;
            font-size: 0.85em;
        }
        
        .menu-subsection-content button:last-child,
        .menu-subsection-content label:last-child {
            margin-bottom: 0;
        }
        
        /* Dark mode styles for subsections */
        body.dark-mode .menu-subsection-header {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode .menu-subsection-header:hover {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            border-color: rgba(218, 41, 28, 0.5);
        }
        
        body.dark-mode .menu-subsection-content {
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
        }
        
        body.dark-mode .menu-subsection-content.expanded {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: none;
        }
        
        /* === STYLE DLA LOAD JSON SECTION === */
        .load-json-section {
            text-align: center;
            padding: 12px 8px;
            margin: 8px 0;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 6px;
        }
        
        .load-json-section label {
            display: block;
            margin-bottom: 8px;
            text-align: center;
        }
        
        body.dark-mode .load-json-section {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* === STYLE DLA LOAD EXCEL SECTION === */
        .load-excel-section {
            padding: 12px;
            margin: 8px 0;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .excel-file-browser {
            margin-bottom: 12px;
            padding: 8px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 6px;
        }
        
        .excel-file-label {
            display: inline-block;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            color: #2c3e50;
            padding: 8px 16px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85em;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
            position: relative;
            overflow: hidden;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            text-align: center;
        }
        
        .excel-file-label::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }
        
        .excel-file-label:hover::before {
            left: 100%;
        }
        
        .excel-file-label:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            border-color: rgba(218, 41, 28, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        #excel-file-input {
            display: none;
        }
        
        .file-name-display {
            display: block;
            margin-top: 6px;
            font-size: 0.75em;
            color: #6c757d;
            font-style: italic;
        }
        
        .excel-action-button {
            width: 100%;
            margin-bottom: 8px;
            padding: 10px 16px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            color: #2c3e50;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 6px;
            font-weight: 500;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
            position: relative;
            overflow: hidden;
        }
        
        .excel-action-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }
        
        .excel-action-button:hover::before {
            left: 100%;
        }
        
        .excel-action-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            border-color: rgba(218, 41, 28, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .excel-action-button:disabled {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            color: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .excel-converters {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px dashed rgba(0, 0, 0, 0.1);
        }
        
        .json-preview-container {
            margin-top: 12px;
            padding: 10px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 6px;
        }
        
        .json-preview-container h6 {
            margin: 0 0 8px 0;
            font-size: 0.8em;
            font-weight: 600;
            color: #495057;
        }
        
        .json-preview-content {
            max-height: 120px;
            overflow-y: auto;
            padding: 8px;
            background: #f8f9fa;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.7em;
            color: #495057;
            white-space: pre-wrap;
            margin-bottom: 8px;
        }
        
        /* === DARK MODE DLA LOAD EXCEL === */
        body.dark-mode .load-excel-section {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode .excel-file-browser {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode .excel-file-label {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode .excel-file-label:hover {
            background: linear-gradient(135deg, #5a6c7d 0%, #3a4a5d 100%);
            border-color: rgba(218, 41, 28, 0.5);
        }
        
        body.dark-mode .file-name-display {
            color: #cbd5e0;
        }
        
        body.dark-mode .excel-action-button {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode .excel-action-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #5a6c7d 0%, #3a4a5d 100%);
            border-color: rgba(218, 41, 28, 0.5);
        }
        
        body.dark-mode .excel-action-button:disabled {
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%);
            color: #9ca3af;
        }
        
        body.dark-mode .json-preview-container {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode .json-preview-container h6 {
            color: #e2e8f0;
        }
        
        body.dark-mode .json-preview-content {
            background: #1a202c;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
        }

        /* === NOWOCZESNE STYLE DLA CONTEXT MENU === */
        .context-menu {
            display: none;
            position: absolute;
            z-index: 1010;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.1),
                0 5px 15px rgba(0, 0, 0, 0.07);
            padding: 8px;
            min-width: 180px;
            animation: dropdownSlideIn 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .context-menu-item {
            padding: 10px 14px;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            display: block;
            width: 100%;
            box-sizing: border-box;
            text-align: left;
            background: none;
            border: none;
            border-radius: 6px;
            color: #2c3e50;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .context-menu-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }
        
        .context-menu-item:hover::before {
            left: 100%;
        }
        
        .context-menu-item:hover {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-color: rgba(218, 41, 28, 0.3);
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .context-menu-item:active {
            transform: translateX(2px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

/* === NOWOCZESNE STYLE DLA WYSUWANEGO PANELU PROCESS DETAILS === */
#process-details {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    backdrop-filter: blur(10px);
    box-shadow: 
        0 -5px 25px rgba(0, 0, 0, 0.15),
        0 -2px 10px rgba(0, 0, 0, 0.1),
        0 0 0 1px rgba(255, 255, 255, 0.1);
    border-top: 1px solid rgba(0, 0, 0, 0.08);
    z-index: 990;
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
    max-height: 52px;
    transform: translateY(100%);
}

/* Kiedy panel staje się aktywny (wybrano proces), wsuwa się na ekran */
#process-details.active {
    transform: translateY(0);
    border-top: 3px solid var(--bridgestone-red);
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    box-shadow: 
        0 -8px 40px rgba(0, 0, 0, 0.2),
        0 -4px 16px rgba(0, 0, 0, 0.15),
        0 0 0 1px rgba(255, 255, 255, 0.2);
}

/* Kiedy jest rozwinięty, zwiększamy jego wysokość */
#process-details.expanded {
    max-height: 50vh;
}

#details-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 25px;
    height: 52px;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.details-title-container {
    display: flex;
    align-items: center;
    gap: 12px;
    color: #6c757d;
    pointer-events: none;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.details-icon {
    color: var(--bridgestone-red);
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

#process-details.active .details-title-container {
    color: #2c3e50;
}

#details-header h3 {
    margin: 0;
    font-size: 1.2em;
    font-weight: 600;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.details-controls {
    visibility: hidden;
    opacity: 0;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

#process-details.active .details-controls {
    visibility: visible;
    opacity: 1;
}

#details-toggle-button {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.9em;
    font-weight: 500;
    color: #495057;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

#details-toggle-button:hover {
    background: linear-gradient(135deg, #dee2e6 0%, #ced4da 100%);
    border-color: rgba(218, 41, 28, 0.3);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

#details-toggle-button .button-text-show,
#details-toggle-button .chevron-down {
    display: inline-block;
}

#details-toggle-button .button-text-hide,
#details-toggle-button .chevron-up {
    display: none;
}

#process-details.expanded #details-toggle-button .button-text-show,
#process-details.expanded #details-toggle-button .chevron-down {
    display: none;
}

#process-details.expanded #details-toggle-button .button-text-hide,
#process-details.expanded #details-toggle-button .chevron-up {
    display: inline-block;
}

/* Flexbox container dla zawartości i przycisków */
#details-content-container {
    display: flex;
    gap: 20px;
    height: calc(50vh - 52px);
    padding: 25px;
    padding-top: 15px;
}

#details-content-wrapper {
    flex: 1;
    overflow-y: auto;
    padding-right: 15px;
}

#details-content-wrapper::-webkit-scrollbar {
    width: 8px;
}

#details-content-wrapper::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.05);
    border-radius: 4px;
}

#details-content-wrapper::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
}

#details-content-wrapper::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.3);
}

/* Style dla kontenera przycisków akcji */
#details-action-buttons {
    width: 180px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 20px;
    background: linear-gradient(135deg, rgba(248, 249, 250, 0.8) 0%, rgba(233, 236, 239, 0.8) 100%);
    border-radius: 8px;
    border: 1px solid rgba(0, 0, 0, 0.05);
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

#process-details.expanded #details-action-buttons {
    opacity: 1;
    visibility: visible;
}

#details-action-buttons h4 {
    margin: 0 0 15px 0;
    font-size: 1em;
    font-weight: 600;
    color: #2c3e50;
    text-align: center;
    border-bottom: 2px solid rgba(218, 41, 28, 0.2);
    padding-bottom: 8px;
}

#details-content-wrapper p { 
    margin: 8px 0; 
    font-size: 0.95em; 
    line-height: 1.6; 
    color: #495057;
}

#details-content-wrapper strong { 
    color: #2c3e50; 
    min-width: 150px; 
    display: inline-block; 
    font-weight: 600;
}

/* Style dla przycisków akcji */
#details-action-buttons button { 
    width: 100%;
    padding: 12px 16px; 
    border: none; 
    border-radius: 6px; 
    cursor: pointer; 
    font-size: 0.9em;
    font-weight: 500;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

#details-action-buttons .edit-process-button { 
    background: linear-gradient(135deg, var(--bridgestone-red) 0%, #e74c3c 100%);
    color: white; 
    box-shadow: 0 2px 8px rgba(218, 41, 28, 0.3);
}

#details-action-buttons .edit-process-button:hover { 
    background: linear-gradient(135deg, var(--bridgestone-red-darker) 0%, #c0392b 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(218, 41, 28, 0.4);
}

#details-action-buttons .simulate-impact-button { 
    background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
    color: #212529;
    font-weight: 600;
    box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3);
}

#details-action-buttons .simulate-impact-button:hover { 
    background: linear-gradient(135deg, #e0a800 0%, #d39e00 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(255, 193, 7, 0.4);
}

/* Zachowanie starych stylów dla przycisków które mogą pozostać w details-content-wrapper */
#details-content-wrapper button { 
    padding: 10px 16px; 
    border: none; 
    border-radius: 6px; 
    cursor: pointer; 
    background: linear-gradient(135deg, var(--bridgestone-red) 0%, #e74c3c 100%);
    color: white; 
    margin-top: 12px; 
    margin-right: 8px;
    font-size: 0.9em;
    font-weight: 500;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 8px rgba(218, 41, 28, 0.3);
}

#details-content-wrapper button:hover { 
    background: linear-gradient(135deg, var(--bridgestone-red-darker) 0%, #c0392b 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(218, 41, 28, 0.4);
}
body {
    padding-bottom: 20px; /* Zresetuj padding, bo panel jest teraz w przepływie */
}
        body.dark-mode #dependency-panel-resizer {
            background: linear-gradient(90deg, transparent 0%, rgba(218, 41, 28, 0.2) 50%, transparent 100%);
        }
        
        body.dark-mode #dependency-panel-resizer:hover {
            background: linear-gradient(90deg, transparent 0%, rgba(218, 41, 28, 0.4) 50%, transparent 100%);
            box-shadow: inset -2px 0 4px rgba(218, 41, 28, 0.3);
        }
	</style>

    <style>
        body.dark-mode {
            /* NOWOCZESNE DARK GRADIENT TŁO */
            background: linear-gradient(135deg, #0d1117 0%, #1c2128 25%, #21262d 75%, #161b22 100%);
            background-attachment: fixed;
            color: #e0e0e0;
        }
        
        /* DODATKOWA TEKSTURA SUBTLNA DLA DARK MODE */
        body.dark-mode::before {
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(218, 41, 28, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(218, 41, 28, 0.05) 0%, transparent 50%);
        }

        body.dark-mode .top-bar {
            /* NOWOCZESNE DARK GLASSMORPHISM TŁO */
            background: linear-gradient(135deg, rgba(45, 55, 72, 0.25) 0%, rgba(26, 32, 44, 0.15) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        body.dark-mode .main-controls {
            /* NOWOCZESNY DARK GRADIENT KONTENER */
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        body.dark-mode .main-controls button,
        body.dark-mode .main-controls input[type="search"],
        body.dark-mode #shortcut-show-dependencies-button,
        body.dark-mode #shortcut-simulate-impact-button {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%) !important;
            color: #e2e8f0 !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
        }

        body.dark-mode .main-controls button:hover:not(:disabled),
        body.dark-mode .main-controls input[type="search"]:hover,
        body.dark-mode #shortcut-show-dependencies-button:hover:not(:disabled),
        body.dark-mode #shortcut-simulate-impact-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%) !important;
            border-color: rgba(218, 41, 28, 0.5) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;
        }
        
        body.dark-mode #shortcut-show-dependencies-button:disabled,
        body.dark-mode #shortcut-simulate-impact-button:disabled {
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%) !important;
            color: #9ca3af !important;
            opacity: 0.6;
        }
        body.dark-mode #shortcut-show-dependencies-button:disabled:hover,
        body.dark-mode #shortcut-simulate-impact-button:disabled:hover {
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%) !important;
        }

        /* === DARK MODE STYLES FOR VISUAL SHORTCUT BUTTONS === */
        body.dark-mode .visual-shortcut-buttons button {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%) !important;
            color: #e2e8f0 !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
        }

        body.dark-mode .visual-shortcut-buttons button:hover {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%) !important;
            border-color: rgba(218, 41, 28, 0.5) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;
        }

        /* === NOWOCZESNE STYLE DLA PRZYCISKÓW FILTERS I MINI-MAP === */
        #toggle-filter-panel-button, #toggle-mini-map-button {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            color: #2c3e50;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
            padding: 10px 16px;
            font-weight: 500;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
            position: relative;
            overflow: hidden;
        }

        #toggle-filter-panel-button::before, #toggle-mini-map-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }

        #toggle-filter-panel-button:hover::before, #toggle-mini-map-button:hover::before {
            left: 100%;
        }

        #toggle-filter-panel-button:hover, #toggle-mini-map-button:hover {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-color: rgba(218, 41, 28, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        #toggle-filter-panel-button:active, #toggle-mini-map-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }
        
        /* Dark mode styles for Filters and Mini-map buttons */
        body.dark-mode #toggle-filter-panel-button, body.dark-mode #toggle-mini-map-button {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%) !important;
            color: #e2e8f0 !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
        }
        
        body.dark-mode #toggle-filter-panel-button:hover, body.dark-mode #toggle-mini-map-button:hover {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%) !important;
            border-color: rgba(218, 41, 28, 0.5) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;
        }
        
        body.dark-mode #menu-dependency-panel-trigger.disabled {
            background-color: #4a5568 !important;
            color: #9ca3af !important;
        }
        
        body.dark-mode #menu-dependency-panel-trigger.disabled:hover {
            background-color: #4a5568 !important;
            transform: none !important;
            box-shadow: none !important;
        }
        
        body.dark-mode #menu-dependency-panel-trigger svg {
            stroke: #e2e8f0;
        }

        body.dark-mode #menu-button {
            background-color: var(--bridgestone-red);
            color: white;
            border: 1px solid var(--bridgestone-red-darker);
        }
        body.dark-mode #menu-button:hover {
            background-color: var(--bridgestone-red-darker);
            color: white;
        }
        body.dark-mode #menu-button svg {
            fill: white;
        }


        body.dark-mode #diagram-container {
            /* GRADIENT TŁO ZAMIAST PŁASKIEGO DARK */
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 50%, #1e2530 100%);
            /* NOWOCZESNE OBRAMOWANIE Z GRADIENTEM */
            border-image: linear-gradient(135deg, var(--bridgestone-red) 0%, #e74c3c 50%, var(--bridgestone-red-darker) 100%) 1;
            /* NOWOCZESNE CIENIE 3D DLA DARK MODE */
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.3),
                0 8px 16px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }
        
        /* SUBTLE ANIMATION ON HOVER DLA DARK MODE */
        body.dark-mode #diagram-container:hover {
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.4),
                0 10px 20px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.08),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }
        
        body.dark-mode #welcome-message-overlay {
            background-color: rgba(30, 30, 30, 0.97);
            color: #e0e0e0;
        }
        body.dark-mode #welcome-message-overlay h2 {
            color: var(--bridgestone-red);
        }
        body.dark-mode #welcome-message-overlay strong {
            color: #f5f5f5;
        }
        body.dark-mode #welcome-message-overlay .highlight-path {
            color: #64b5f6;
        }


                body.dark-mode .process-node {
            background-color: #2c3e50;
            border-color: #4a657a;
            color: #e0e0e0;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
        }
        body.dark-mode .process-node.can-hover:hover {
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            border-color: #608da8;
        }
        body.dark-mode .process-node.selected {
            border-color: var(--bridgestone-red) !important;
            box-shadow: 0 0 8px var(--bridgestone-red) !important;
        }
		
        /* === DARK MODE DLA STANDARD-BLOCKING - KOLORY USTAWIANE DYNAMICZNIE === */
        body.dark-mode .process-node.standard-blocking {
            /* Kolory tła, obramowania i cienia są ustawiane dynamicznie w JavaScript
               na podstawie aktualnych wartości configColors.node i configColors.blockingNode */
        }
		
        body.dark-mode .process-node.search-highlight {
            background-color: #5c431f !important;
            border-color: #ff8c00 !important;
            color: #fff !important;
        }
         body.dark-mode .process-node .node-type-symbol {
            color: #111;
            background-color: rgba(200, 200, 200, 0.7);
        }
        body.dark-mode #dependency-svg line {
            stroke: #aaa;
        }

        body.dark-mode .modal-content {
            background-color: #2b2b2b;
            color: #e0e0e0;
            border: 1px solid #444;
            border-top: 4px solid var(--bridgestone-red);
        }
        body.dark-mode .modal-content h3 {
            border-bottom: 1px solid #444;
        }
        body.dark-mode .modal-content label {
            color: #ccc;
        }
        body.dark-mode .modal-content input[type="text"],
        body.dark-mode .modal-content input[type="time"],
        body.dark-mode .modal-content textarea,
        body.dark-mode .modal-content input[type="number"],
        body.dark-mode .modal-content select {
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #555;
        }
        body.dark-mode .modal-content input.invalid,
        body.dark-mode .modal-content textarea.invalid,
        body.dark-mode .modal-content select.invalid {
            border-color: #e57373;
        }
        body.dark-mode .modal-content .error-message {
            color: #e57373;
        }
        body.dark-mode .modal-content .save-button { background-color: #4CAF50; color: white; }
        body.dark-mode .modal-content .save-button:hover { background-color: #45a049; }
        body.dark-mode .modal-content .cancel-button { background-color: #777; color: white; }
        body.dark-mode .modal-content .cancel-button:hover { background-color: #666; }
        body.dark-mode .modal-content .delete-button { background-color: #f44336; color: white; }
        body.dark-mode .modal-content .delete-button:hover { background-color: #e53935; }


        body.dark-mode #converter-panel {
            background-color: #252525;
            color: #e0e0e0;
            box-shadow: -2px 0 5px rgba(0,0,0,0.3);
        }
        body.dark-mode #converter-panel h3 {
            border-bottom: 1px solid #444;
        }
        body.dark-mode #converter-panel input[type="file"] {
            background-color: #333;
            color: #e0e0e0;
            border-color: #555;
        }
        body.dark-mode #converter-panel button {
            background-color: #007bff;
            color: white;
        }
        body.dark-mode #converter-panel button:hover {
             background-color: #0056b3;
        }
        
        /* === KOMPLETNA STYLIZACJA DARK MODE DLA SIMULATION PANEL === */
        body.dark-mode #simulation-panel {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            backdrop-filter: blur(10px);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                -5px 0 25px rgba(0, 0, 0, 0.4),
                -2px 0 10px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.05);
        }
        
        body.dark-mode #simulation-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        body.dark-mode #simulation-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        body.dark-mode #simulation-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        body.dark-mode #simulation-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        body.dark-mode #simulation-panel h3 { 
            color: #f7fafc;
            border-bottom: 3px solid var(--bridgestone-red);
        }
        
        body.dark-mode #simulation-panel h3::after {
            background: linear-gradient(90deg, var(--bridgestone-red), rgba(218, 41, 28, 0.3));
        }
        
        body.dark-mode #simulation-panel h4 {
            color: #ffccc7;
            border-bottom: 2px solid rgba(218, 41, 28, 0.3);
        }
        
        body.dark-mode #simulation-panel h4::after {
            background: linear-gradient(90deg, var(--bridgestone-red), rgba(218, 41, 28, 0.2));
        }
        
        body.dark-mode #simulation-panel p, 
        body.dark-mode #simulation-panel li,
        body.dark-mode #simulation-panel label { 
            color: #cbd5e0;
        }
        
        body.dark-mode #simulation-panel select, 
        body.dark-mode #simulation-panel input[type="text"], 
        body.dark-mode #simulation-panel input[type="number"] {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        body.dark-mode #simulation-panel select:hover, 
        body.dark-mode #simulation-panel input[type="text"]:hover, 
        body.dark-mode #simulation-panel input[type="number"]:hover {
            border-color: rgba(218, 41, 28, 0.5);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        
        body.dark-mode #simulation-panel select:focus, 
        body.dark-mode #simulation-panel input[type="text"]:focus, 
        body.dark-mode #simulation-panel input[type="number"]:focus {
            border-color: var(--bridgestone-red);
            box-shadow: 0 0 0 3px rgba(218, 41, 28, 0.2);
        }
        
        body.dark-mode #simulation-panel button {
            background: linear-gradient(135deg, var(--bridgestone-red) 0%, #c53030 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(218, 41, 28, 0.4);
        }
        
        body.dark-mode #simulation-panel button:hover {
            background: linear-gradient(135deg, var(--bridgestone-red-darker) 0%, #a71005 100%);
            box-shadow: 0 4px 12px rgba(218, 41, 28, 0.5);
        }
        
        body.dark-mode #simulation-panel .close-panel-button { 
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(229, 62, 62, 0.4);
        }
        
        body.dark-mode #simulation-panel .close-panel-button:hover {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.5);
        }
        
        body.dark-mode #simulation-panel .close-panel-button:focus {
            outline: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        /* Stylizacja dark mode dla kart symulacji */
        body.dark-mode #simulation-targets-list .sim-card {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        body.dark-mode #simulation-targets-list .sim-card.active-card {
            border-color: var(--bridgestone-red);
            box-shadow: 0 4px 16px rgba(218, 41, 28, 0.3);
            background: linear-gradient(135deg, #5a6c7d 0%, #3a4a5d 100%);
        }
        
        body.dark-mode #simulation-targets-list .sim-card-header {
            color: #e2e8f0;
        }
        
        body.dark-mode #simulation-targets-list .sim-card-header .sim-card-remove-btn:hover {
            border-color: #e53e3e;
            background: linear-gradient(135deg, #5a2d32 0%, #4d1f24 100%);
            color: #ff7a83;
        }
        
        /* Stylizacja dark mode dla przycisków symulacji */
        body.dark-mode .simulation-type-button {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        body.dark-mode .simulation-type-button.active {
            background: linear-gradient(135deg, var(--bridgestone-red) 0%, #c53030 100%);
            border-color: var(--bridgestone-red);
            box-shadow: 0 2px 8px rgba(218, 41, 28, 0.4);
        }
        
        body.dark-mode .simulation-type-button:hover:not(.active) {
            background: linear-gradient(135deg, #5a6c7d 0%, #3a4a5d 100%);
            border-color: rgba(218, 41, 28, 0.5);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        
        /* Stylizacja dark mode dla zarządzania scenariuszami */
        body.dark-mode .simulation-scenario-management {
            border-top: 2px solid rgba(218, 41, 28, 0.3);
        }
        
        body.dark-mode .simulation-scenario-management select {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Stylizacja dark mode dla listy wpływu symulacji */
        body.dark-mode #simulation-impact-info h4 {
            border-top: 2px solid rgba(218, 41, 28, 0.3);
            color: #ffccc7;
        }
        
        body.dark-mode #simulation-impact-list li {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            border-left: 3px solid var(--bridgestone-red);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            color: #cbd5e0;
        }
        
        /* Stylizacja dark mode dla kontrolek kart symulacji */
        body.dark-mode #simulation-targets-list .sim-card-controls {
            border-top: 1px dashed rgba(218, 41, 28, 0.3);
        }
        
        body.dark-mode .sim-card-controls .sim-param-group label {
            color: #cbd5e0;
        }
        
        body.dark-mode .sim-card-controls .sim-param-group input {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode .sim-card-controls .sim-param-group input:hover {
            border-color: rgba(218, 41, 28, 0.5);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        
        body.dark-mode .sim-card-controls .sim-param-group input:focus {
            border-color: var(--bridgestone-red);
            box-shadow: 0 0 0 3px rgba(218, 41, 28, 0.2);
        }
        
        /* === KOMPLETNA STYLIZACJA DARK MODE DLA FILTER PANEL === */
        body.dark-mode #filter-panel {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            backdrop-filter: blur(10px);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                -5px 0 25px rgba(0, 0, 0, 0.4),
                -2px 0 10px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.05);
        }
        
        body.dark-mode #filter-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        body.dark-mode #filter-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        body.dark-mode #filter-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        body.dark-mode #filter-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        body.dark-mode #filter-panel h3 { 
            color: #f7fafc;
            border-bottom: 3px solid var(--bridgestone-red);
        }
        
        body.dark-mode #filter-panel h3::after {
            background: linear-gradient(90deg, var(--bridgestone-red), rgba(218, 41, 28, 0.3));
        }
        
        body.dark-mode #filter-panel h4 {
            color: #ffccc7;
            border-bottom: 2px solid rgba(218, 41, 28, 0.3);
        }
        
        body.dark-mode #filter-panel h4::after {
            background: linear-gradient(90deg, var(--bridgestone-red), rgba(218, 41, 28, 0.2));
        }
        
        body.dark-mode #filter-panel p, 
        body.dark-mode #filter-panel li,
        body.dark-mode #filter-panel label { 
            color: #cbd5e0;
        }
        
        body.dark-mode #filter-panel select, 
        body.dark-mode #filter-panel input[type="time"], 
        body.dark-mode #filter-panel input[type="text"] {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        body.dark-mode #filter-panel select:hover, 
        body.dark-mode #filter-panel input[type="time"]:hover, 
        body.dark-mode #filter-panel input[type="text"]:hover {
            border-color: rgba(218, 41, 28, 0.5);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        
        body.dark-mode #filter-panel select:focus, 
        body.dark-mode #filter-panel input[type="time"]:focus, 
        body.dark-mode #filter-panel input[type="text"]:focus {
            border-color: var(--bridgestone-red);
            box-shadow: 0 0 0 3px rgba(218, 41, 28, 0.2);
        }
        
        body.dark-mode #filter-panel .close-panel-button { 
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(229, 62, 62, 0.4);
        }
        
        body.dark-mode #filter-panel .close-panel-button:hover {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.5);
        }
        
        body.dark-mode #filter-panel .close-panel-button:focus {
            outline: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        body.dark-mode #apply-filters-button {
            background: linear-gradient(135deg, var(--bridgestone-red) 0%, #c53030 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(218, 41, 28, 0.4);
        }
        
        body.dark-mode #apply-filters-button:hover {
            background: linear-gradient(135deg, var(--bridgestone-red-darker) 0%, #a71005 100%);
            box-shadow: 0 6px 20px rgba(218, 41, 28, 0.5);
        }
        body.dark-mode #converter-panel .warning {
            color: #ffe082;
            background-color: #4e4010;
            border: 1px solid #a1883b;
        }
        body.dark-mode #converter-status pre, body.dark-mode #converter-panel pre {
            background-color: #1c1c1c;
            border: 1px solid #444;
            color: #ccc;
        }


        /* UWAGA: Stare style dark mode dla process-details zostały zastąpione nowoczesnymi stylami poniżej */


        body.dark-mode .colors-toggle-bar, body.dark-mode .visual-controls {
            /* NOWOCZESNY DARK GRADIENT KONTENER */
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #e0e0e0;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }
        body.dark-mode #toggle-colors-button {
            background-color: #333;
            color: #e0e0e0;
            border-color: #555;
        }
        body.dark-mode #toggle-colors-button:hover {
            background-color: #444;
        }
/* ZAKTUALIZUJ TE SELEKTORY */
body.dark-mode #reset-colors-button, body.dark-mode #generate-theme-button {
    background-color: #333;
    color: #e0e0e0;
    border-color: #555;
}
body.dark-mode #reset-colors-button:hover, body.dark-mode #generate-theme-button:hover {
    background-color: #444;
}
        body.dark-mode .visual-controls input[type="color"] {
             border-color: #555;
        }


        /* ===== DARK MODE - CZĘŚĆ D: NOWOCZESNE AXIS I LABELS ===== */
        body.dark-mode .axis {
            background: linear-gradient(135deg, rgba(45, 55, 72, 0.9) 0%, rgba(26, 32, 44, 0.85) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        
        body.dark-mode #sticky-y-axis, body.dark-mode #sticky-x-axis {
            /* NOWOCZESNE DARK GLASSMORPHISM CONTAINER */
            background: linear-gradient(135deg, rgba(45, 55, 72, 0.95) 0%, rgba(26, 32, 44, 0.92) 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            /* ENHANCED DARK CONTAINER SHADOW */
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.4),
                0 1px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }
        
        body.dark-mode #sticky-y-axis .axis, body.dark-mode #sticky-x-axis .axis {
            /* ENHANCED DARK GLASSMORPHISM LABELS */
            background: linear-gradient(135deg, rgba(45, 55, 72, 0.9) 0%, rgba(26, 32, 44, 0.85) 100%);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #e2e8f0;
            /* ENHANCED DARK DEPTH SHADOW */
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.4),
                0 1px 3px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        /* DARK MODE SHIMMER EFFECT */
        body.dark-mode #sticky-y-axis .axis::before, body.dark-mode #sticky-x-axis .axis::before {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }
        
        body.dark-mode #sticky-y-axis .axis:hover, body.dark-mode #sticky-x-axis .axis:hover {
            background: linear-gradient(135deg, rgba(74, 85, 104, 0.95) 0%, rgba(45, 55, 72, 0.9) 100%);
            border-color: rgba(218, 41, 28, 0.5);
            color: #f7fafc;
            transform: scale(1.02);
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.5),
                0 2px 6px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        
        /* DARK MODE SELECTED/ACTIVE STATE */
        body.dark-mode #sticky-y-axis .axis.active-axis-filter,
        body.dark-mode #sticky-x-axis .axis.active-axis-filter {
            background: linear-gradient(135deg, rgba(218, 41, 28, 0.2) 0%, rgba(218, 41, 28, 0.1) 100%);
            border: 2px solid var(--bridgestone-red);
            color: #ff9999;
            font-weight: 600;
            box-shadow: 
                0 0 20px rgba(218, 41, 28, 0.4),
                0 4px 16px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
            transform: scale(1.05);
        }

        body.dark-mode .page-footer {
            color: #aaa;
            border-top: 1px solid var(--bridgestone-red);
        }
        body.dark-mode .bridgestone-footer-symbol {
             fill: var(--bridgestone-red);
        }

        body.dark-mode #notification-bar {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%) !important;
            color: #e2e8f0 !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.4),
                0 8px 20px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.05) !important;
        }
        
        /* Dark mode variants for different notification types */
        body.dark-mode #notification-bar[data-type="error"] {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%) !important;
            color: white !important;
            border-color: rgba(229, 62, 62, 0.4) !important;
        }
        
        body.dark-mode #notification-bar[data-type="warning"] {
            background: linear-gradient(135deg, #d69e2e 0%, #b7791f 100%) !important;
            color: #1a1a1a !important;
            border-color: rgba(214, 158, 46, 0.4) !important;
        }
        
        body.dark-mode #notification-bar[data-type="success"] {
            background: linear-gradient(135deg, #38a169 0%, #2f855a 100%) !important;
            color: white !important;
            border-color: rgba(56, 161, 105, 0.4) !important;
        }
        
        body.dark-mode #notification-bar[data-type="info"] {
            background: linear-gradient(135deg, #3182ce 0%, #2c5aa0 100%) !important;
            color: white !important;
            border-color: rgba(49, 130, 206, 0.4) !important;
        }
        
        body.dark-mode #notification-message pre {
            background-color: rgba(0,0,0,0.3);
            color: #f0f0f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode #notification-close {
            color: #e2e8f0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        body.dark-mode #notification-close:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            border-color: rgba(218, 41, 28, 0.5);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        /* === DARK MODE STYLES FOR SIM-CARD CONTROLS === */
        body.dark-mode .sim-card-controls .sim-type-group button {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        body.dark-mode .sim-card-controls .sim-type-group button:hover {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            border-color: rgba(218, 41, 28, 0.5);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        body.dark-mode .sim-card-controls .sim-type-group button.active {
            background: linear-gradient(135deg, #3182ce 0%, #2c5aa0 100%);
            color: white;
            border-color: #2c5aa0;
            box-shadow: 0 4px 12px rgba(49, 130, 206, 0.4);
        }
        
        body.dark-mode .sim-card-controls .sim-type-group button.active:hover {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            box-shadow: 0 6px 16px rgba(49, 130, 206, 0.5);
        }
        
        body.dark-mode #menu-content,
        body.dark-mode #sheet-multi-select-dropdown,
        body.dark-mode #top-sheet-multi-select-dropdown,
        body.dark-mode #delete-view-config-dropdown,
        body.dark-mode .context-menu {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            backdrop-filter: blur(10px);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 8px 16px rgba(0, 0, 0, 0.3);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        body.dark-mode #menu-content button,
        body.dark-mode #menu-content .menu-item-group select {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        body.dark-mode #menu-content button:hover,
        body.dark-mode #menu-content .menu-item-group select:hover {
             background: linear-gradient(135deg, #5a6c7d 0%, #3a4a5d 100%);
             border-color: rgba(218, 41, 28, 0.5);
             box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        body.dark-mode #menu-content label#json-file-input-label {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%) !important; 
            color: #e2e8f0 !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
        }
        body.dark-mode #menu-content label#json-file-input-label:hover {
            background: linear-gradient(135deg, #5a6c7d 0%, #3a4a5d 100%) !important;
            border-color: rgba(218, 41, 28, 0.5) !important;
        }

        body.dark-mode #sheet-multi-select-options label:hover,
        body.dark-mode #top-sheet-multi-select-options label:hover,
        body.dark-mode .context-menu-item:hover,
        body.dark-mode #delete-view-config-dropdown .delete-item:hover {
            background: linear-gradient(135deg, #5a6c7d 0%, #3a4a5d 100%);
            color: #f7fafc;
            border-color: rgba(218, 41, 28, 0.5);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        body.dark-mode .context-menu-item {
            color: #e2e8f0;
        }
        body.dark-mode #menu-content h4 {
            color: #f7fafc;
            border-bottom-color: rgba(218, 41, 28, 0.3);
        }
        body.dark-mode #menu-content h4::after {
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        body.dark-mode #menu-content hr {
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        }
        body.dark-mode .menu-item-group {
            background: rgba(45, 55, 72, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        body.dark-mode .menu-item-group .delete-view-config-container button {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            color: white;
        }
        body.dark-mode .menu-item-group .delete-view-config-container button:hover {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
        }
        body.dark-mode #menu-content .sheet-multi-select-container button {
            background: linear-gradient(135deg, #3182ce 0%, #2c5aa0 100%);
        }
        body.dark-mode #menu-content .sheet-multi-select-container button:hover {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
        }
        body.dark-mode #delete-view-config-dropdown .delete-item:hover {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            color: white;
        }

        /* === KOMPLETNA STYLIZACJA DARK MODE DLA DEPENDENCY PANEL === */
        body.dark-mode #dependency-panel-container {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 3px solid var(--bridgestone-red);
            box-shadow: 
                -8px 0 40px rgba(0, 0, 0, 0.4),
                -4px 0 16px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.05);
        }
        
        body.dark-mode #dependency-panel-title-bar {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            border-bottom: 3px solid rgba(218, 41, 28, 0.3);
            color: #e2e8f0;
        }
        
        body.dark-mode #dependency-panel-title-bar::after {
            background: linear-gradient(90deg, var(--bridgestone-red), rgba(218, 41, 28, 0.3));
        }
        
        body.dark-mode #dependency-panel-title-bar h3 {
            color: #f7fafc;
        }
        
        body.dark-mode #highlight-tree-nodes-button {
            background: linear-gradient(135deg, var(--bridgestone-red) 0%, #c53030 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(218, 41, 28, 0.4);
        }
        
        body.dark-mode #highlight-tree-nodes-button:hover {
            background: linear-gradient(135deg, var(--bridgestone-red-darker) 0%, #a71005 100%);
            box-shadow: 0 4px 12px rgba(218, 41, 28, 0.5);
        }
        
        body.dark-mode .close-dependency-panel-button {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(229, 62, 62, 0.4);
        }
        
        body.dark-mode .close-dependency-panel-button:hover {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.5);
        }
        
        body.dark-mode #dependency-tree-content {
            background: linear-gradient(135deg, #2c2c2c 0%, #1a202c 100%);
        }
        
        body.dark-mode #dependency-tree-content::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        body.dark-mode #dependency-tree-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        body.dark-mode #dependency-tree-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        body.dark-mode #dependency-tree-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* === ULEPSZONY DARK MODE DLA DEPENDENCY TREE NODES === */
        body.dark-mode .dep-tree-node rect {
            fill: #4a5568;
            stroke: var(--bridgestone-red);
            stroke-width: 2px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }
        
        body.dark-mode .dep-tree-node.selected-root rect {
            fill: #8b5a5a;
            stroke: #ff8a8a;
            stroke-width: 3px;
            filter: drop-shadow(0 4px 8px rgba(255, 138, 138, 0.4));
        }
        
        body.dark-mode .dep-tree-node.not-in-view rect {
            fill: #64748b;
            stroke: #94a3b8;
            stroke-dasharray: 4,4;
            opacity: 0.6;
        }
        

        
        body.dark-mode .dep-tree-node text {
            fill: #e2e8f0;
            font-weight: 500;
        }
        
        body.dark-mode .dep-tree-node text.toggle-text {
            fill: #cbd5e0;
            font-weight: 600;
        }
        
        body.dark-mode .dep-tree-node text.toggle-text:hover {
            fill: #ffccc7;
        }
        
        body.dark-mode .dep-tree-link {
            stroke: #cbd5e0;
            stroke-width: 2px;
        }
        
        body.dark-mode .dep-tree-node.path-highlight rect {
            fill: #b7791f;
            stroke: #ecc94b;
            stroke-width: 3px;
            filter: drop-shadow(0 4px 8px rgba(236, 201, 75, 0.4));
        }
        
        body.dark-mode .dep-tree-link.path-highlight {
            stroke: #ecc94b;
            stroke-width: 3px;
            filter: drop-shadow(0 1px 3px rgba(236, 201, 75, 0.4));
        }
        
        /* Kolory dla różnych typów procesów w dependency tree (dark mode) są teraz ustawiane dynamicznie w JavaScript */

        body.dark-mode .process-node.simulation-target-node {
            box-shadow: 0 0 8px 2px gold !important;
        }
        body.dark-mode .process-node.simulation-new-node {
            border: 2px dashed #17a2b8 !important;
            background-color: #1a3f45 !important;
        }
        body.dark-mode .process-node.simulation-new-node::after {
            color: #17a2b8;
        }
        body.dark-mode .process-node.simulation-removed {
            border-color: #dc3545 !important;
            background-color: #5a2d32 !important;
        }
        body.dark-mode .process-node.simulation-removed::after {
            color: #dc3545;
        }
    /* --- NOWE, SZCZEGÓŁOWE STYLE (TRYB CIEMNY) --- */

    /* Wejście z problemem (jasnoczerwony w ciemnym trybie) */
    body.dark-mode .process-node.simulation-input-conflict {
        background-color: #5a2d32 !important;
        border: 2px solid #ff7a83 !important;
    }
    /* Wyjście z problemem (ciemnoczerwony w ciemnym trybie) */
    body.dark-mode .process-node.simulation-output-at-risk {
        background-color: #4d1f24 !important;
        border: 2px solid #ff4f5a !important;
    }
	/* Poprawne wejście w symulacji (jasnozielony w ciemnym trybie) */
    body.dark-mode .process-node.simulation-ok-input {
        background-color: #1c4b27 !important;
        border: 2px solid #52c467 !important;
    }
    /* Poprawne wyjście w symulacji (ciemnozielony w ciemnym trybie) */
    body.dark-mode .process-node.simulation-ok-output {
        background-color: #113118 !important;
        border: 2px solid #3fa551 !important;
    }
        body.dark-mode .simulation-ghost-node {
            border-color: #555 !important;
            background-color: rgba(44, 62, 80, 0.3) !important;
        }

        body.dark-mode #mini-map-wrapper {
            background: linear-gradient(135deg, rgba(33, 37, 41, 0.95) 0%, rgba(52, 58, 64, 0.9) 100%);
            border: 1px solid #495057;
            border-top: 3px solid var(--bridgestone-red);
            box-shadow: 
                0 12px 32px rgba(255, 255, 255, 0.08),
                0 4px 16px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        body.dark-mode #mini-map-wrapper:hover {
            transform: scale(1.02);
            box-shadow: 
                0 16px 40px rgba(255, 255, 255, 0.12),
                0 6px 20px rgba(255, 255, 255, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        
        body.dark-mode #mini-map-viewport-rect {
            fill: rgba(218, 41, 28, 0.25);
            stroke: rgba(218, 41, 28, 0.9);
        }
        body.dark-mode .mini-map-node {
            stroke: #adb5bd;
            filter: drop-shadow(0 1px 2px rgba(255, 255, 255, 0.05));
        }

        /* === NOWOCZESNE STYLE DLA COLORS PANEL === */
        #colors-panel {
            width: 400px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 
                -5px 0 25px rgba(0, 0, 0, 0.1),
                -2px 0 10px rgba(0, 0, 0, 0.06),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            padding: 25px;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #colors-panel h3 { 
            margin-top: 0; 
            margin-bottom: 25px; 
            border-bottom: 3px solid var(--bridgestone-red);
            padding-bottom: 15px;
            font-size: 1.4em;
            font-weight: 700;
            color: #2c3e50;
            position: relative;
        }
        
        #colors-panel h3::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 50px;
            height: 3px;
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        
        #colors-panel h4 { 
            margin-top: 20px; 
            margin-bottom: 12px; 
            color: var(--bridgestone-red); 
            border-bottom: 2px solid rgba(218, 41, 28, 0.2); 
            padding-bottom: 8px;
            font-size: 1.1em;
            font-weight: 600;
            position: relative;
        }
        
        #colors-panel h4::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 30px;
            height: 2px;
            background: linear-gradient(90deg, var(--bridgestone-red), transparent);
        }
        
        .colors-panel-content {
            padding-bottom: 20px;
        }
        
        .color-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(248, 249, 250, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }
        
        .color-group:hover {
            background: rgba(218, 41, 28, 0.05);
            border-color: rgba(218, 41, 28, 0.2);
        }
        
        .color-group label {
            font-size: 0.9em;
            font-weight: 500;
            color: #495057;
            flex-grow: 1;
        }
        
        .color-group input[type="color"] {
            width: 40px;
            height: 32px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
            background: none;
            transition: all 0.2s ease;
        }
        
        .color-group input[type="color"]:hover {
            border-color: rgba(218, 41, 28, 0.3);
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .colors-panel-actions {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid rgba(218, 41, 28, 0.2);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .colors-panel-actions .action-button {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .colors-panel-actions .action-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }
        
        .colors-panel-actions .action-button:hover::before {
            left: 100%;
        }
        
        .colors-panel-actions .reset-button {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
            border-color: rgba(255, 107, 107, 0.3);
        }
        
        .colors-panel-actions .reset-button:hover {
            background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
        }
        
        .colors-panel-actions .generate-button {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border-color: rgba(40, 167, 69, 0.3);
        }
        
        .colors-panel-actions .generate-button:hover {
            background: linear-gradient(135deg, #20c997 0%, #17a2b8 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }
        
        #colors-panel .close-panel-button { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            border: none; 
            font-size: 1.8em; 
            cursor: pointer; 
            line-height: 1; 
            width: 45px;
            height: 45px;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(238, 90, 82, 0.3);
            z-index: 1001;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            padding: 0;
            margin: 0;
            min-width: 45px;
            min-height: 45px;
            pointer-events: auto;
        }
        
        #colors-panel .close-panel-button:hover {
            background: linear-gradient(135deg, #ff5252 0%, #d32f2f 100%);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(238, 90, 82, 0.4);
        }
        
        #colors-panel .close-panel-button:active {
            transform: scale(0.95);
        }
        
        #colors-panel .close-panel-button:focus {
            outline: 2px solid rgba(255, 255, 255, 0.5);
            outline-offset: 2px;
        }
        
        /* Scrollbar styling for colors panel */
        #colors-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        #colors-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        
        #colors-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        #colors-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        /* === KOMPLETNA STYLIZACJA DARK MODE DLA TUTORIAL PANEL === */
        body.dark-mode #tutorial-panel {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            backdrop-filter: blur(10px);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                -5px 0 25px rgba(0, 0, 0, 0.4),
                -2px 0 10px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.05);
        }
        
        body.dark-mode #tutorial-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        body.dark-mode #tutorial-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        body.dark-mode #tutorial-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        
        body.dark-mode #tutorial-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        body.dark-mode #tutorial-panel h3 { 
            color: #f7fafc;
            border-bottom: 3px solid var(--bridgestone-red);
            background: linear-gradient(90deg, var(--bridgestone-red) 0%, transparent 50%);
            background-clip: text;
            -webkit-background-clip: text;
        }
        
        body.dark-mode #tutorial-panel h3::after {
            background: linear-gradient(90deg, var(--bridgestone-red), rgba(218, 41, 28, 0.3));
        }
        
        body.dark-mode #tutorial-panel h4 {
            color: #ffccc7;
            border-bottom: 2px solid rgba(218, 41, 28, 0.3);
        }
        
        body.dark-mode #tutorial-panel h4::after {
            background: linear-gradient(90deg, var(--bridgestone-red), rgba(218, 41, 28, 0.2));
        }
        
        body.dark-mode #tutorial-panel p, 
        body.dark-mode #tutorial-panel li { 
            color: #cbd5e0;
        }
        
        body.dark-mode #tutorial-panel ul li::before {
            color: #ffccc7;
        }
        
        body.dark-mode #tutorial-panel ol li::marker {
            color: #ffccc7;
        }
        
        body.dark-mode #tutorial-panel .code-like { 
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #ffccc7;
            border: 1px solid rgba(218, 41, 28, 0.3);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        body.dark-mode #tutorial-panel strong {
            color: #f7fafc;
        }
        
        body.dark-mode #tutorial-panel .close-panel-button { 
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(229, 62, 62, 0.4);
        }
        
        body.dark-mode #tutorial-panel .close-panel-button:hover {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.5);
        }
        
        body.dark-mode #tutorial-panel .close-panel-button:focus {
            outline: 2px solid rgba(255, 255, 255, 0.3);
        }

        /* === KOMPLETNA STYLIZACJA DARK MODE DLA COLORS PANEL === */
        body.dark-mode #colors-panel {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            backdrop-filter: blur(10px);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                -5px 0 25px rgba(0, 0, 0, 0.4),
                -2px 0 10px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.05);
        }
        
        body.dark-mode #colors-panel h3 { 
            color: #f7fafc;
            border-bottom: 3px solid var(--bridgestone-red);
            background: linear-gradient(90deg, var(--bridgestone-red) 0%, transparent 50%);
            background-clip: text;
            -webkit-background-clip: text;
        }
        
        body.dark-mode #colors-panel h3::after {
            background: linear-gradient(90deg, var(--bridgestone-red), rgba(218, 41, 28, 0.3));
        }
        
        body.dark-mode #colors-panel h4 {
            color: #ffccc7;
            border-bottom: 2px solid rgba(218, 41, 28, 0.3);
        }
        
        body.dark-mode #colors-panel h4::after {
            background: linear-gradient(90deg, var(--bridgestone-red), rgba(218, 41, 28, 0.2));
        }
        
        body.dark-mode .color-group {
            background: rgba(45, 55, 72, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        body.dark-mode .color-group:hover {
            background: rgba(218, 41, 28, 0.1);
            border-color: rgba(218, 41, 28, 0.4);
        }
        
        body.dark-mode .color-group label {
            color: #cbd5e0;
        }
        
        body.dark-mode .color-group input[type="color"] {
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        body.dark-mode .color-group input[type="color"]:hover {
            border-color: rgba(218, 41, 28, 0.5);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        body.dark-mode .colors-panel-actions {
            border-top-color: rgba(218, 41, 28, 0.3);
        }
        
        body.dark-mode .colors-panel-actions .reset-button {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
        }
        
        body.dark-mode .colors-panel-actions .reset-button:hover {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.4);
        }
        
        body.dark-mode .colors-panel-actions .generate-button {
            background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
        }
        
        body.dark-mode .colors-panel-actions .generate-button:hover {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            box-shadow: 0 4px 12px rgba(56, 161, 105, 0.4);
        }
        
        body.dark-mode #colors-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        body.dark-mode #colors-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
        }
        
        body.dark-mode #colors-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        body.dark-mode #colors-panel .close-panel-button { 
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(229, 62, 62, 0.4);
        }
        
        body.dark-mode #colors-panel .close-panel-button:hover {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.5);
        }
        
        body.dark-mode #colors-panel .close-panel-button:focus {
            outline: 2px solid rgba(255, 255, 255, 0.3);
        }

        body.dark-mode.presentation-mode .top-bar {
            background-color: #121212;
        }
        body.dark-mode.presentation-mode #diagram-container {
            background-color: #121212;
        }

/* START NOWYCH STYLI DLA TRYBU CIEMNEGO */
body.dark-mode #process-details {
    background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
    backdrop-filter: blur(10px);
    box-shadow: 
        0 20px 40px rgba(0, 0, 0, 0.4),
        0 8px 16px rgba(0, 0, 0, 0.3);
    color: #e2e8f0;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

body.dark-mode #process-details.active {
    background: linear-gradient(135deg, #5a6c7d 0%, #3a4a5d 100%);
    border-top-color: var(--bridgestone-red);
}

body.dark-mode .details-title-container {
    color: #adb5bd;
}

body.dark-mode #process-details.active .details-title-container {
    color: #e0e0e0;
}

body.dark-mode #details-header h3 {
    color: inherit;
}

body.dark-mode #details-toggle-button {
    background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
    color: #e2e8f0;
    border: 1px solid rgba(255, 255, 255, 0.1);
}
body.dark-mode #details-toggle-button:hover {
    background: linear-gradient(135deg, #5a6c7d 0%, #3a4a5d 100%);
    border-color: rgba(218, 41, 28, 0.5);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

/* Dark mode styles dla nowego layoutu */
body.dark-mode #details-content-container {
    background: transparent;
}

body.dark-mode #details-content-wrapper {
    color: #e0e0e0;
}

body.dark-mode #details-content-wrapper strong { 
    color: #f5f5f5; 
}

body.dark-mode #details-action-buttons {
    background: linear-gradient(135deg, rgba(45, 55, 72, 0.8) 0%, rgba(26, 32, 44, 0.8) 100%);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

body.dark-mode #details-action-buttons h4 {
    color: #ffccc7;
    border-bottom-color: rgba(218, 41, 28, 0.3);
}

body.dark-mode #details-action-buttons .edit-process-button { 
    background: linear-gradient(135deg, var(--bridgestone-red) 0%, #c53030 100%);
    color: white;
    box-shadow: 0 2px 8px rgba(218, 41, 28, 0.4);
}

body.dark-mode #details-action-buttons .edit-process-button:hover { 
    background: linear-gradient(135deg, var(--bridgestone-red-darker) 0%, #a71005 100%);
    box-shadow: 0 4px 12px rgba(218, 41, 28, 0.5);
}

body.dark-mode #details-action-buttons .simulate-impact-button { 
    background: linear-gradient(135deg, #d69e2e 0%, #b7791f 100%);
    color: #212529;
    font-weight: 600;
    box-shadow: 0 2px 8px rgba(214, 158, 46, 0.4);
}

body.dark-mode #details-action-buttons .simulate-impact-button:hover { 
    background: linear-gradient(135deg, #ecc94b 0%, #d69e2e 100%);
    box-shadow: 0 4px 12px rgba(214, 158, 46, 0.5);
}

/* Zachowanie starych stylów dla kompatybilności */
body.dark-mode #details-content-wrapper button { 
    background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%); 
    color: #e2e8f0; 
    border: 1px solid rgba(255, 255, 255, 0.1); 
}

body.dark-mode #details-content-wrapper button:hover { 
    background: linear-gradient(135deg, #5a6c7d 0%, #3a4a5d 100%); 
    border-color: rgba(218, 41, 28, 0.5); 
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); 
}

/* Responsive design dla mniejszych ekranów */
@media screen and (max-width: 768px) {
    #details-content-container {
        flex-direction: column;
    }
    
    #details-action-buttons {
        width: 100%;
        flex-direction: row;
        padding: 15px;
    }
    
    #details-action-buttons h4 {
        display: none;
    }
}

/* =====================================================
   PROCESS STATUS VISUALIZATION STYLES
   ===================================================== */

/* Status indicator - subtle border effect */
.status-indicator {
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    border-radius: 0; /* Brutalist design */
    pointer-events: none;
    z-index: 1;
}

/* Status icon - positioned in top-right corner */
.status-icon {
    position: absolute;
    top: -4px;
    right: -4px;
    width: 12px;
    height: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 8px;
    font-weight: bold;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 10;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

/* Status-specific indicator styles */
.status-completed-on-time {
    border: 2px solid var(--fc-neon-success);
    box-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
}

.status-completed-late {
    border: 2px solid var(--fc-neon-warning);
    box-shadow: 0 0 10px rgba(255, 190, 11, 0.3);
}

.status-overdue {
    border: 2px solid var(--fc-neon-secondary);
    box-shadow: 0 0 10px rgba(255, 0, 110, 0.3);
    animation: pulse-border 2s infinite;
}

.status-delayed {
    border: 2px solid var(--fc-neon-warning);
    box-shadow: 0 0 10px rgba(255, 190, 11, 0.2);
}

.status-pending {
    border: 2px solid var(--fc-border);
}

/* Status-specific icon styles */
.status-icon-completed {
    background: var(--fc-neon-success);
    color: var(--fc-dark-primary);
}

.status-icon-completed-late {
    background: var(--fc-neon-warning);
    color: var(--fc-dark-primary);
}

.status-icon-overdue {
    background: var(--fc-neon-secondary);
    color: var(--fc-text-primary);
    animation: pulse-icon 2s infinite;
}

.status-icon-delayed {
    background: var(--fc-neon-warning);
    color: var(--fc-dark-primary);
}

.status-icon-pending {
    background: var(--fc-surface);
    color: var(--fc-text-muted);
    border: 1px solid var(--fc-border);
}

/* Hover effects */
.status-icon:hover {
    transform: scale(1.3);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
}

/* Animations for overdue processes */
@keyframes pulse-red {
    0% { box-shadow: 0 0 15px rgba(255, 0, 110, 0.5); }
    50% { box-shadow: 0 0 25px rgba(255, 0, 110, 0.8); }
    100% { box-shadow: 0 0 15px rgba(255, 0, 110, 0.5); }
}

@keyframes pulse-border {
    0% { border-color: var(--fc-neon-secondary); }
    50% { border-color: rgba(255, 0, 110, 0.8); }
    100% { border-color: var(--fc-neon-secondary); }
}

@keyframes pulse-icon {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

/* Dark mode adjustments */
body.dark-mode .status-icon {
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

body.dark-mode .status-icon:hover {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
}

body.dark-mode .status-icon-pending {
    background: var(--fc-dark-secondary);
    border-color: rgba(255, 255, 255, 0.2);
}

/* Process status modal styles moved to index.html */

/* Small screen adjustments */
@media (max-width: 768px) {
    .status-icon {
        width: 10px;
        height: 10px;
        font-size: 6px;
        top: -3px;
        right: -3px;
    }
}    </style>
</head>
<body>


    <div id="notification-bar">
        <span id="notification-message"></span>
        <button id="notification-close">&times;</button>
    </div>

    <div class="top-bar">
        <div class="main-controls">
            <!-- Navigation Controls -->
            <div class="navigation-controls" style="display: flex; gap: 8px; margin-right: 16px; align-items: center;">
                <div id="app-logo-header" title="FlowCraft - Interactive Process Visualization" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; cursor: pointer;">
                    <img src="FlowCraft.png" alt="FlowCraft Logo" style="width: 24px; height: 24px; border-radius: 4px; filter: drop-shadow(0 0 8px rgba(0, 212, 255, 0.4)); transition: all 0.3s ease;">
                    <span style="font-size: 16px; font-weight: 700; color: var(--fc-text-primary); text-transform: uppercase; letter-spacing: 0.5px;">FlowCraft</span>
                </div>
                <div class="sheet-multi-select-container" style="display: flex; align-items: center; gap: 8px; position: relative;">
                    <button id="top-sheet-multi-select-button" title="Select sheets to view" style="padding: 6px 12px; border: 1px solid #ced4da; border-radius: 4px; background: white; font-size: 0.85em; min-width: 150px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                        <span id="top-sheet-selection-text">Loading...</span>
                        <span style="margin-left: 8px;">▼</span>
                </button>
                    <div id="top-sheet-multi-select-dropdown" style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ced4da; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; min-width: 200px; max-height: 300px; overflow-y: auto;">
                        <div style="padding: 8px; border-bottom: 1px solid #e9ecef;">
                            <label style="display: flex; align-items: center; font-size: 0.85em; cursor: pointer;">
                                <input type="checkbox" id="top-sheet-select-all-checkbox" style="margin-right: 6px;">
                                <strong>Select All</strong>
                            </label>
                        </div>
                        <div id="top-sheet-multi-select-options" style="padding: 4px;">
                            <p style="font-size:0.85em; color:#777; margin: 8px; text-align: center;">No sheets available in this project.</p>
                        </div>
                    </div>
                </div>
                <button id="manage-columns-diagram-btn" title="Manage Table Columns" style="padding: 8px 12px; background: linear-gradient(135deg, #6c757d 0%, #495057 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; display: flex; align-items: center; gap: 4px;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="6" rx="1"></rect>
                        <rect x="3" y="9" width="18" height="6" rx="1"></rect>
                        <rect x="3" y="15" width="18" height="6" rx="1"></rect>
                    </svg>
                    Columns
                </button>
            </div>
            <div class="menu-container">
                <button id="menu-button" class="btn-fc btn-fc-danger btn-fc-md" title="Access application menu">
                    MENU
                </button>
                <div id="menu-content">
                    <h4>View & Display</h4>

                    <div class="menu-item-group">
                        <label for="view-config-selector">Load View:</label>
                        <select id="view-config-selector" title="Load a saved view configuration">
                            <option value="">- Select View -</option>
                        </select>
                        <div class="delete-view-config-container">
                            <button id="delete-view-config-button" title="Open menu to delete a view configuration">🗑️</button>
                            <div id="delete-view-config-dropdown">
                                <div style="font-size:0.9em; color:#777; padding: 8px 12px; text-align: center;">No views to delete.</div>
                            </div>
                        </div>
                    </div>
                    <button id="save-view-config-button" title="Save current filters and colors as a named view configuration">Save View Config</button>

                    <hr>
                    <h4>Editing & Tools</h4>
                    <button id="add-process-button" title="Add a new process to the current sheet view">Add Process</button>
                    <button id="toggle-dependency-edit-button" title="Toggle dependency editing mode">Enable Dependency Editing</button>
                    <button id="menu-dependency-panel-trigger" title="Show Dependencies in Panel (select a node first)">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 5px;">
                            <circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle>
                            <circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                        </svg>
                        Show Dependencies
                    </button>
                    
                    <hr>
                    <h4>Help</h4>
                    <button id="toggle-tutorial-panel-button" title="Open tutorial panel">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 8px;"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 1 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12" y2="17"/></svg>
                        Tutorial / Help
                    </button>
                </div>
            </div>

            <div class="search-group">
                <input type="search" id="search-process-input" placeholder="Search processes..." title="Search by ID, Short name, Description">
            </div>
            <button id="reset-button" title="Reset diagram zoom, scroll, filters, and selections to default">Reset View</button>
            <div class="visual-shortcut-buttons">
                <!-- Przycisk do zmiany motywu (Dark/Light) -->
                <button id="theme-toggle-button" title="Toggle Dark/Light Theme">
                    <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                    <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                </button>
                <!-- Przycisk do zarządzania kolorami -->
                <div class="menu-container">
<button id="color-controls-menu-button" title="Color Options">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path></svg>
</button>
                    <div id="color-controls-dropdown" class="context-menu" style="right: 0; left: auto; min-width: 200px;">
                        <div class="context-menu-item" id="generate-theme-from-menu">Generate New Theme 🎨</div>
                        <div class="context-menu-item" id="reset-colors-from-menu">Reset to Default 🔄</div>
                        <div class="context-menu-item" id="toggle-manual-colors-from-menu">Change Colours...</div>
                    </div>
                </div>

                <!-- Przycisk do trybu prezentacji -->
                <button id="toggle-presentation-mode-button" title="Toggle Presentation Mode">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
                </button>
            </div>
            <!-- KONIEC PRZENIESIONEGO BLOKU -->
            
            <button id="shortcut-show-dependencies-button" class="btn-fc btn-fc-secondary btn-fc-sm" title="Show Dependencies for Selected Process" disabled>
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;">
                    <circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle>
                    <circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                </svg>
            </button>
            <button id="shortcut-simulate-impact-button" class="btn-fc btn-fc-accent btn-fc-sm" title="Simulate Impact for Selected Process" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;">
                    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                </svg>
            </button>

        </div>
        <button id="toggle-filter-panel-button" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #e9e9e9; font-size: 0.9em; margin-left:10px;" title="Open panel to filter processes based on their attributes">Filters</button>
        <button id="toggle-mini-map-button" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; background-color: #e9e9e9; font-size: 0.9em; margin-left:5px;" title="Toggle Mini-Map">M</button>
    </div>

    <div id="diagram-container">
        <div id="diagram-zoom-pane">
            <svg id="dependency-svg"></svg>
            <div id="simulation-ghost-layer"></div>
            <div id="link-handle-trigger" title="Add dependency">+</div>
            <div id="welcome-message-overlay">
                <h2>No Processes Found</h2>
                <p>This sheet doesn't contain any processes yet.</p>
                <p>
                    <strong>To get started:</strong>
                </p>
                <ol style="text-align: left; display: inline-block; margin-top: 15px; margin-bottom: 20px;">
                    <li style="margin-bottom: 10px;">
                        <strong>Add your first process</strong> by clicking the <span class="highlight-path">+ Add Process</span> button in the top menu
                        </li>
                    <li style="margin-bottom: 10px;">
                        <strong>Or go to the Project Manager</strong> to import processes from Excel or create them in bulk
                        </li>
                        <li>
                        <strong>All changes are automatically saved</strong> to the database
                        </li>
                    </ol>
                
                <div style="margin-top: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
                    <p style="margin: 0; font-size: 0.95em; color: #495057;">
                        <strong>💡 Tip:</strong> Once you add processes, they will appear automatically on this diagram. Use filters, search, and simulation tools to explore complex process dependencies.
                    </p>
                </div>
                
                <p class="tutorial-prompt" style="margin-top: 20px;">
                    Need help? Check out the 
                    <span class="highlight-path" onclick="document.getElementById('toggle-tutorial-panel-button').click(); document.getElementById('menu-content').style.display='none';">Tutorial</span> 
                    (available under <span class="highlight-path">Menu &gt; Tutorial / Help</span>).
                </p>
            </div>
        </div>
    </div>

<div id="dependency-panel-container">
    <div id="dependency-panel-resizer"></div>
    <div id="dependency-panel-title-bar">
        <h3 id="dependency-panel-title">Process Dependencies</h3>
        <button id="highlight-tree-nodes-button" title="Highlight only these processes on the main diagram">Highlight Tree Nodes</button>
        <button id="close-dependency-panel-button" class="close-dependency-panel-button" title="Close dependency panel">×</button>
    </div>
    <div id="dependency-tree-content">
        <svg id="dependency-tree-svg"></svg>
    </div>
</div>

<!-- Panel do ręcznej edycji kolorów - teraz jest ukryty i kontrolowany z górnego menu -->
<div class="visual-controls" style="display: none; padding: 15px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); flex-wrap: wrap; gap: 15px; margin-top: 10px;">
    <label for="sim-ok-input-color">Sim: Input OK:</label>
    <input type="color" id="sim-ok-input-color" value="#d4edda" title="Simulation Input OK Color">
    <label for="sim-ok-output-color">Sim: Output OK:</label>
    <input type="color" id="sim-ok-output-color" value="#a3d9b1" title="Simulation Output OK Color">
    <label for="node-color">Process (default):</label>
    <input type="color" id="node-color" value="#aedff7" title="Default Process Node Color">
    <label for="lightning-color">Lightning:</label>
    <input type="color" id="lightning-color" value="#00ff00" title="Selected Node Lightning Effect Color">
    <label for="input-process-color">Input Process (OK):</label>
    <input type="color" id="input-process-color" value="#d4edda" title="Input Dependent Process Color (OK)">
    <label for="output-process-color">Output Process (OK):</label>
    <input type="color" id="output-process-color" value="#a3d9b1" title="Output Dependent Process Color (OK)">
    <label for="sim-input-conflict-color">Sim: Input Conflict:</label>
    <input type="color" id="sim-input-conflict-color" value="#f8d7da" title="Simulation Input Conflict Color">
    <label for="sim-output-at-risk-color">Sim: Output at Risk:</label>
    <input type="color" id="sim-output-at-risk-color" value="#e4a1a6" title="Simulation Output at Risk Color">
    <label for="input-arrow-color">Input Arrow (Std):</label>
    <input type="color" id="input-arrow-color" value="#50c878" title="Input Dependency Arrow Color (Standard)">
    <label for="output-arrow-color">Output Arrow (Std):</label>
    <input type="color" id="output-arrow-color" value="#ff7f7f" title="Output Dependency Arrow Color (Standard)">
    <label for="blocking-node-color">Blocking Process:</label>
    <input type="color" id="blocking-node-color" value="#ffcc80" title="Blocking Process Node Color">
    <label for="informational-node-color">Informational Process:</label>
    <input type="color" id="informational-node-color" value="#b3e5fc" title="Informational Process Node Color">
    <label for="input-arrow-blocking-color">Input Arrow (Block):</label>
    <input type="color" id="input-arrow-blocking-color" value="#FF0000" title="Input Blocking Dependency Arrow Color">
    <label for="output-arrow-blocking-color">Output Arrow (Block):</label>
    <input type="color" id="output-arrow-blocking-color" value="#FF0000" title="Output Blocking Dependency Arrow Color">
    <label for="input-arrow-informational-color">Input Arrow (Info):</label>
    <input type="color" id="input-arrow-informational-color" value="#0000FF" title="Input Informational Dependency Arrow Color">
    <label for="output-arrow-informational-color">Output Arrow (Info):</label>
    <input type="color" id="output-arrow-informational-color" value="#0000FF" title="Output Informational Dependency Arrow Color">
</div>

<!-- Nowy, wysuwany panel Process Details -->
<div id="process-details"> <!-- Usunęliśmy klasy .inactive i .collapsed -->
    <div id="details-header">
        <div class="details-title-container">
            <!-- Nowa ikona, podobna do tej z projektu -->
<svg class="details-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
    <polyline points="14 2 14 8 20 8"></polyline>
    <line x1="16" y1="13" x2="8" y2="13"></line>
    <line x1="16" y1="17" x2="8" y2="17"></line>
    <polyline points="10 9 9 9 8 9"></polyline>
</svg>
            <h3 id="details-title-text">Process Details</h3>
        </div>
        <div class="details-controls">
            <!-- Przycisk, który będzie się zmieniał (Show/Hide) -->
            <button id="details-toggle-button">
                <span class="button-text-show">Show</span>
                <span class="button-text-hide">Hide</span>
                <!-- Ikony strzałek -->
                <svg class="chevron-down" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                <svg class="chevron-up" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>
            </button>
        </div>
    </div>
    <div id="details-content-container">
        <div id="details-content-wrapper">
            <!-- Ta część pozostaje bez zmian, zawartość generuje JS -->
        </div>
        <div id="details-action-buttons" class="details-actions">
            <!-- Przyciski akcji będą tutaj generowane przez JS -->
        </div>
    </div>
</div>
    <div id="process-modal" class="modal">
        <div class="modal-content">
            <h3 id="modal-title">Add/Edit Process</h3>
            <input type="hidden" id="process-edit-id">
            <!-- MODIFICATION START: Added Sheet Selector -->
            <div>
                <label for="process-target-sheet-modal">Target Sheet:</label>
                <select id="process-target-sheet-modal"></select>
                <span class="error-message" id="error-process-target-sheet-modal"></span>
            </div>
            <!-- MODIFICATION END: Added Sheet Selector -->
            <div><label for="process-id-modal">ID (unique within its sheet):</label><input type="text" id="process-id-modal"><span class="error-message" id="error-process-id-modal"></span></div>
            <div><label for="process-short-name-modal">Short name:</label><input type="text" id="process-short-name-modal"><span class="error-message" id="error-process-short-name-modal"></span></div>
            <div><label for="process-wd-modal">WD (number, e.g., -5, 1, 15):</label><input type="number" id="process-wd-modal" title="Cannot be 0. Negative values indicate previous month."><span class="error-message" id="error-process-wd-modal"></span></div>
            <div><label for="process-due-time-modal">Due time (HH:MM or HH:MM:SS):</label><input type="text" id="process-due-time-modal" placeholder="HH:MM or HH:MM:SS"><span class="error-message" id="error-process-due-time-modal"></span></div>
            <div><label for="process-dependencies-modal">Dependencies (Short names separated by commas, e.g., START, DESIGN, REVIEW):</label><input type="text" id="process-dependencies-modal" placeholder="Click here to see all processes or type to search..."><span class="error-message" id="error-process-dependencies-modal"></span><div id="dependencies-autocomplete" style="display: none; position: absolute; background: white; border: 1px solid #ccc; max-height: 200px; overflow-y: auto; z-index: 1000; width: 100%; box-shadow: 0 2px 5px rgba(0,0,0,0.1);"></div></div>
            <div><label for="process-checklist-modal">Checklist:</label><input type="text" id="process-checklist-modal"><span class="error-message" id="error-process-checklist-modal"></span></div>
            <div><label for="process-company-codes-modal">Company Codes:</label><input type="text" id="process-company-codes-modal"><span class="error-message" id="error-process-company-codes-modal"></span></div>
            <div><label for="process-critical-modal">Critical (C/N):</label><input type="text" id="process-critical-modal"><span class="error-message" id="error-process-critical-modal"></span></div>
            <div><label for="process-description-modal">Description:</label><textarea id="process-description-modal" rows="3"></textarea><span class="error-message" id="error-process-description-modal"></span></div>
            <div><label for="process-frequency-modal">Frequency:</label><input type="text" id="process-frequency-modal"><span class="error-message" id="error-process-frequency-modal"></span></div>
            <div><label for="process-input-what-modal">Input (What):</label><input type="text" id="process-input-what-modal"><span class="error-message" id="error-process-input-what-modal"></span></div>
            <div><label for="process-input-who-modal">Input "Who":</label><input type="text" id="process-input-who-modal"><span class="error-message" id="error-process-input-who-modal"></span></div>
            <div><label for="process-output-who-modal">Output (Who):</label><input type="text" id="process-output-who-modal"><span class="error-message" id="error-process-output-who-modal"></span></div>
            <div><label for="process-responsibility-conso-modal">Responsibility - Conso:</label><input type="text" id="process-responsibility-conso-modal"><span class="error-message" id="error-process-responsibility-conso-modal"></span></div>
            <div><label for="process-process-type-modal">Process Type:</label>
                <select id="process-process-type-modal">
                    <option value="standard" selected>Standard</option>
                    <option value="blocking">Blocking</option>
                    <option value="informational">Informational</option>
                </select>
                <span class="error-message" id="error-process-process-type-modal"></span>
            </div>
            <div id="dynamic-fields-container"></div>
            <div class="button-group">
                <button type="button" id="delete-process-button" class="btn-fc btn-fc-danger delete-button" style="display:none;">Delete</button>
                <button type="button" id="save-process-button" class="btn-fc btn-fc-success save-button">Save</button>
                <button type="button" id="cancel-process-button" class="btn-fc btn-fc-secondary cancel-button">Cancel</button>
            </div>
        </div>
    </div>

    <div id="filter-panel">
        <button id="close-filter-panel-button" class="btn-fc btn-fc-close close-panel-button" title="Close Filters">&times;</button>
        <h3>Filters</h3>
        <div id="filter-options-container">
            <p>Load data to see filter options.</p>
        </div>
        <button id="apply-filters-button" class="btn-fc btn-fc-primary btn-fc-full">Apply Filters</button>
    </div>

    <div id="converter-panel">
        <button id="close-converter-panel-button" class="btn-fc btn-fc-close close-panel-button" title="Close Converter">&times;</button>
        <h1>XLSX to JSON Converter</h1>
        <p>Select an XLSX file. Each sheet will be converted. The output JSON will be an object with sheet names as keys.</p>
        <div class="warning">
            <strong>Important:</strong> Ensure column names in your XLSX file match expected keys (e.g., "ID", "Short name", "Process Type"). The converter will attempt to process all sheets.
        </div>
        <input type="file" id="xlsxFileInputConverter" accept=".xlsx, .xls">
        <button id="convertButtonConverter">Convert and Download JSON</button>
        <button id="convertAndLoadButtonConverter" style="margin-top: 10px; background-color: #17a2b8;">Convert and Load to Diagram</button>
        <div id="converter-status"></div>
        <h3>Generated JSON Preview (first 3 records of first sheet):</h3>
        <pre id="converterJsonPreview"></pre>
    </div>

<!-- === POCZĄTEK NOWEGO BLOKU HTML === -->
<div id="simulation-panel">
    <button id="close-simulation-panel-button" class="btn-fc btn-fc-close close-panel-button" title="Close Simulation Panel">×</button>
    <h3>Simulation Mode</h3>

    <!-- Główne przyciski akcji -->
    <button id="run-simulation-button" class="btn-fc btn-fc-primary btn-fc-full" style="margin-bottom: 5px;">Run / Update Simulation</button>
    <button id="end-simulation-button" class="btn-fc btn-fc-secondary btn-fc-full" style="display:none; margin-top:5px;">End Simulation</button>
    <button id="export-simulation-report-button" class="btn-fc btn-fc-accent btn-fc-full" style="display:none; margin-top:5px;">Export Report</button>

    <!-- Kontener na zarządzanie symulacją (karty procesów, dodawanie, scenariusze) -->
    <div id="multi-process-simulation-manager" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; display: none;">
        
        <h4>Processes in Simulation</h4>
        <!-- Tutaj JavaScript będzie dynamicznie generował karty dla każdego procesu -->
        <div id="simulation-targets-list"></div>

        <!-- Sekcja do dodawania kolejnych procesów do symulacji -->
        <div id="add-another-process-container" style="margin-top: 15px; padding-top: 10px; border-top: 1px dashed #ccc;">
            <label for="simulation-add-another-process-select" style="font-size: 0.9em; display: block; margin-bottom: 5px;">Add another process:</label>
            <div style="display: flex; gap: 5px;">
                <select id="simulation-add-another-process-select" style="flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background-color: white; box-sizing: border-box;">
                    <option value="">- Select a process to add -</option>
                </select>
                <button id="simulation-add-process-button" title="Add selected process to the current simulation" style="padding: 8px 12px;">Add</button>
            </div>
        </div>

        <!-- Sekcja zarządzania zapisanymi scenariuszami symulacji -->
        <div class="simulation-scenario-management">
            <label for="simulation-scenario-selector">Manage Scenarios:</label>
            <div style="display:flex; gap: 5px; margin-bottom: 8px;">
                <select id="simulation-scenario-selector" title="Load a saved simulation scenario" style="flex-grow: 1;">
                    <option value="">- Load Scenario -</option>
                </select>
                <button id="load-simulation-scenario-button" title="Load Selected Scenario" style="flex-shrink: 0;">Load</button>
                <!-- NOWY PRZYCISK DO USUWANIA -->
                <div class="delete-view-config-container">
                    <button id="delete-simulation-scenario-button" title="Open menu to delete a simulation scenario" style="padding: 8px 10px; font-size: 0.85em;">🗑️</button>
                    <div id="delete-simulation-scenario-dropdown" class="delete-view-config-dropdown">
                        <!-- Treść generowana przez JS -->
                    </div>
                </div>
            </div>
            <button id="save-simulation-scenario-button" title="Save current simulation parameters as a new scenario" style="width:100%;">Save Current as Scenario</button>
        </div>
    </div>
    
    <!-- Kontener na wyświetlanie wyników symulacji -->
    <div id="simulation-impact-info" style="margin-top:15px;">
        <div id="simulation-impact-list-container">
            <!-- Tutaj JavaScript będzie wstawiał podsumowanie wpływu -->
        </div>
    </div>
</div>
    <div id="colors-panel">
        <button id="close-colors-panel-button" class="close-panel-button" title="Close Colors Panel">×</button>
        <h3>Change Colors</h3>
        
        <div class="colors-panel-content">
            <h4>Process Colors</h4>
            <div class="color-group">
                <label for="colors-panel-node-color">Process (default):</label>
                <input type="color" id="colors-panel-node-color" value="#aedff7" title="Default Process Node Color">
            </div>
            <div class="color-group">
                <label for="colors-panel-blocking-node-color">Blocking Process:</label>
                <input type="color" id="colors-panel-blocking-node-color" value="#ffcc80" title="Blocking Process Node Color">
            </div>
            <div class="color-group">
                <label for="colors-panel-informational-node-color">Informational Process:</label>
                <input type="color" id="colors-panel-informational-node-color" value="#b3e5fc" title="Informational Process Node Color">
            </div>
            <div class="color-group">
                <label for="colors-panel-lightning-color">Lightning:</label>
                <input type="color" id="colors-panel-lightning-color" value="#00ff00" title="Selected Node Lightning Effect Color">
            </div>
            
            <h4>Dependency Colors</h4>
            <div class="color-group">
                <label for="colors-panel-input-process-color">Input Process (OK):</label>
                <input type="color" id="colors-panel-input-process-color" value="#d4edda" title="Input Dependent Process Color (OK)">
            </div>
            <div class="color-group">
                <label for="colors-panel-output-process-color">Output Process (OK):</label>
                <input type="color" id="colors-panel-output-process-color" value="#a3d9b1" title="Output Dependent Process Color (OK)">
            </div>
            
            <h4>Arrow Colors - Standard</h4>
            <div class="color-group">
                <label for="colors-panel-input-arrow-color">Input Arrow (Std):</label>
                <input type="color" id="colors-panel-input-arrow-color" value="#50c878" title="Input Dependency Arrow Color (Standard)">
            </div>
            <div class="color-group">
                <label for="colors-panel-output-arrow-color">Output Arrow (Std):</label>
                <input type="color" id="colors-panel-output-arrow-color" value="#ff7f7f" title="Output Dependency Arrow Color (Standard)">
            </div>
            
            <h4>Arrow Colors - Blocking</h4>
            <div class="color-group">
                <label for="colors-panel-input-arrow-blocking-color">Input Arrow (Block):</label>
                <input type="color" id="colors-panel-input-arrow-blocking-color" value="#FF0000" title="Input Blocking Dependency Arrow Color">
            </div>
            <div class="color-group">
                <label for="colors-panel-output-arrow-blocking-color">Output Arrow (Block):</label>
                <input type="color" id="colors-panel-output-arrow-blocking-color" value="#FF0000" title="Output Blocking Dependency Arrow Color">
            </div>
            
            <h4>Arrow Colors - Informational</h4>
            <div class="color-group">
                <label for="colors-panel-input-arrow-informational-color">Input Arrow (Info):</label>
                <input type="color" id="colors-panel-input-arrow-informational-color" value="#0000FF" title="Input Informational Dependency Arrow Color">
            </div>
            <div class="color-group">
                <label for="colors-panel-output-arrow-informational-color">Output Arrow (Info):</label>
                <input type="color" id="colors-panel-output-arrow-informational-color" value="#0000FF" title="Output Informational Dependency Arrow Color">
            </div>
            
            <h4>Simulation Colors</h4>
            <div class="color-group">
                <label for="colors-panel-sim-ok-input-color">Sim: Input OK:</label>
                <input type="color" id="colors-panel-sim-ok-input-color" value="#d4edda" title="Simulation Input OK Color">
            </div>
            <div class="color-group">
                <label for="colors-panel-sim-ok-output-color">Sim: Output OK:</label>
                <input type="color" id="colors-panel-sim-ok-output-color" value="#a3d9b1" title="Simulation Output OK Color">
            </div>
            <div class="color-group">
                <label for="colors-panel-sim-input-conflict-color">Sim: Input Conflict:</label>
                <input type="color" id="colors-panel-sim-input-conflict-color" value="#f8d7da" title="Simulation Input Conflict Color">
            </div>
            <div class="color-group">
                <label for="colors-panel-sim-output-at-risk-color">Sim: Output at Risk:</label>
                <input type="color" id="colors-panel-sim-output-at-risk-color" value="#e4a1a6" title="Simulation Output at Risk Color">
            </div>
            
            <div class="colors-panel-actions">
                <button id="colors-panel-reset-button" class="action-button reset-button">Reset to Default</button>
                <button id="colors-panel-generate-button" class="action-button generate-button">Generate New Theme</button>
            </div>
        </div>
    </div>

    <div id="tutorial-panel">
        <button id="close-tutorial-panel-button" class="close-panel-button" title="Close Tutorial">×</button>
        <h3>Interactive Diagram Tutorial</h3>

        <h4>Introduction</h4>
        <p>Welcome to FlowCraft! This powerful platform helps you visualize, analyze, and understand complex process flows and their dependencies. Use this guide to learn about its advanced features.</p>

        <h4>Data Management</h4>
        <p>This application uses a modern database-driven approach for process management:</p>
        <ul>
            <li><strong>Automatic Data Loading:</strong> Process data is automatically loaded from the database when you access this page through the Project Manager.</li>
            <li><strong>Project Manager:</strong> Use the main Project Manager to create, edit, and manage your processes and projects.</li>
            <li><strong>Real-time Sync:</strong> All changes made in the diagram (adding processes, editing dependencies, etc.) are automatically saved to the database.</li>
            <li><strong>No Manual Import Needed:</strong> The old Excel import functions have been replaced with seamless database integration.</li>
        </ul>
        <p>Process data includes columns like "Short name", "WD", "Due time", "Dependencies", "Process Type", and custom fields defined per project.</p>

        <h4>Understanding Process Nodes & Diagram Area</h4>
        <ul>
            <li>Each box (node) represents a process. It displays the "Short name".</li>
            <li>"WD" (Working Day) and "Due time" determine its position on the X (time/day) and Y (time of day) axes.</li>
            <li>Nodes can be of type "Standard", "Blocking" (<span class="code-like">B</span>), "Informational" (<span class="code-like">I</span>), or the new <strong>"Standard-Blocking"</strong> (<span class="code-like">S/B</span>) which has a dashed border. This affects dependency interpretation.</li>
            <li>Sticky axes (top and left) help you understand the timeline even when scrolled.</li>
        </ul>

        <h4>Navigating the Diagram</h4>
        <ul>
            <li><strong>Zoom:</strong> Use your mouse wheel to zoom in and out.</li>
            <li><strong>Pan:</strong> Click and drag the diagram background to move around.</li>
            <li><strong>Mini-Map:</strong> Toggle the Mini-Map using the 'M' button in the top right.</li>
            <li><strong>Reset View:</strong> Click 'Reset View' to return to the default zoom and position.</li>
        </ul>

        <h4>Filtering and Searching</h4>
        <ul>
            <li><strong>Filters:</strong> Click the 'Filters' button to filter processes based on attributes like "Company Codes", "WD", etc.</li>
            <li><strong>Search:</strong> Use the "Search processes..." bar to find nodes by ID, Short name, or Description.</li>
            <li><strong>Axis Filtering:</strong> Click on a WD label on the top axis or a time label on the left axis to quickly filter for that day/hour.</li>
        </ul>

        <h4>Interacting with Nodes</h4>
        <ul>
            <li><strong>Selection:</strong> Click a node to select it, highlight its dependencies, and dim other nodes.</li>
            <li><strong>Process Details:</strong> When a node is selected, its details appear at the bottom. From here, you can edit it or start a simulation.</li>
            <li><strong>Dependency Tree:</strong> With a node selected, use <span class="code-like">Menu > Show Dependencies</span> to open a side panel showing its input/output hierarchy.</li>
        </ul>

        <h4>Editing Dependencies</h4>
        <ol>
            <li>Go to <span class="code-like">Menu > Enable Dependency Editing</span>.</li>
            <li>Click on a source node. A green '+' handle appears on its right.</li>
            <li>Drag this '+' handle to a target node.</li>
            <li>On release, a context menu will appear. Choose the dependency type ("Standard", "Blocking", or "Informational").</li>
            <li>To remove a dependency, click the red '–' handle that appears on a linked output node.</li>
        </ol>

        <h4>Simulation Mode (Multi-Process)</h4>
        <p>This powerful mode allows you to see the potential impact of changing multiple processes at once without altering your actual data.</p>
        <ol>
            <li>Select a process and click the 'Simulate Impact' button in the details panel to start.</li>
            <li>The Simulation Panel opens with the first process on a "card". Here you can choose to <strong>Shift</strong> its WD/Time or <strong>Remove</strong> it from the flow.</li>
            <li>You can add more processes to the simulation using the "Add another process" dropdown at the bottom of the panel. Each will get its own card.</li>
            <li>After making your changes on the cards, you <strong>must click the 'Run / Update Simulation' button</strong> to see the effects on the diagram.</li>
            <li>The diagram will highlight the target processes and color-code any dependent nodes that are at risk or have timing conflicts. A summary appears in the panel.</li>
            <li>Use the 'End Simulation' button to exit and return to the normal view.</li>
            <li>You can also save the current set of changes as a named scenario for later use.</li>
        </ol>

        <h4>Presentation Mode</h4>
        <p>Click the 'Presentation' button for a clean, full-screen view ideal for showcasing the diagram. Most UI controls are hidden. Click 'Presentation' again to exit.</p>
        
        <h4>View Configurations</h4>
        <ul>
            <li><strong>Save View:</strong> After setting up desired filters and colors, go to <span class="code-like">Menu > Save View Config</span> to save this setup with a name.</li>
            <li><strong>Load/Delete View:</strong> Use the "Load View:" dropdown and the adjacent trash icon in the <span class="code-like">Menu</span> to apply or delete saved configurations.</li>
        </ul>

    </div>


    <div id="mini-map-wrapper">
        <svg id="mini-map-svg"></svg>
    </div>

	<div id="dependency-type-menu" class="context-menu">
    <div class="context-menu-item" data-type="standard">Standard</div>
    <div class="context-menu-item" data-type="blocking">Blocking (_B)</div>
    <div class="context-menu-item" data-type="informational">Informational (_I)</div>
	</div>

<script>
    const dependencyTypeMenu = document.getElementById('dependency-type-menu');
    let pendingLinkSourceId = null;
    let pendingLinkSourceSheet = null;
    let pendingLinkTargetId = null;
    let pendingLinkTargetProcess = null; 
    let lastMouseUpEvent = null; 
    let processesData = {};
	let isProgrammaticClick = false;
	let blockNextGlobalClick = false;
    let selectedSheetViews = [];
    let allDataSourceSheetNames = [];

    let sheetColors = ['#aedff7', '#f7aeae', '#aef7af', '#f7d9ae', '#aeaef7', '#f7aef7', '#aff7f7', '#cccccc', '#99ccff', '#ffcc99'];
	const darkSheetColors = ['#2c5a71', '#733e3e', '#3e6b40', '#715f3e', '#524371', '#713e71', '#3e7171', '#555555', '#99ccff', '#805c33'];

    let currentZoom = 1;
    const diagramContainer = document.getElementById('diagram-container');
    const diagramPane = document.getElementById('diagram-zoom-pane');
    const svgLayer = document.getElementById('dependency-svg');
    const simulationGhostLayer = document.getElementById('simulation-ghost-layer');
    const detailsPane = document.getElementById('process-details');
    // Old file input elements removed - using Supabase now
	
	let isPanning = false; let panStartX=0, panStartY=0; let initialScrollLeft=0, initialScrollTop=0;

    const modal = document.getElementById('process-modal');
    const modalTitle = document.getElementById('modal-title');
    const saveProcessButton = document.getElementById('save-process-button');
    const cancelProcessButton = document.getElementById('cancel-process-button');
    const deleteProcessButton = document.getElementById('delete-process-button');
    const dynamicFieldsContainer = document.getElementById('dynamic-fields-container');
	
	const XLSX_REQUIRED_KEYS = new Set(["ID", "Short name", "WD", "Due time"]);
    const XLSX_KEY_VALIDATION_SAMPLES = 5; 

    const filterPanel = document.getElementById('filter-panel');
    const filterOptionsContainer = document.getElementById('filter-options-container');
    const toggleFilterPanelButton = document.getElementById('toggle-filter-panel-button');
    const closeFilterPanelButton = document.getElementById('close-filter-panel-button');
    const applyFiltersButton = document.getElementById('apply-filters-button');

    const converterPanel = document.getElementById('converter-panel');
    // const toggleConverterPanelButton = document.getElementById('toggle-converter-panel-button'); // Usunięty w nowym interfejsie
    const closeConverterPanelButton = document.getElementById('close-converter-panel-button');
    const xlsxFileInputConverter = document.getElementById('xlsxFileInputConverter');
    const convertButtonConverter = document.getElementById('convertButtonConverter');
    const convertAndLoadButtonConverter = document.getElementById('convertAndLoadButtonConverter');
    const converterStatusDiv = document.getElementById('converter-status');
    const converterJsonPreview = document.getElementById('converterJsonPreview');

    const searchInput = document.getElementById('search-process-input');
    const togglePresentationModeButton = document.getElementById('toggle-presentation-mode-button');

    const toggleDependencyEditButton = document.getElementById('toggle-dependency-edit-button');


    const sheetMultiSelectButton = document.getElementById('top-sheet-multi-select-button');
    const sheetMultiSelectDropdown = document.getElementById('top-sheet-multi-select-dropdown');
    const sheetMultiSelectOptions = document.getElementById('top-sheet-multi-select-options');
    const sheetSelectAllCheckbox = document.getElementById('top-sheet-select-all-checkbox');


    const menuButton = document.getElementById('menu-button');
    const menuContent = document.getElementById('menu-content');

    const visualControlsContainer = document.querySelector('.visual-controls');


    const saveViewConfigButton = document.getElementById('save-view-config-button');
    const loadViewConfigSelector = document.getElementById('view-config-selector');
    const deleteViewConfigButton = document.getElementById('delete-view-config-button');
    const deleteViewConfigDropdown = document.getElementById('delete-view-config-dropdown');

    // Supabase Configuration
    // Secure Supabase configuration
    const supabaseConfig = window.FlowCraftSecurity.getSupabaseConfig();
    
    // Initialize Supabase client
    const { createClient } = supabase;
    const supabaseClient = createClient(supabaseConfig.url, supabaseConfig.anonKey);

    // Get URL parameters for new project/sheet system
    const urlParams = new URLSearchParams(window.location.search);
    const currentSheetId = urlParams.get('sheet');
    const currentProjectId = urlParams.get('project');
    let currentSheetData = null; // Will store sheet info with custom_fields
    let currentCustomFields = {}; // Custom fields from current sheet

    const LOCAL_STORAGE_KEY = 'interactiveProcessDiagram_V23_MainState';
    const VIEW_CONFIGS_STORAGE_KEY = 'diagramViewConfigurations_V23';
    const SIMULATION_SCENARIOS_STORAGE_KEY = 'diagramSimulationScenarios_V23';

    const miniMapWrapper = document.getElementById('mini-map-wrapper');
    const miniMapSvg = document.getElementById('mini-map-svg');
    let miniMapViewportRect = null;
    let overallDiagramBounds = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    const toggleMiniMapButton = document.getElementById('toggle-mini-map-button');

    const dependencyPanelContainer = document.getElementById('dependency-panel-container');
    const dependencyPanelTitle = document.getElementById('dependency-panel-title');
    const dependencyTreeContent = document.getElementById('dependency-tree-content');
    const dependencyTreeSvg = document.getElementById('dependency-tree-svg');
    const menuDependencyPanelTrigger = document.getElementById('menu-dependency-panel-trigger');
    const closeDependencyPanelBtn = document.getElementById('close-dependency-panel-button');
    const highlightTreeNodesButton = document.getElementById('highlight-tree-nodes-button');

    const linkHandleTrigger = document.getElementById('link-handle-trigger'); 
    let isLinking = false;
    let linkStartProcessId = null;
    let linkStartProcessSheet = null;
    let tempLinkLine = null;
    let dependencyEditingEnabled = false; 


    const simulationPanel = document.getElementById('simulation-panel');
    const closeSimulationPanelButton = document.getElementById('close-simulation-panel-button');
    const simulationTargetNameSpan = document.getElementById('simulation-target-name');
    const simulationTargetIdSpan = document.getElementById('simulation-target-id-display');
    
    const simulationTypeSelectorGroup = document.querySelector('.simulation-type-selector-group');
    const activeSimulationTypeInput = document.getElementById('active-simulation-type');
    
    const simulationShiftInputsDiv = document.getElementById('simulation-shift-inputs');
    const simulationAddInputsDiv = document.getElementById('simulation-add-inputs'); 
    const simulationNewWdInput = document.getElementById('simulation-new-wd');
    const simulationNewDueTimeInput = document.getElementById('simulation-new-due-time');
    const runSimulationButton = document.getElementById('run-simulation-button');
    const endSimulationButton = document.getElementById('end-simulation-button');
    const exportSimulationReportButton = document.getElementById('export-simulation-report-button'); 
    const simulationImpactListContainer = document.getElementById('simulation-impact-list-container'); 
    const undoSimulationParamsButton = document.getElementById('undo-simulation-params-button');
    const saveSimulationScenarioButton = document.getElementById('save-simulation-scenario-button');
    const loadSimulationScenarioButton = document.getElementById('load-simulation-scenario-button');
    const simulationScenarioSelector = document.getElementById('simulation-scenario-selector');
    
    let isSimulationModeActive = false;
    // MODYFIKACJA START: Zmiana z pojedynczego celu na tablicę celów
    let simulationTargets = []; // Format: [{id, sheet, type, params: {wd, dueTime}}]
    // let simulationTargetProcessId = null; // Zastąpione przez simulationTargets
    // let simulationTargetProcessSheet = null; // Zastąpione przez simulationTargets
    let currentSimulationType = 'remove'; // Używane głównie do przełączania UI, stan jest w simulationTargets
    // let simulatedShiftWd = null; // Zastąpione przez params w simulationTargets
    // let simulatedShiftDueTime = null; // Zastąpione przez params w simulationTargets
    let simulatedNewProcessData = null; // Pozostaje dla typu 'add' (nowy proces)
    // MODYFIKACJA KONIEC 
    let originalSimulatedNodeStyles = { top: null, left: null, zIndex: null, ghostElement: null };
    let previousSimulationParams = {};
    let currentImpactPaths = [];

    const notificationBar = document.getElementById('notification-bar');
    const notificationMessageSpan = document.getElementById('notification-message');
    const notificationCloseButton = document.getElementById('notification-close');
    let notificationTimeout;

    const tutorialPanel = document.getElementById('tutorial-panel');
    const toggleTutorialPanelButton = document.getElementById('toggle-tutorial-panel-button');
    const closeTutorialPanelButton = document.getElementById('close-tutorial-panel-button');
    const welcomeMessageOverlay = document.getElementById('welcome-message-overlay');

    const colorsPanel = document.getElementById('colors-panel');
    const closeColorsPanelButton = document.getElementById('close-colors-panel-button');

    const shortcutShowDependenciesButton = document.getElementById('shortcut-show-dependencies-button');
    const shortcutSimulateImpactButton = document.getElementById('shortcut-simulate-impact-button');


    const SVG_NS = "http://www.w3.org/2000/svg";
    const DEP_TREE_MAX_DEPTH = 3; 
    let topBarHeight = 0;

    let currentDependencyTreeRootProcess = null;
    let currentTreeInputsData = [];
    let currentTreeOutputsData = [];
    let dependencyTreeNodeMap = new Map(); 


    let temporaryActiveFilters = {};
    let currentAppliedFilters = {};
    let currentAxisFilter = { type: null, value: null, valueEnd: null };
    let currentlySelectedProcessId = null;
    let nodeLayouts = {};

    let isTreeHighlightActive = false;
    let highlightedTreeNodesIds = new Set();

    const PADDING = 60;
    const NODE_BASE_WIDTH = 80;
    const NODE_HEIGHT = 26;
    const VERTICAL_NODE_PADDING = 6;
    const Y_AXIS_LABEL_WIDTH_ORIGINAL = 55;
    const STICKY_Y_AXIS_WIDTH = Y_AXIS_LABEL_WIDTH_ORIGINAL;
    const STICKY_X_AXIS_HEIGHT = 25;
    const SCROLLBAR_HEIGHT_ESTIMATE = 18;
    let gTimeBins = [];
    let gUniqueDataWds = [];
    let gUniqueDueTimeHours = [];
    let gWdColumnWidth = 0;
    let gPlotWidth = 0;
    let gPlotHeight = 0;
    let gTimeBinSizeSec = 3600;
    let gDiagramPanePadding = PADDING;
    let gYAxisLabelWidthOriginal = Y_AXIS_LABEL_WIDTH_ORIGINAL;
    let stickyYAxisContainer = null;
    let stickyXAxisContainer = null;
    let stickyAxisInitialized = false;

    const SHAREPOINT_DOWNLOAD_LINK = "https://salesbridge.sharepoint.com/sites/BSEMIA-BSBEBS/Quality/_layouts/download.aspx?SourceUrl=https://salesbridge.sharepoint.com/sites/BSEMIA-BSBEBS/Quality/Test%20RTR/processes_multisheet_converted%20%20(4).xlsx";

// =======================================================================
// === NOWA, PROFESJONALNA KOLEKCJA MOTYWÓW KOLORYSTYCZNYCH v3 ===
// =======================================================================
const THEMES_BASE = [
    // === KATEGORIA 1: MOTYWY MARKI BRIDGESTONE ===
    {
        name: "Bridgestone Classic",
        node: '#F0F2F5',
        blockingNode: '#FFC107',
        informationalNode: '#CFD8DC',
        lightning: '#DA291C',
        inputProcess: '#EEEEEE',
        outputProcess: '#FFEBEE',
        inputArrow: '#424242',
        outputArrow: '#DA291C',
        inputArrowBlocking: '#DA291C',
        outputArrowBlocking: '#DA291C',
        inputArrowInformational: '#9E9E9E',
        outputArrowInformational: '#9E9E9E',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Bridgestone Inverted",
        node: '#263238',
        blockingNode: '#FDD835',
        informationalNode: '#455A64',
        lightning: '#DA291C',
        inputProcess: '#424242',
        outputProcess: '#562226',
        inputArrow: '#B0BEC5',
        outputArrow: '#DA291C',
        inputArrowBlocking: '#EF5350',
        outputArrowBlocking: '#EF5350',
        inputArrowInformational: '#78909C',
        outputArrowInformational: '#78909C',
        nodeSymbolColor: '#CFD8DC'
    },
    {
        name: "Bridgestone Premium",
        node: '#FAFAFA',
        blockingNode: '#FFEB3B',
        informationalNode: '#F5F5F5',
        lightning: '#DA291C',
        inputProcess: '#E8EAF6',
        outputProcess: '#FFEBEE',
        inputArrow: '#1976D2',
        outputArrow: '#DA291C',
        inputArrowBlocking: '#F57C00',
        outputArrowBlocking: '#F57C00',
        inputArrowInformational: '#616161',
        outputArrowInformational: '#616161',
        nodeSymbolColor: '#212121'
    },
    {
        name: "Bridgestone Motorsport",
        node: '#1A1A1A',
        blockingNode: '#FFD600',
        informationalNode: '#2D2D2D',
        lightning: '#DA291C',
        inputProcess: '#212121',
        outputProcess: '#424242',
        inputArrow: '#BDBDBD',
        outputArrow: '#DA291C',
        inputArrowBlocking: '#FF6F00',
        outputArrowBlocking: '#FF6F00',
        inputArrowInformational: '#757575',
        outputArrowInformational: '#757575',
        nodeSymbolColor: '#FFFFFF'
    },
    // === KATEGORIA 2: MOTYWY TEMATYCZNE (SPOKOJNY PRZEPŁYW) ===
    {
        name: "Oceanic Flow",
        node: '#E0F7FA',
        blockingNode: '#FFAB40',
        informationalNode: '#ECEFF1',
        lightning: '#00796B',
        inputProcess: '#B2DFDB',
        outputProcess: '#80CBC4',
        inputArrow: '#009688',
        outputArrow: '#00695C',
        inputArrowBlocking: '#FF7043',
        outputArrowBlocking: '#FF7043',
        inputArrowInformational: '#4DB6AC',
        outputArrowInformational: '#4DB6AC',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Sunrise Warmth",
        node: '#FFF8E1',
        blockingNode: '#4FC3F7',
        informationalNode: '#FFFDE7',
        lightning: '#E65100',
        inputProcess: '#FFECB3',
        outputProcess: '#FFD54F',
        inputArrow: '#FFB300',
        outputArrow: '#FF8F00',
        inputArrowBlocking: '#D84315',
        outputArrowBlocking: '#D84315',
        inputArrowInformational: '#FFCA28',
        outputArrowInformational: '#FFCA28',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Forest Serenity",
        node: '#E8F5E8',
        blockingNode: '#FFB74D',
        informationalNode: '#F1F8E9',
        lightning: '#2E7D32',
        inputProcess: '#C8E6C9',
        outputProcess: '#A5D6A7',
        inputArrow: '#388E3C',
        outputArrow: '#2E7D32',
        inputArrowBlocking: '#FF5722',
        outputArrowBlocking: '#FF5722',
        inputArrowInformational: '#66BB6A',
        outputArrowInformational: '#66BB6A',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Lavender Dreams",
        node: '#F3E5F5',
        blockingNode: '#FFA726',
        informationalNode: '#FAF2FF',
        lightning: '#6A1B9A',
        inputProcess: '#E1BEE7',
        outputProcess: '#CE93D8',
        inputArrow: '#8E24AA',
        outputArrow: '#7B1FA2',
        inputArrowBlocking: '#E65100',
        outputArrowBlocking: '#E65100',
        inputArrowInformational: '#AB47BC',
        outputArrowInformational: '#AB47BC',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Arctic Frost",
        node: '#F0F4F8',
        blockingNode: '#FF7043',
        informationalNode: '#FAFBFC',
        lightning: '#1565C0',
        inputProcess: '#CFD8DC',
        outputProcess: '#B0BEC5',
        inputArrow: '#455A64',
        outputArrow: '#263238',
        inputArrowBlocking: '#D32F2F',
        outputArrowBlocking: '#D32F2F',
        inputArrowInformational: '#607D8B',
        outputArrowInformational: '#607D8B',
        nodeSymbolColor: '#000000'
    },
    // === KATEGORIA 3: MOTYWY FUNKCJONALNE (WYSOKI KONTRAST WEJŚCIE/WYJŚCIE) ===
    {
        name: "Clarity: Green & Purple",
        node: '#ECEFF1',
        blockingNode: '#FDD835',
        informationalNode: '#F5F5F5',
        lightning: '#0288D1',
        inputProcess: '#E8F5E9',
        outputProcess: '#F3E5F5',
        inputArrow: '#4CAF50',
        outputArrow: '#8E24AA',
        inputArrowBlocking: '#EF5350',
        outputArrowBlocking: '#EF5350',
        inputArrowInformational: '#90A4AE',
        outputArrowInformational: '#90A4AE',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Blueprint: Blue & Orange",
        node: '#E3F2FD',
        blockingNode: '#66BB6A',
        informationalNode: '#F5F5F5',
        lightning: '#F44336',
        inputProcess: '#BBDEFB',
        outputProcess: '#FFCCBC',
        inputArrow: '#1976D2',
        outputArrow: '#F57C00',
        inputArrowBlocking: '#C62828',
        outputArrowBlocking: '#C62828',
        inputArrowInformational: '#64B5F6',
        outputArrowInformational: '#64B5F6',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Neon Tech: Cyan & Magenta",
        node: '#F0FDFF',
        blockingNode: '#FFC107',
        informationalNode: '#FAFAFA',
        lightning: '#E91E63',
        inputProcess: '#B2EBF2',
        outputProcess: '#F8BBD9',
        inputArrow: '#00BCD4',
        outputArrow: '#E91E63',
        inputArrowBlocking: '#FF5722',
        outputArrowBlocking: '#FF5722',
        inputArrowInformational: '#26C6DA',
        outputArrowInformational: '#26C6DA',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Corporate: Indigo & Amber",
        node: '#E8EAF6',
        blockingNode: '#4CAF50',
        informationalNode: '#F3F4F6',
        lightning: '#D32F2F',
        inputProcess: '#C5CAE9',
        outputProcess: '#FFECB3',
        inputArrow: '#3F51B5',
        outputArrow: '#FF8F00',
        inputArrowBlocking: '#C62828',
        outputArrowBlocking: '#C62828',
        inputArrowInformational: '#5C6BC0',
        outputArrowInformational: '#5C6BC0',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Medical: Teal & Rose",
        node: '#E0F2F1',
        blockingNode: '#FFAB40',
        informationalNode: '#FCE4EC',
        lightning: '#B71C1C',
        inputProcess: '#B2DFDB',
        outputProcess: '#F8BBD9',
        inputArrow: '#00695C',
        outputArrow: '#C2185B',
        inputArrowBlocking: '#E65100',
        outputArrowBlocking: '#E65100',
        inputArrowInformational: '#26A69A',
        outputArrowInformational: '#26A69A',
        nodeSymbolColor: '#000000'
    },
    // === KATEGORIA 4: MOTYWY SPECJALNE/SEZONOWE ===
    {
        name: "Autumn Harvest",
        node: '#FFF8E1',
        blockingNode: '#2196F3',
        informationalNode: '#FFFDE7',
        lightning: '#D84315',
        inputProcess: '#FFCC80',
        outputProcess: '#FFAB91',
        inputArrow: '#FF8F00',
        outputArrow: '#BF360C',
        inputArrowBlocking: '#1976D2',
        outputArrowBlocking: '#1976D2',
        inputArrowInformational: '#FFB74D',
        outputArrowInformational: '#FFB74D',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Spring Bloom",
        node: '#F1F8E9',
        blockingNode: '#E91E63',
        informationalNode: '#E8F5E8',
        lightning: '#388E3C',
        inputProcess: '#DCEDC8',
        outputProcess: '#F8BBD9',
        inputArrow: '#689F38',
        outputArrow: '#C2185B',
        inputArrowBlocking: '#AD1457',
        outputArrowBlocking: '#AD1457',
        inputArrowInformational: '#8BC34A',
        outputArrowInformational: '#8BC34A',
        nodeSymbolColor: '#000000'
    },
    {
        name: "Midnight Professional",
        node: '#212121',
        blockingNode: '#FFC107',
        informationalNode: '#303030',
        lightning: '#00E676',
        inputProcess: '#424242',
        outputProcess: '#2E2E2E',
        inputArrow: '#81C784',
        outputArrow: '#00E676',
        inputArrowBlocking: '#FF9800',
        outputArrowBlocking: '#FF9800',
        inputArrowInformational: '#A5D6A7',
        outputArrowInformational: '#A5D6A7',
        nodeSymbolColor: '#FFFFFF'
    },
    {
        name: "Sunset Gradient",
        node: '#FFFDE7',
        blockingNode: '#5C6BC0',
        informationalNode: '#FFF3E0',
        lightning: '#E91E63',
        inputProcess: '#FFECB3',
        outputProcess: '#FFCDD2',
        inputArrow: '#FF6F00',
        outputArrow: '#E91E63',
        inputArrowBlocking: '#3F51B5',
        outputArrowBlocking: '#3F51B5',
        inputArrowInformational: '#FFA726',
        outputArrowInformational: '#FFA726',
        nodeSymbolColor: '#000000'
    },
];

// === KATEGORIA DODATKOWA: TEMATY WYSOKIEGO KONTRASTU ===
const HIGH_CONTRAST_THEMES = [
    {
        name: "High Contrast Light",
        node: '#FFFFFF',
        blockingNode: '#FFD600',
        informationalNode: '#F0F0F0',
        lightning: '#000000',
        inputProcess: '#E8F5E8',
        outputProcess: '#FFEBEE',
        inputArrow: '#000000',
        outputArrow: '#000000',
        inputArrowBlocking: '#FF0000',
        outputArrowBlocking: '#FF0000',
        inputArrowInformational: '#404040',
        outputArrowInformational: '#404040',
        nodeSymbolColor: '#000000'
    },
    {
        name: "High Contrast Dark",
        node: '#000000',
        blockingNode: '#FFFF00',
        informationalNode: '#1A1A1A',
        lightning: '#FFFFFF',
        inputProcess: '#0A4A0A',
        outputProcess: '#4A0A0A',
        inputArrow: '#FFFFFF',
        outputArrow: '#FFFFFF',
        inputArrowBlocking: '#FF0000',
        outputArrowBlocking: '#FF0000',
        inputArrowInformational: '#AAAAAA',
        outputArrowInformational: '#AAAAAA',
        nodeSymbolColor: '#FFFFFF'
    }
];

// Połącz wszystkie tematy
const ALL_THEMES = [...THEMES_BASE, ...HIGH_CONTRAST_THEMES];

const SIMULATION_COLORS = {
    simOkInput: '#D4EDDA',
    simOkOutput: '#A3D9B1',
    simInputConflict: '#F8D7DA',
    simOutputAtRisk: '#E4A1A6'
};

const THEMES = ALL_THEMES.map(theme => ({
    ...theme,
    ...SIMULATION_COLORS
}));

// =======================================================================

// Zmienna przechowująca indeks aktualnego motywu
let currentThemeIndex = 0;

// Inicjalizacja bieżącej konfiguracji kolorów jako kopii pierwszego motywu (domyślnego)
let configColors = JSON.parse(JSON.stringify(THEMES[0]));    const expectedDiagramKeys = [
        "ID", "Short name", "WD", "Due time", "Dependencies",
        "Checklist", "Company Codes", "Critical (C) or Non-Critical (N)",
        "Description", "Frequency", "Input (What)", "Input \"Who\"",
        "Output (Who)", "Responsibility - Conso", "Process Type"
    ];
    const JSON_VALIDATION_REQUIRED_KEYS = ["ID", "WD", "Due time"];


    // MODIFICATION: Added _targetSheet for modal internal use (not saved to process data with this key)
    const allProcessFields = [
        // { idSuffix: "target-sheet-modal", jsonKey: "_targetSheet", type: "sheet-select", label: "Target Sheet" }, // Placeholder for form logic
        { idSuffix: "id-modal", jsonKey: "ID", type: "text", readOnlyEdit: false, required: true }, // Made ID editable
        { idSuffix: "short-name-modal", jsonKey: "Short name", type: "text", required: true },
        { idSuffix: "wd-modal", jsonKey: "WD", type: "number", required: true },
        { idSuffix: "due-time-modal", jsonKey: "Due time", type: "custom-time", required: true },
        { idSuffix: "dependencies-modal", jsonKey: "Dependencies", type: "text" },
        { idSuffix: "checklist-modal", jsonKey: "Checklist", type: "text" },
        { idSuffix: "company-codes-modal", jsonKey: "Company Codes", type: "text" },
        { idSuffix: "critical-modal", jsonKey: "Critical (C) or Non-Critical (N)", type: "text" },
        { idSuffix: "description-modal", jsonKey: "Description", type: "textarea" },
        { idSuffix: "frequency-modal", jsonKey: "Frequency", type: "text" },
        { idSuffix: "input-what-modal", jsonKey: "Input (What)", type: "text" },
        { idSuffix: "input-who-modal", jsonKey: "Input \"Who\"", type: "text" },
        { idSuffix: "output-who-modal", jsonKey: "Output (Who)", type: "text" },
        { idSuffix: "responsibility-conso-modal", jsonKey: "Responsibility - Conso", type: "text" },
        // MODYFIKACJA START: Dodanie nowej opcji do Process Type
        { idSuffix: "process-process-type-modal", jsonKey: "Process Type", type: "select", options: ["standard", "blocking", "informational", "standard-blocking"], default: "standard" }
        // MODYFIKACJA KONIEC
    ];
    const excludedFilterKeys = new Set(["ID", "Short name", "Dependencies", "Description"]);
    const multiSelectFilterKeys = new Set(["Checklist", "Company Codes", "Critical (C) or Non-Critical (N)", "Frequency", "Input (What)", "Input \"Who\"", "Output (Who)", "Responsibility - Conso", "WD"]);


            notificationCloseButton.addEventListener('click', () => {
            notificationBar.style.animation = 'notificationSlideOut 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            setTimeout(() => {
                notificationBar.style.display = 'none';
                notificationBar.style.animation = '';
                notificationBar.removeAttribute('data-type');
            }, 300);
            if (notificationTimeout) clearTimeout(notificationTimeout);
        });

    // Initialize application with sheet context
    async function initializeApp() {
        if (currentSheetId) {
            await loadSheetData();
            await loadProjectSheetsForDisplay(); // Load all project sheets for VIEW & DISPLAY
            await loadMultipleSheetsFromSupabase(); // Load data from selected sheets
            
            // Initialize diagram after loading data
            updateGlobalUniqueDueTimeHours(); 
            populateFilterPanel(); 
            renderDiagram(); 
            resetVisualStates(); 
            saveStateToLocalStorage();
            
            // Optional: Force refresh status data after initial load to ensure latest data
            setTimeout(async () => {
                console.log('🔄 Force refreshing status data after initial load...');
                await loadDataFromSupabase();
            }, 1000);
        } else {
            showNotification("No sheet specified. Please access this page through the project manager.", "warning");
        }
    }



    // Load project sheets for display in VIEW & DISPLAY section
    async function loadProjectSheetsForDisplay() {
        if (!currentProjectId) return;
        
        try {
            const { data: sheets, error } = await supabaseClient
                .from('sheets')
                .select('id, name')
                .eq('project_id', currentProjectId)
                .order('name');

            if (error) throw error;

            // Update allDataSourceSheetNames with all project sheets
            allDataSourceSheetNames = sheets.map(sheet => sheet.name);
            
            if (allDataSourceSheetNames.length === 0) {
                showNotification("This project has no sheets. Please create a sheet in the project manager.", 'warning');
            } else {
                // If no sheet is currently selected, select the current sheet
                if (selectedSheetViews.length === 0 && currentSheetData) {
                    selectedSheetViews = [currentSheetData.name];
                } else if (selectedSheetViews.length === 0 && allDataSourceSheetNames.length > 0) {
                    // If no current sheet, select all sheets by default
                    selectedSheetViews = [...allDataSourceSheetNames];
                }
            }

            // Update the sheet selector dropdown in top menu
            updateSheetMultiSelectDropdown();
            updateTopSheetSelectionText();
            
            console.log('Loaded project sheets for display:', allDataSourceSheetNames);
        } catch (error) {
            console.error('Error loading project sheets for display:', error);
            showNotification("Error loading project sheets: " + error.message, 'error');
        }
    }

    // Load sheet data and custom fields
    async function loadSheetData() {
        try {
            const { data: sheet, error } = await supabaseClient
                .from('sheets')
                .select('*')
                .eq('id', currentSheetId)
                .single();

            if (error) throw error;

            currentSheetData = sheet;
            currentCustomFields = sheet.custom_fields || {};
            
            // Update page title
            document.title = `Diagram - ${sheet.name}`;
            
            showNotification(`Loaded sheet: ${sheet.name}`, "success");
        } catch (error) {
            console.error('Error loading sheet data:', error);
            showNotification("Error loading sheet data: " + error.message, "error");
        }
    }



    // Listen for status updates from process manager window
    window.addEventListener('message', function(event) {
        console.log('Message received in diagram:', event.data);
        
        if (event.origin !== window.location.origin) {
            console.warn('Message from different origin ignored:', event.origin);
            return;
        }
        
        if (event.data.type === 'PROCESS_STATUS_UPDATED') {
            const { processId, newStatus, completionNote } = event.data;
            console.log(`Processing status update: ${processId} -> ${newStatus}`);
            
            // Update process data in memory
            let processFound = false;
            console.log(`Looking for process with ID: ${processId}`);
            
            for (const sheetName in processesData) {
                const process = processesData[sheetName].find(p => {
                    return p._databaseId == processId; // Use == for type coercion
                });
                if (process) {
                    console.log(`Found process to update: ${process["Short name"]} (ID: ${process._databaseId})`);
                    console.log(`Updating status from ${process.status} to ${newStatus}`);
                    const oldStatus = process.status;
                    process.status = newStatus;
                    process.completion_note = completionNote;
                    console.log(`Status changed: ${oldStatus} → ${process.status}`);
                    
                    if (newStatus.includes('COMPLETED')) {
                        process.completed_at = new Date().toISOString();
                    } else if (newStatus === 'PENDING') {
                        // Clear completion data for reset status
                        process.completed_at = null;
                        process.completion_note = null;
                    }
                    
                    console.log(`Process ${process["Short name"]} status updated to ${newStatus}`);
                    processFound = true;
                    break;
                }
            }
            
            if (processFound) {
                // Re-render diagram to show updated status
                console.log('Re-rendering diagram with updated status...');
                renderDiagramAndRestoreState();
                showNotification(`Process status synchronized from manager`, 'success');
                
                // Force refresh from database to ensure we have latest data
                setTimeout(() => {
                    console.log('Force refreshing from database after status update...');
                    loadDataFromSupabase();
                }, 1000);
            } else {
                console.warn(`Process with ID ${processId} not found in diagram data`);
                console.log('Available process IDs:', 
                    Object.values(processesData).flat().map(p => `${p._databaseId} (${p["Short name"]})`));
                // Try to reload from database as fallback
                console.log('Attempting to reload data from database...');
                loadDataFromSupabase();
            }
        }
    });

    // Periodic status refresh to ensure diagram stays synchronized
    function initPeriodicRefresh() {
        // Check for status updates every 10 minutes for background synchronization
        setInterval(async () => {
            if (currentSheetId && Object.keys(processesData).length > 0) {
                console.log('Performing periodic status refresh (10min interval)...');
                try {
                    await loadDataFromSupabase();
                } catch (error) {
                    console.warn('Periodic refresh failed:', error);
                }
            }
        }, 600000); // 10 minutes
    }
    
    // Start periodic refresh if data is already loaded
    if (currentSheetId) {
        initPeriodicRefresh();
        console.log('📅 Background refresh set to every 10 minutes');
    }

    // Navigation event listeners
    document.getElementById('app-logo-header').addEventListener('click', () => {
        if (confirm('Are you sure you want to go back to the Home Page? Any unsaved changes in the diagram will be lost.')) {
            window.location.href = 'index.html';
        }
    });



    document.getElementById('manage-columns-diagram-btn').addEventListener('click', () => {
        if (currentSheetId && currentSheetData) {
            // Redirect to ProcessDiagramApp.html with current sheet to manage columns
            window.location.href = `index.html?openSheet=${currentSheetId}&project=${currentProjectId}`;
        } else {
            showNotification('Please load a sheet first to manage its columns.', 'warning');
        }
    });

    document.getElementById('reset-button').addEventListener('click', () => {
        if (isSimulationModeActive) endSimulation();
        currentZoom = 1;
        diagramPane.style.transform = `scale(${currentZoom})`;
        fullReset();
        diagramContainer.scrollTop = 0;
        diagramContainer.scrollLeft = 0;
        requestAnimationFrame(() => {
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
            drawMiniMap();
            updateMiniMapViewPort();
        });
        saveStateToLocalStorage();
    });
    document.getElementById('add-process-button').addEventListener('click', openAddModal);
    
    // === OBSŁUGA SUBMENU W DATA MANAGEMENT ===
    function setupSubmenuToggles() {
        const sections = ['load', 'save', 'clear'];
        
        sections.forEach(section => {
            const header = document.getElementById(`${section}-section-toggle`);
            const content = document.getElementById(`${section}-section-content`);
            
            if (header && content) {
                header.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isExpanded = content.classList.contains('expanded');
                    
                    // Najpierw zamknij wszystkie inne sekcje
                    sections.forEach(otherSection => {
                        if (otherSection !== section) {
                            const otherHeader = document.getElementById(`${otherSection}-section-toggle`);
                            const otherContent = document.getElementById(`${otherSection}-section-content`);
                            if (otherHeader && otherContent) {
                                otherHeader.classList.remove('expanded');
                                otherContent.classList.remove('expanded');
                            }
                        }
                    });
                    
                    // Potem przełącz bieżącą sekcję
                    if (isExpanded) {
                        header.classList.remove('expanded');
                        content.classList.remove('expanded');
                    } else {
                        header.classList.add('expanded');
                        content.classList.add('expanded');
                    }
                });
            }
        });
    }
    
    // === FUNKCJA EKSPORTU JSON ===
    function exportToJson() {
        if (Object.keys(processesData).length === 0) {
            showNotification("No data to export. Please load data first.", "warning");
            return;
        }

        try {
            const exportData = JSON.parse(JSON.stringify(processesData));
            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `diagram_data_${new Date().toISOString().slice(0,10)}.json`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            
            showNotification("JSON file exported successfully!", "success");
        } catch (error) {
            console.error("Error exporting JSON:", error);
            showNotification("Error exporting JSON file. Please try again.", "error");
        }
    }
    
    // Dodaj event listener dla nowego przycisku eksportu JSON
    const exportJsonButton = document.getElementById('export-json-button');
    if (exportJsonButton) {
        exportJsonButton.addEventListener('click', exportToJson);
    }
    
    // Inicjalizuj submenu
    setupSubmenuToggles();
    
    // === DEPENDENCIES AUTOCOMPLETE SETUP ===
    function setupDependenciesAutocomplete() {
        const dependenciesInput = document.getElementById('process-dependencies-modal');
        const autocompleteDiv = document.getElementById('dependencies-autocomplete');
        
        if (!dependenciesInput || !autocompleteDiv) return;
        
        let availableProcesses = [];
        
        // Function to show autocomplete suggestions
        async function showAutocompleteSuggestions(filterTerm = '') {
            const value = dependenciesInput.value;
            const currentSheet = document.getElementById('process-target-sheet-modal')?.value || 'Manual';
            
            // Get current input and cursor position
            const cursorPos = dependenciesInput.selectionStart;
            const beforeCursor = value.substring(0, cursorPos);
            const afterCursor = value.substring(cursorPos);
            
            // Find the current term being typed
            const terms = beforeCursor.split(',');
            const currentTerm = filterTerm || terms[terms.length - 1].trim();
            
            // Get available processes if not cached
            if (availableProcesses.length === 0) {
                availableProcesses = await getAvailableProcesses(currentSheet);
            }
            
            // Filter processes based on current term (show all if no filter term)
            let matches;
            if (currentTerm.length === 0) {
                // Show all processes when no filter
                matches = availableProcesses.filter(proc => 
                    !beforeCursor.includes(proc) // Don't suggest already added processes
                );
            } else {
                // Filter based on current term
                matches = availableProcesses.filter(proc => 
                    proc.toLowerCase().includes(currentTerm.toLowerCase()) &&
                    !beforeCursor.includes(proc) // Don't suggest already added processes
                );
            }
            
            if (matches.length === 0) {
                autocompleteDiv.style.display = 'none';
                return;
            }
            
            // Sort matches alphabetically
            matches.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
            
            // Display suggestions
            autocompleteDiv.innerHTML = '';
            matches.slice(0, 15).forEach(proc => {
                const item = document.createElement('div');
                item.style.cssText = 'padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee;';
                item.textContent = proc;
                
                item.addEventListener('mouseenter', () => {
                    item.style.backgroundColor = '#f0f0f0';
                });
                
                item.addEventListener('mouseleave', () => {
                    item.style.backgroundColor = '';
                });
                
                item.addEventListener('click', () => {
                    // Replace the current term with the selected process
                    const beforeCurrentTerm = terms.slice(0, -1).join(', ');
                    const newValue = (beforeCurrentTerm ? beforeCurrentTerm + ', ' : '') + proc + afterCursor;
                    
                    dependenciesInput.value = newValue;
                    dependenciesInput.focus();
                    
                    // Position cursor after the inserted term
                    const newCursorPos = (beforeCurrentTerm ? beforeCurrentTerm.length + 2 : 0) + proc.length;
                    dependenciesInput.setSelectionRange(newCursorPos, newCursorPos);
                    
                    autocompleteDiv.style.display = 'none';
                });
                
                autocompleteDiv.appendChild(item);
            });
            
            autocompleteDiv.style.display = 'block';
        }
        
        // Show suggestions on focus/click
        dependenciesInput.addEventListener('focus', async function() {
            await showAutocompleteSuggestions();
        });
        
        dependenciesInput.addEventListener('click', async function() {
            await showAutocompleteSuggestions();
        });
        
        dependenciesInput.addEventListener('input', async function(e) {
            const value = e.target.value;
            
            // Get current input and cursor position
            const cursorPos = e.target.selectionStart;
            const beforeCursor = value.substring(0, cursorPos);
            
            // Find the current term being typed
            const terms = beforeCursor.split(',');
            const currentTerm = terms[terms.length - 1].trim();
            
            await showAutocompleteSuggestions(currentTerm);
        });
        
        // Hide autocomplete when clicking outside
        document.addEventListener('click', function(e) {
            if (!dependenciesInput.contains(e.target) && !autocompleteDiv.contains(e.target)) {
                autocompleteDiv.style.display = 'none';
            }
        });
        
        // Hide autocomplete on ESC key
        dependenciesInput.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                autocompleteDiv.style.display = 'none';
            }
        });
        
        // Reset available processes when sheet changes
        const sheetSelector = document.getElementById('process-target-sheet-modal');
        if (sheetSelector) {
            sheetSelector.addEventListener('change', function() {
                availableProcesses = []; // Reset cache
            });
        }
    }
    
    // Initialize autocomplete
    setupDependenciesAutocomplete();
    
    // === LOAD EXCEL INTERFACE REMOVED - USING SUPABASE NOW ===
    // This interface was replaced with Supabase integration


    menuButton.addEventListener('click', (e) => {
        e.stopPropagation();
        const isMenuOpen = menuContent.style.display === 'block';
        if (!isMenuOpen) { 
                    filterPanel.classList.remove('open');
        converterPanel.classList.remove('open');
        closeTutorialPanelSafely(); 
        colorsPanel.classList.remove('open');
        dependencyPanelContainer.classList.remove('visible');
        sheetMultiSelectDropdown.style.display = 'none';
        deleteViewConfigDropdown.style.display = 'none';
        simulationPanel.classList.remove('open');
            updateAllDependencyAndSimShortcutButtonsState();
        }
        menuContent.style.display = isMenuOpen ? 'none' : 'block';
    });

    sheetMultiSelectButton.addEventListener('click', (e) => {
        e.stopPropagation();
        const isDropdownOpen = sheetMultiSelectDropdown.style.display === 'block';
        if (!isDropdownOpen) { 
            filterPanel.classList.remove('open');
            converterPanel.classList.remove('open');
            closeTutorialPanelSafely(); 
            dependencyPanelContainer.classList.remove('visible');
            deleteViewConfigDropdown.style.display = 'none';
            simulationPanel.classList.remove('open');
        }
        sheetMultiSelectDropdown.style.display = isDropdownOpen ? 'none' : 'block';
    });

    sheetSelectAllCheckbox.addEventListener('change', async (e) => {
        const isChecked = e.target.checked;
        const checkboxes = sheetMultiSelectOptions.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(cb => cb.checked = isChecked);
        await handleSheetSelectionChange();
    });


    // toggleConverterPanelButton event listener usunięty - zastąpiony przez nowy Load Excel interface

	// Naprawiony kod dla tutorial panel
		toggleTutorialPanelButton.addEventListener('click', (e) => {
		e.stopPropagation(); // Zapobiega propagacji zdarzenia i zamknięciu panelu.
		
		// Natychmiastowe usunięcie inline style.right przed togglem klasy
		tutorialPanel.style.right = '';
		
		// Toggle klasy z krótkim opóźnieniem dla pewności
		setTimeout(() => {
			tutorialPanel.classList.toggle('open');
		}, 10);
		
		menuContent.style.display = 'none'; // Dodaję zamykanie menu
		filterPanel.classList.remove('open');
		converterPanel.classList.remove('open');
		dependencyPanelContainer.classList.remove('visible');
		sheetMultiSelectDropdown.style.display = 'none';
		deleteViewConfigDropdown.style.display = 'none';
		simulationPanel.classList.remove('open');
		colorsPanel.classList.remove('open');
		});
    closeTutorialPanelButton.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        // Natychmiastowe usunięcie inline style.right przed usunięciem klasy
        tutorialPanel.style.right = '';
        tutorialPanel.classList.remove('open');
    });


    toggleFilterPanelButton.addEventListener('click', () => {
        filterPanel.classList.toggle('open');
        converterPanel.classList.remove('open');
        closeTutorialPanelSafely(); 
        dependencyPanelContainer.classList.remove('visible');
        menuContent.style.display = 'none';
        sheetMultiSelectDropdown.style.display = 'none';
        deleteViewConfigDropdown.style.display = 'none';
        simulationPanel.classList.remove('open');
    });
    closeFilterPanelButton.addEventListener('click', () => filterPanel.classList.remove('open'));
    applyFiltersButton.addEventListener('click', applyGeneralFilters);
    closeConverterPanelButton.addEventListener('click', () => converterPanel.classList.remove('open'));
    convertButtonConverter.addEventListener('click', handleConvertXlsxToJson);
    convertAndLoadButtonConverter.addEventListener('click', handleConvertAndLoadXlsxToDiagram);
	
    saveProcessButton.addEventListener('click', saveProcess);
    cancelProcessButton.addEventListener('click', closeModal);
    deleteProcessButton.addEventListener('click', deleteCurrentProcess);

    saveViewConfigButton.addEventListener('click', saveCurrentViewConfiguration);
    loadViewConfigSelector.addEventListener('change', loadSelectedViewConfiguration);

    deleteViewConfigButton.addEventListener('click', (e) => {
        e.stopPropagation();
        const isDeleteDropdownOpen = deleteViewConfigDropdown.style.display === 'block';
        if (!isDeleteDropdownOpen) { 
            sheetMultiSelectDropdown.style.display = 'none';
            filterPanel.classList.remove('open');
            converterPanel.classList.remove('open');
            closeTutorialPanelSafely(); 
            dependencyPanelContainer.classList.remove('visible');
            simulationPanel.classList.remove('open');
            populateDeleteViewDropdown(); 
        }
        deleteViewConfigDropdown.style.display = isDeleteDropdownOpen ? 'none' : 'block';
    });

    toggleDependencyEditButton.addEventListener('click', () => {
        const currentStatus = dependencyEditingEnabled ? "Enabled" : "Disabled";
        const desiredAction = dependencyEditingEnabled ? "Disable" : "Enable";
        const confirmationMessage = `Dependency editing is currently ${currentStatus}. Do you want to ${desiredAction} it?`;

        if (confirm(confirmationMessage)) { 
            dependencyEditingEnabled = !dependencyEditingEnabled;
            updateDependencyEditButtonText();
            positionActionIcons(); 
            saveStateToLocalStorage();
            showNotification(`Dependency editing has been ${dependencyEditingEnabled ? "Enabled" : "Disabled"}.`, 'info');
        }
        menuContent.style.display = 'none';
        updateAllDependencyAndSimShortcutButtonsState();
    });


// Nowy kod
window.addEventListener('click', (event) => {
    // <<< START DODANEGO BLOKU >>>
    if (blockNextGlobalClick) {
        blockNextGlobalClick = false;
        return;
    }
    // <<< KONIEC DODANEGO BLOKU >>>
    if (isProgrammaticClick) return; // Zachowujemy to zabezpieczenie z v74
    // Usunięto automatyczne zamykanie modala - użytkownik musi kliknąć Cancel lub Save

    // Pobranie referencji do nowo dodanych elementów
    const deleteSimScenarioButton = document.getElementById('delete-simulation-scenario-button');
    const deleteSimScenarioDropdown = document.getElementById('delete-simulation-scenario-dropdown');
    const colorMenuButton = document.getElementById('color-controls-menu-button');
    const colorDropdown = document.getElementById('color-controls-dropdown');

    // Sprawdzenie, czy kliknięto poza wszystkimi interaktywnymi obszarami
    const clickedOutsideUI = (
        !menuButton.contains(event.target) && !menuContent.contains(event.target) &&
        !sheetMultiSelectButton.contains(event.target) && !sheetMultiSelectDropdown.contains(event.target) &&
        !deleteViewConfigButton.contains(event.target) && !deleteViewConfigDropdown.contains(event.target) &&
        (deleteSimScenarioButton ? !deleteSimScenarioButton.contains(event.target) : true) && (deleteSimScenarioDropdown ? !deleteSimScenarioDropdown.contains(event.target) : true) &&
        (colorMenuButton ? !colorMenuButton.contains(event.target) : true) && (colorDropdown ? !colorDropdown.contains(event.target) : true) &&
        !dependencyTypeMenu.contains(event.target) && event.target !== linkHandleTrigger &&
        !filterPanel.contains(event.target) && event.target !== toggleFilterPanelButton &&
        !converterPanel.contains(event.target) &&
        !tutorialPanel.contains(event.target) && !toggleTutorialPanelButton.contains(event.target) &&
        !colorsPanel.contains(event.target) && !closeColorsPanelButton.contains(event.target) &&
        !simulationPanel.contains(event.target) && event.target !== closeSimulationPanelButton && (document.getElementById('initiate-simulation-button') ? event.target !== document.getElementById('initiate-simulation-button') : true) && event.target !== shortcutSimulateImpactButton &&
        !dependencyPanelContainer.contains(event.target) && event.target !== menuDependencyPanelTrigger && !menuDependencyPanelTrigger.contains(event.target) && event.target !== closeDependencyPanelBtn && event.target !== shortcutShowDependenciesButton &&
        !modal.contains(event.target) &&
        !notificationBar.contains(event.target)
    );

    // Logika odznaczania węzła, jeśli kliknięto poza diagramem i UI
    if (clickedOutsideUI && !diagramContainer.contains(event.target) && !event.target.closest('.top-bar') && !event.target.closest('#process-details')) {
        if (currentlySelectedProcessId && !isTreeHighlightActive && !isSimulationModeActive) {
            clearSelectionHighlightsAndDimming();
            currentlySelectedProcessId = null;
            displayProcessDetails(null);
            hideActionIcons();
            updateAllDependencyAndSimShortcutButtonsState();
        } else if (isTreeHighlightActive) {
            isTreeHighlightActive = false;
            highlightedTreeNodesIds.clear();
            clearSelectionHighlightsAndDimming();
            currentlySelectedProcessId = null;
            displayProcessDetails(null);
            hideActionIcons();
            renderDiagramAndRestoreState();
            updateAllDependencyAndSimShortcutButtonsState();
        }
    }

    // Logika zamykania wszystkich paneli i menu, jeśli kliknięto poza nimi
    if (clickedOutsideUI) {
        menuContent.style.display = 'none';
        sheetMultiSelectDropdown.style.display = 'none';
        deleteViewConfigDropdown.style.display = 'none';
        if (deleteSimScenarioDropdown) deleteSimScenarioDropdown.style.display = 'none';
        if (colorDropdown) colorDropdown.style.display = 'none';
        dependencyTypeMenu.style.display = 'none';
        filterPanel.classList.remove('open');
        converterPanel.classList.remove('open');
        closeTutorialPanelSafely();
        colorsPanel.classList.remove('open');
        simulationPanel.classList.remove('open');
    }
});
    diagramContainer.addEventListener('wheel', (e) => { e.preventDefault(); zoom(e.deltaY > 0 ? 0.9 : 1.1, e); }, { passive: false });



    const throttledSaveScrollState = throttle(() => {
        if (Object.keys(processesData).length > 0 && getCurrentlyVisibleProcesses().length > 0) saveStateToLocalStorage();
    }, 250);
    const handleScrollAndResize = throttle(() => {
        updateTopBarHeight(); 
        if (typeof updateStickyAxesContainerPositions === 'function' && typeof updateStickyAxesLabels === 'function' && stickyAxisInitialized && Object.keys(processesData).length > 0 && getCurrentlyVisibleProcesses().length > 0) {
            requestAnimationFrame(() => {
                updateStickyAxesContainerPositions();
                updateStickyAxesLabels();
                updateMiniMapViewPort();
                positionActionIcons(); 
            });
        }
        throttledSaveScrollState();
    }, 16);

    diagramContainer.addEventListener('scroll', handleScrollAndResize);
    
    // Dodaj dodatkowy listener na scroll dla sticky axes (bezpośredni, bez throttling'u)
    diagramContainer.addEventListener('scroll', () => {
        if (stickyAxisInitialized && stickyYAxisContainer && stickyXAxisContainer) {
            requestAnimationFrame(() => {
                updateStickyAxesContainerPositions();
                updateStickyAxesLabels();
            });
        }
    });
    window.addEventListener('scroll', handleScrollAndResize);
    window.addEventListener('resize', () => {
        handleScrollAndResize();
        drawMiniMap();
        if(dependencyPanelContainer.classList.contains('visible')) {
             dependencyPanelContainer.style.right = '0';
        } else {
             dependencyPanelContainer.style.right = `-${dependencyPanelContainer.offsetWidth}px`;
        }
        if(simulationPanel.classList.contains('open')) { 
             simulationPanel.style.right = '0';
        } else {
             simulationPanel.style.right = `-${simulationPanel.offsetWidth}px`;
        }
        // Tutorial panel używa CSS transform zamiast manipulacji style.right
        // Nie manipulujemy style.right dla tutorial-panel
        if(tutorialPanel.classList.contains('open')) { 
             // Panel jest otwarty - pozwalamy CSS transform działać
        } else {
             // Panel jest zamknięty - czyszczenie inline styles
             tutorialPanel.style.right = '';
        }
        if(colorsPanel.classList.contains('open')) { 
             colorsPanel.style.right = '0';
        } else {
             colorsPanel.style.right = `-${colorsPanel.offsetWidth}px`;
        }
    });

    searchInput.addEventListener('input', (e) => {
        if (isSimulationModeActive) return; 
        applySearchHighlight(e.target.value);
    });

    togglePresentationModeButton.addEventListener('click', () => {
        if (isSimulationModeActive) endSimulation();
        document.body.classList.toggle('presentation-mode');
        updateTopBarHeight();
        menuContent.style.display = 'none';
        sheetMultiSelectDropdown.style.display = 'none';
        deleteViewConfigDropdown.style.display = 'none';

        if (document.body.classList.contains('presentation-mode')) { 
            hideActionIcons(); 
            toggleDependencyPanel(false); 
            toggleSimulationPanel(false); 
            closeTutorialPanelSafely(); 
            toggleColorsPanel(false);
            notificationBar.style.display = 'none'; 
        } else { 
            if (!dependencyPanelContainer.classList.contains('visible') &&
                (dependencyPanelContainer.style.right === '0px' || dependencyPanelContainer.style.right === '-0px')) {
                toggleDependencyPanel(false); 
            }
            if (!simulationPanel.classList.contains('open') &&
                (simulationPanel.style.right === '0px' || simulationPanel.style.right === '-0px')) {
                toggleSimulationPanel(false); 
            }
             positionActionIcons(); 
        }
        updateAllDependencyAndSimShortcutButtonsState();

        // Wymusz ponowne obliczenie layoutu przed aktualizacją osi
        diagramContainer.offsetHeight; // Trigger reflow
        
        // Dodaj opóźnienie dla lepszej synchronizacji po zmianie presentation mode
        requestAnimationFrame(() => {
            // Aktualizuj topBarHeight przed pozycjonowaniem osi
            updateTopBarHeight();
            
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
            drawMiniMap();
            updateMiniMapViewPort();
            
            // Dodatkowe wywołania z różnymi opóźnieniami dla pełnej synchronizacji
            setTimeout(() => {
                updateTopBarHeight();
                diagramContainer.offsetHeight; // Trigger reflow
                updateStickyAxesContainerPositions();
                updateStickyAxesLabels();
            }, 50);
            
            setTimeout(() => {
                updateTopBarHeight();
                diagramContainer.offsetHeight; // Trigger reflow
                updateStickyAxesContainerPositions();
                updateStickyAxesLabels();
            }, 150);
            
            setTimeout(() => {
                updateTopBarHeight();
                diagramContainer.offsetHeight; // Trigger reflow
                updateStickyAxesContainerPositions();
                updateStickyAxesLabels();
            }, 300);
            
            // Dodaj jednorazowy listener na resize dla przypadku przełączania presentation mode
            const handlePostPresentationResize = () => {
                updateStickyAxesContainerPositions();
                updateStickyAxesLabels();
                window.removeEventListener('resize', handlePostPresentationResize);
            };
            window.addEventListener('resize', handlePostPresentationResize);
            
            // Usuń listener po 2 sekundach jeśli nie został wywołany
            setTimeout(() => {
                window.removeEventListener('resize', handlePostPresentationResize);
            }, 2000);
            
            // Dodaj jednorazowy listener na scroll dla przypadku przełączania presentation mode
            const handlePostPresentationScroll = () => {
                updateStickyAxesContainerPositions();
                updateStickyAxesLabels();
                diagramContainer.removeEventListener('scroll', handlePostPresentationScroll);
            };
            diagramContainer.addEventListener('scroll', handlePostPresentationScroll);
            
            // Usuń scroll listener po 3 sekundach jeśli nie został wywołany
            setTimeout(() => {
                diagramContainer.removeEventListener('scroll', handlePostPresentationScroll);
            }, 3000);
            
            // Dodaj również bezpośrednie wywołanie bez throttling'u po dłuższym opóźnieniu
            setTimeout(() => {
                // Bezpośrednie wywołanie omijające warunki w handleScrollAndResize
                updateTopBarHeight();
                updateStickyAxesContainerPositions();
                updateStickyAxesLabels();
                updateMiniMapViewPort();
                positionActionIcons();
            }, 500);
            
            // Jeszcze jedno wywołanie po sekundzie dla pewności
            setTimeout(() => {
                updateTopBarHeight();
                updateStickyAxesContainerPositions();
                updateStickyAxesLabels();
            }, 1000);
            
            // Dodaj jednorazowy listener na pierwsze kliknięcie po wyjściu z presentation mode
            if (!document.body.classList.contains('presentation-mode')) {
                const handleFirstClickAfterPresentation = () => {
                    updateTopBarHeight();
                    updateStickyAxesContainerPositions();
                    updateStickyAxesLabels();
                    document.removeEventListener('click', handleFirstClickAfterPresentation);
                };
                document.addEventListener('click', handleFirstClickAfterPresentation);
                
                // Usuń listener po 5 sekundach jeśli nie został wywołany
                setTimeout(() => {
                    document.removeEventListener('click', handleFirstClickAfterPresentation);
                                 }, 5000);
             }
             
             // Symuluj resize event dla pełnej synchronizacji layout'u
             setTimeout(() => {
                 window.dispatchEvent(new Event('resize'));
             }, 200);
        });
        saveStateToLocalStorage();
    });




    menuDependencyPanelTrigger.addEventListener('click', (e) => {
        e.stopPropagation();
        if (isSimulationModeActive || menuDependencyPanelTrigger.disabled) return; 
        if (currentlySelectedProcessId) {
            generateAndShowDependencyTree(currentlySelectedProcessId);
            toggleDependencyPanel(true);
            filterPanel.classList.remove('open');
            converterPanel.classList.remove('open');
            closeTutorialPanelSafely(); 
            colorsPanel.classList.remove('open');
            menuContent.style.display = 'none';
            sheetMultiSelectDropdown.style.display = 'none';
            deleteViewConfigDropdown.style.display = 'none';
            simulationPanel.classList.remove('open');
        } else {
            showNotification("Please select a process node first to see its dependencies.", "info");
        }
    });
    closeDependencyPanelBtn.addEventListener('click', () => toggleDependencyPanel(false));
    highlightTreeNodesButton.addEventListener('click', highlightTreeNodesOnDiagram);

    linkHandleTrigger.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        if (isSimulationModeActive || !dependencyEditingEnabled) return;
        if (!currentlySelectedProcessId || !nodeLayouts[currentlySelectedProcessId]) return;
        isLinking = true;
        linkStartProcessId = currentlySelectedProcessId;
        const startProcess = getCurrentlyVisibleProcesses(true).find(p => p.ID === linkStartProcessId);
        linkStartProcessSheet = startProcess ? (startProcess._sourceSheet || (selectedSheetViews.length === 1 ? selectedSheetViews[0] : null)) : (selectedSheetViews.length === 1 ? selectedSheetViews[0] : null);
        linkHandleTrigger.style.cursor = 'grabbing';
        const startNodeLayout = nodeLayouts[linkStartProcessId];
        if (!startNodeLayout) { isLinking = false; return; }
        const startX = startNodeLayout.finalX + startNodeLayout.width / 2;
        const startY = startNodeLayout.finalY + startNodeLayout.height / 2;
        tempLinkLine = document.createElementNS(SVG_NS, 'line');
        tempLinkLine.setAttribute('class', 'temp-link-line');
		tempLinkLine.style.pointerEvents = 'none'; 
        tempLinkLine.setAttribute('x1', startX);
        tempLinkLine.setAttribute('y1', startY);
        tempLinkLine.setAttribute('x2', startX);
        tempLinkLine.setAttribute('y2', startY);
        svgLayer.appendChild(tempLinkLine);
        e.preventDefault();
    });

    diagramPane.addEventListener('click', async function(e) {
        if (isSimulationModeActive || !dependencyEditingEnabled) return; 
        if (e.target && e.target.classList.contains('unlink-handle')) {
            e.stopPropagation();
            const sourceId = e.target.dataset.sourceId;
            const targetRawDep = e.target.dataset.targetRawDep;
            const sourceSheet = e.target.dataset.sourceSheet;

            if (sourceId && targetRawDep && sourceSheet) {
                const sourceProcessData = processesData[sourceSheet]?.find(p => p.ID === sourceId);
                if (sourceProcessData && sourceProcessData.Dependencies) {
                    let depsArray = String(sourceProcessData.Dependencies).split(',').map(d => d.trim()).filter(d => d);
                    const indexToRemove = depsArray.indexOf(targetRawDep);
                    if (indexToRemove > -1) {
                        depsArray.splice(indexToRemove, 1);
                        sourceProcessData.Dependencies = depsArray.join(',');
                        
                        // Zapisz zmiany do Supabase
                        const updateSuccess = await updateProcessInSupabase(sourceProcessData, sourceSheet);
                        if (updateSuccess) {
                            showNotification(`Dependency removed successfully and synced to database.`, 'success');
                        } else {
                            showNotification(`Dependency removed locally but failed to sync to database. Please check your connection.`, 'warning');
                        }
                        
                        renderDiagramAndRestoreState();
                        if (dependencyPanelContainer.classList.contains('visible')) {
                            generateAndShowDependencyTree(sourceId);
                        }
                        saveStateToLocalStorage();
                    } else {
                         console.warn("Could not find raw dependency to unlink:", targetRawDep, "in", depsArray);
                    }
                }
            }
            positionActionIcons();
        }
    });


    diagramContainer.addEventListener('mousemove', (e) => {
        if (!isLinking || !tempLinkLine || isSimulationModeActive || !dependencyEditingEnabled) return;
        e.preventDefault();
        const dcRect = diagramContainer.getBoundingClientRect();
        const mouseSvgX = (e.clientX - dcRect.left + diagramContainer.scrollLeft) / currentZoom;
        const mouseSvgY = (e.clientY - dcRect.top + diagramContainer.scrollTop) / currentZoom;

        tempLinkLine.setAttribute('x2', mouseSvgX);
        tempLinkLine.setAttribute('y2', mouseSvgY);

        diagramPane.querySelectorAll('.process-node:not(.filtered-out-general):not(.filtered-out-axis):not(.search-dimmed):not(.tree-highlight-dimmed)').forEach(nodeEl => {
            const procId = nodeEl.dataset.id;
            if (procId === linkStartProcessId) return;
            const layout = nodeLayouts[procId];
            if (layout &&
                mouseSvgX >= layout.finalX && mouseSvgX <= layout.finalX + layout.width &&
                mouseSvgY >= layout.finalY && mouseSvgY <= layout.finalY + layout.height) {
                nodeEl.classList.add('link-target-hover');
            } else {
                nodeEl.classList.remove('link-target-hover');
            }
        });
    });

document.addEventListener('mouseup', (e) => {
    if (isPanning && e.target !== linkHandleTrigger && !e.target.classList.contains('unlink-handle')) {
        isPanning = false;
        diagramContainer.style.cursor = 'grab';
    }

    if (!isLinking || isSimulationModeActive || !dependencyEditingEnabled) {
        if (isLinking) { // Cleanup if linking was aborted
            isLinking = false;
            linkHandleTrigger.style.cursor = 'grab';
            if (tempLinkLine) { tempLinkLine.remove(); tempLinkLine = null; }
            diagramPane.querySelectorAll('.process-node.link-target-hover').forEach(el => el.classList.remove('link-target-hover'));
            linkStartProcessId = null; linkStartProcessSheet = null;
        }
        if (dependencyTypeMenu.style.display === 'block' && !dependencyTypeMenu.contains(e.target)) {
            dependencyTypeMenu.style.display = 'none';
        }
        return;
    }

    isLinking = false;
    linkHandleTrigger.style.cursor = 'grab';
    if (tempLinkLine) {
        tempLinkLine.remove();
        tempLinkLine = null;
    }
    diagramPane.querySelectorAll('.process-node.link-target-hover').forEach(el => el.classList.remove('link-target-hover'));
    
    lastMouseUpEvent = e; 

    let targetProcessNodeElement = null; 

    if (diagramContainer.contains(e.target) || e.target === diagramContainer || diagramPane.contains(e.target)) {
        const dcRect = diagramContainer.getBoundingClientRect();
        const mouseSvgX = (e.clientX - dcRect.left + diagramContainer.scrollLeft) / currentZoom;
        const mouseSvgY = (e.clientY - dcRect.top + diagramContainer.scrollTop) / currentZoom;

        const visibleProcesses = getCurrentlyVisibleProcesses(true);
        for (const procLayout of Object.values(nodeLayouts)) {
            const nodeEl = procLayout.node;
            if (nodeEl && procLayout.process.ID !== linkStartProcessId &&
                !nodeEl.classList.contains('filtered-out-general') &&
                !nodeEl.classList.contains('filtered-out-axis') &&
                !nodeEl.classList.contains('search-dimmed') &&
                !nodeEl.classList.contains('tree-highlight-dimmed') &&
                mouseSvgX >= procLayout.finalX && mouseSvgX <= procLayout.finalX + procLayout.width &&
                mouseSvgY >= procLayout.finalY && mouseSvgY <= procLayout.finalY + procLayout.height)
            {
                pendingLinkTargetId = procLayout.process.ID;
                pendingLinkTargetProcess = visibleProcesses.find(p => p.ID === pendingLinkTargetId);
                targetProcessNodeElement = nodeEl; 
                break;
            }
        }
    }


    if (pendingLinkTargetProcess && linkStartProcessId && linkStartProcessSheet) {
        pendingLinkSourceId = linkStartProcessId;
        pendingLinkSourceSheet = linkStartProcessSheet;
        
        const sourceProcDataForCheck = processesData[pendingLinkSourceSheet]?.find(p => p.ID === pendingLinkSourceId);
        if (sourceProcDataForCheck && sourceProcDataForCheck.Dependencies) {
            const depsArray = String(sourceProcDataForCheck.Dependencies).split(',').map(d => d.trim()).filter(d => d);
            const existingDepToBaseId = depsArray.some(depStr => parseDependencyEntry(depStr).id === pendingLinkTargetId);
            if (existingDepToBaseId) {
                showNotification(`A dependency to process ${pendingLinkTargetProcess["Short name"]} (ID: ${pendingLinkTargetId}) already exists. You can edit its type in the modal or remove and re-add it.`, 'warning');
                resetPendingLink();
                return;
            }
        }
        
		blockNextGlobalClick = true;
        showDependencyTypeMenu(e.clientX, e.clientY);
    } else {
        resetPendingLink();
    }
    
    linkStartProcessId = null; 
    linkStartProcessSheet = null;
});

    toggleMiniMapButton.addEventListener('click', () => {
        const isCurrentlyHidden = miniMapWrapper.style.display === 'none' || miniMapWrapper.style.display === '';
        if (isCurrentlyHidden) {
            miniMapWrapper.style.display = 'block';
            drawMiniMap();
            updateMiniMapViewPort();
        } else {
            miniMapWrapper.style.display = 'none';
            miniMapSvg.innerHTML = '';
        }
        saveStateToLocalStorage();
    });

    // Dodaj obsługę kliknięć na Mini Map dla nawigacji
    miniMapSvg.addEventListener('click', (e) => {
        if (miniMapWrapper.style.display === 'none' || !overallDiagramBounds) return;
        
        e.stopPropagation();
        
        // Pobierz pozycję kliknięcia względem SVG
        const svgRect = miniMapSvg.getBoundingClientRect();
        const clickX = e.clientX - svgRect.left;
        const clickY = e.clientY - svgRect.top;
        
        // Przelicz pozycję kliknięcia na współrzędne diagramu
        const miniMapWidth = svgRect.width;
        const miniMapHeight = svgRect.height;
        
        const diagramWidth = overallDiagramBounds.maxX - overallDiagramBounds.minX;
        const diagramHeight = overallDiagramBounds.maxY - overallDiagramBounds.minY;
        
        // Współrzędne w układzie diagramu
        const targetDiagramX = overallDiagramBounds.minX + (clickX / miniMapWidth) * diagramWidth;
        const targetDiagramY = overallDiagramBounds.minY + (clickY / miniMapHeight) * diagramHeight;
        
        // Przelicz na scroll position
        const dcRect = diagramContainer.getBoundingClientRect();
        const targetScrollLeft = (targetDiagramX * currentZoom) - (dcRect.width / 2);
        const targetScrollTop = (targetDiagramY * currentZoom) - (dcRect.height / 2);
        
        // Animacja przewijania
        diagramContainer.scrollTo({
            left: Math.max(0, targetScrollLeft),
            top: Math.max(0, targetScrollTop),
            behavior: 'smooth'
        });
        
        // Aktualizuj Mini Map viewport po przewinięciu
        setTimeout(() => {
            updateMiniMapViewPort();
        }, 200);
    });

    closeSimulationPanelButton.addEventListener('click', () => {
        if (isSimulationModeActive) {
            if (confirm("This will end the current simulation. Are you sure?")) { 
                endSimulation();
            }
        } else {
            toggleSimulationPanel(false);
        }
    });

    if (shortcutShowDependenciesButton) {
        shortcutShowDependenciesButton.addEventListener('click', () => {
            console.log('🔍 Show Dependencies button clicked');
            console.log('Button disabled:', shortcutShowDependenciesButton.disabled);
            console.log('Selected process ID:', currentlySelectedProcessId);
            
            // Enhanced debugging for diagnosing the issue
            console.log('🔍 Debug info:');
            console.log('- processesData keys:', Object.keys(processesData));
            console.log('- processesData length:', Object.values(processesData).flat().length);
            console.log('- dependencyTreeSvg element:', !!dependencyTreeSvg);
            console.log('- dependencyPanelTitle element:', !!dependencyPanelTitle);
            
            if (shortcutShowDependenciesButton.disabled) {
                console.log('❌ Button is disabled, returning');
                return;
            }
            if (currentlySelectedProcessId) {
                console.log('✅ Generating dependency tree for:', currentlySelectedProcessId);
                try {
                    // Additional validation before calling the function
                    const currentProcesses = getCurrentlyVisibleProcesses(true);
                    console.log('📊 Currently visible processes:', currentProcesses.length);
                    const targetProcess = currentProcesses.find(p => p.ID === currentlySelectedProcessId);
                    console.log('🎯 Target process found:', !!targetProcess, targetProcess ? targetProcess["Short name"] : 'NOT FOUND');
                    
                    generateAndShowDependencyTree(currentlySelectedProcessId);
                    toggleDependencyPanel(true);
                    filterPanel.classList.remove('open');
                    converterPanel.classList.remove('open');
                    closeTutorialPanelSafely();
                    colorsPanel.classList.remove('open');
                    menuContent.style.display = 'none';
                    sheetMultiSelectDropdown.style.display = 'none';
                    deleteViewConfigDropdown.style.display = 'none';
                    simulationPanel.classList.remove('open');
                    console.log('✅ Dependency tree generated successfully');
                } catch (error) {
                    console.error('💥 Error generating dependency tree:', error);
                    console.error('Stack trace:', error.stack);
                    showNotification("Error generating dependency tree: " + error.message, "error");
                }
            } else {
                console.log('❌ No process selected');
                showNotification("Please select a process node first to see its dependencies.", "info");
            }
        });
    }

    if (shortcutSimulateImpactButton) {
        shortcutSimulateImpactButton.addEventListener('click', () => {
            if (shortcutSimulateImpactButton.disabled) return;
            openSimulationPanelForSelectedProcess();
        });
    }


    function showNotification(message, type = 'info', duration = 7000) {
        if (notificationTimeout) clearTimeout(notificationTimeout);
        
        const cleanMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        notificationMessageSpan.innerHTML = cleanMessage.replace(/\n/g, "<br>");

        // Set data-type attribute for proper dark mode styling
        notificationBar.setAttribute('data-type', type);

        // Update close button text color based on notification type
        const closeButton = document.getElementById('notification-close');
        
        switch (type) {
            case 'error':
                notificationBar.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)';
                notificationBar.style.color = 'white';
                notificationBar.style.borderColor = 'rgba(255, 107, 107, 0.3)';
                if (closeButton) closeButton.style.color = 'white';
                break;
            case 'warning':
                notificationBar.style.background = 'linear-gradient(135deg, #ffc107 0%, #ffb300 100%)'; 
                notificationBar.style.color = '#2c3e50';
                notificationBar.style.borderColor = 'rgba(255, 193, 7, 0.3)';
                if (closeButton) closeButton.style.color = '#2c3e50';
                break;
            case 'success':
                notificationBar.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)'; 
                notificationBar.style.color = 'white';
                notificationBar.style.borderColor = 'rgba(40, 167, 69, 0.3)';
                if (closeButton) closeButton.style.color = 'white';
                break;
            default: 
                notificationBar.style.background = 'linear-gradient(135deg, #007bff 0%, #0056b3 100%)';
                notificationBar.style.color = 'white';
                notificationBar.style.borderColor = 'rgba(0, 123, 255, 0.3)';
                if (closeButton) closeButton.style.color = 'white';
        }

        notificationBar.style.display = 'block';
        updateTopBarHeight(); 

        if (duration > 0) {
            notificationTimeout = setTimeout(() => {
                notificationBar.style.animation = 'notificationSlideOut 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                setTimeout(() => {
                    notificationBar.style.display = 'none';
                    notificationBar.style.animation = '';
                    notificationBar.removeAttribute('data-type');
                }, 300);
            }, duration);
        }
    }


    function showDependencyTypeMenu(x, y) {
        dependencyTypeMenu.style.left = `${x}px`;
        dependencyTypeMenu.style.top = `${y}px`;
        dependencyTypeMenu.style.display = 'block';

        dependencyTypeMenu.querySelectorAll('.context-menu-item').forEach(item => {
            item.replaceWith(item.cloneNode(true)); 
        });
        
        dependencyTypeMenu.querySelectorAll('.context-menu-item').forEach(item => {
            item.addEventListener('click', handleDependencyTypeSelection);
        });
    }

    async function handleDependencyTypeSelection(event) {
        event.stopPropagation();
        const selectedType = event.target.dataset.type;
        dependencyTypeMenu.style.display = 'none';

        if (pendingLinkSourceId && pendingLinkTargetId && pendingLinkSourceSheet) {
            const sourceProcData = processesData[pendingLinkSourceSheet]?.find(p => p.ID === pendingLinkSourceId);
            if (sourceProcData) {
                let depsArray = sourceProcData.Dependencies ? String(sourceProcData.Dependencies).split(',').map(d => d.trim()).filter(d => d) : [];
                
                let newDependencyEntry = pendingLinkTargetId;
                if (selectedType === 'blocking') {
                    newDependencyEntry += '_B';
                } else if (selectedType === 'informational') {
                    newDependencyEntry += '_I';
                }

                if (!depsArray.includes(newDependencyEntry)) {
                    depsArray.push(newDependencyEntry);
                    sourceProcData.Dependencies = depsArray.join(',');
                    
                    // Zapisz zmiany do Supabase
                    const updateSuccess = await updateProcessInSupabase(sourceProcData, pendingLinkSourceSheet);
                    if (updateSuccess) {
                        showNotification(`Dependency to ${pendingLinkTargetProcess["Short name"]} added successfully and synced to database.`, 'success');
                    } else {
                        showNotification(`Dependency added locally but failed to sync to database. Please check your connection.`, 'warning');
                    }
                    
                    renderDiagramAndRestoreState(); 
                    
                    if (dependencyPanelContainer.classList.contains('visible') && currentDependencyTreeRootProcess && currentDependencyTreeRootProcess.ID === pendingLinkSourceId) {
                        generateAndShowDependencyTree(pendingLinkSourceId);
                    }
                    saveStateToLocalStorage();
                } else {
                    showNotification(`Dependency to ${pendingLinkTargetProcess["Short name"]} with type '${selectedType}' already exists.`, 'warning');
                }
            } else {
                console.warn("Source process data not found for pending link:", pendingLinkSourceId, pendingLinkSourceSheet);
            }
        } else {
            console.warn("Missing data for creating dependency link.");
        }
        resetPendingLink();
    }

    function resetPendingLink() {
        pendingLinkSourceId = null;
        pendingLinkSourceSheet = null;
        pendingLinkTargetId = null;
        pendingLinkTargetProcess = null;
        lastMouseUpEvent = null;
    }

    // Helper funkcja do bezpiecznego zamykania tutorial panel
    function closeTutorialPanelSafely() {
        // console.log('Closing tutorial panel safely');
        tutorialPanel.style.right = '';
        tutorialPanel.classList.remove('open');
    }

function updateTopBarHeight() {
    const topBarEl = document.querySelector('.top-bar');
    if (topBarEl) {
        topBarHeight = topBarEl.offsetHeight;
        const panelTopPosition = topBarHeight + 10; 
        const panelHeightCalc = `calc(100vh - ${topBarHeight + 20}px)`; 

        if (miniMapWrapper.style.display === 'block') {
            miniMapWrapper.style.top = (topBarHeight + 15) + 'px';
        }
        if (document.body.classList.contains('presentation-mode')) {
            diagramContainer.style.paddingTop = topBarHeight + 'px';
        } else {
            diagramContainer.style.paddingTop = '0px';
        }
        
        dependencyPanelContainer.style.top = panelTopPosition + 'px';
        dependencyPanelContainer.style.height = panelHeightCalc;

        [filterPanel, converterPanel, simulationPanel, tutorialPanel, colorsPanel].forEach(panelEl => {
            if (panelEl) {
                panelEl.style.top = panelTopPosition + 'px';
                panelEl.style.height = panelHeightCalc;
            }
        });
    }
}

    // MODYFIKACJA START: Zaktualizowana funkcja createNodeElement
    // MODYFIKACJA START: Zaktualizowana funkcja createNodeElement
    // Add process status visualization
    function addProcessStatusVisualization(node, processData) {
        const status = processData.status || 'PENDING';
        
        // Remove existing status elements
        const existingStatusElements = node.querySelectorAll('.status-indicator, .status-icon');
        existingStatusElements.forEach(el => el.remove());
        
        // Create status indicator
        const statusIndicator = document.createElement('div');
        statusIndicator.className = 'status-indicator';
        
        // Create status icon
        const statusIcon = document.createElement('div');
        statusIcon.className = 'status-icon';
        
        // Apply status-specific styling
        switch (status) {
            case 'COMPLETED_ON_TIME':
                statusIndicator.className += ' status-completed-on-time';
                statusIcon.innerHTML = '✓';
                statusIcon.className += ' status-icon-completed';
                node.style.boxShadow = '0 0 15px rgba(57, 255, 20, 0.5)';
                break;
                
            case 'COMPLETED_LATE':
                statusIndicator.className += ' status-completed-late';
                statusIcon.innerHTML = '✓';
                statusIcon.className += ' status-icon-completed-late';
                node.style.boxShadow = '0 0 15px rgba(255, 190, 11, 0.5)';
                break;
                
            case 'OVERDUE':
                statusIndicator.className += ' status-overdue';
                statusIcon.innerHTML = '⚠';
                statusIcon.className += ' status-icon-overdue';
                node.style.boxShadow = '0 0 15px rgba(255, 0, 110, 0.5)';
                node.style.animation = 'pulse-red 2s infinite';
                break;
                
            case 'DELAYED_WITH_REASON':
                statusIndicator.className += ' status-delayed';
                statusIcon.innerHTML = '⏱';
                statusIcon.className += ' status-icon-delayed';
                node.style.boxShadow = '0 0 15px rgba(255, 190, 11, 0.4)';
                break;
                
            case 'PENDING':
            default:
                statusIndicator.className += ' status-pending';
                statusIcon.innerHTML = '○';
                statusIcon.className += ' status-icon-pending';
                break;
        }
        
        // Add completion note tooltip if available
        if (processData.completion_note) {
            statusIcon.title = `Status: ${status.replace('_', ' ')}\nNote: ${processData.completion_note}`;
        } else {
            statusIcon.title = `Status: ${status.replace('_', ' ')}`;
        }
        
        // Add assigned user info if available
        if (processData.assigned_to_email) {
            statusIcon.title += `\nAssigned to: ${processData.assigned_to_email}`;
        }
        
        // Add due date info if available
        if (processData.due_date) {
            statusIcon.title += `\nDue date: ${processData.due_date}`;
        }
        
        // Add status elements to node
        node.appendChild(statusIndicator);
        node.appendChild(statusIcon);
        
        // Status icon is now only for visualization - no click handler needed
    }
    
    function createNodeElement(processData, layout) { 
        const node = document.createElement('div');
        node.className = 'process-node';
        node.textContent = processData["Short name"];

        let tooltipTitle = `${processData["Short name"]} (WD: ${processData.WD}, Due: ${processData["Due time"]})`;
        const description = processData.Description;

        if (description && String(description).trim() !== '') {
            const formattedDescription = String(description).replace(/\\n/g, '\n');
            tooltipTitle += `\n${formattedDescription}`;
        }

        node.title = tooltipTitle;

        node.dataset.id = processData.ID;
        node.dataset.sourceSheet = processData._sourceSheet || 'N/A';

        const processType = (processData["Process Type"] || "standard").toLowerCase();
        let baseColorForNode = configColors.node; 

        // Logika przypisywania klas i kolorów
        if (processType === "blocking") {
            baseColorForNode = configColors.blockingNode || '#ffcc80'; 
            const symbolSpan = document.createElement('span');
            symbolSpan.className = 'node-type-symbol';
            symbolSpan.textContent = 'B';
            symbolSpan.style.color = configColors.nodeSymbolColor || '#333';
            node.appendChild(symbolSpan);
        } else if (processType === "informational") {
            baseColorForNode = configColors.informationalNode || '#b3e5fc'; 
            const symbolSpan = document.createElement('span');
            symbolSpan.className = 'node-type-symbol';
            symbolSpan.textContent = 'I';
            symbolSpan.style.color = configColors.nodeSymbolColor || '#333';
            node.appendChild(symbolSpan);
        } else if (processType === "standard-blocking") {
            baseColorForNode = configColors.node; // Tło jak standard (niebieski)
            node.classList.add('standard-blocking'); // Dodajemy klasę dla specjalnego stylu obramowania (przerywaną ramka)
            const symbolSpan = document.createElement('span');
            symbolSpan.className = 'node-type-symbol';
            symbolSpan.innerHTML = 'S/B'; // Używamy symbolu S/B
            symbolSpan.style.color = configColors.nodeSymbolColor || '#333';
            node.appendChild(symbolSpan);
        }
        // Dla "standard" nie robimy nic specjalnego, bo to domyślny wygląd

        node.style.backgroundColor = baseColorForNode;
        // W przypadku standard-blocking, używamy specjalnego obramowania w kolorze blocking
        if (processType === 'standard-blocking') {
            const blockingColor = configColors.blockingNode || '#ffcc80';
            node.style.borderColor = shadeColor(blockingColor, -0.3); // Obramowanie w kolorze blocking
        } else {
            node.style.borderColor = shadeColor(baseColorForNode, -0.3);
        }

        node.style.width = `${layout.width || NODE_BASE_WIDTH}px`; 
        node.style.height = `${layout.height || NODE_HEIGHT}px`; 
        
        // Add status visualization
        addProcessStatusVisualization(node, processData);
        
        return node;
    }
    // MODYFIKACJA KONIEC
    // MODYFIKACJA KONIEC
    function drawMiniMap() {
        if (miniMapWrapper.style.display === 'none') {
            miniMapSvg.innerHTML = '';
            return;
        }
        miniMapSvg.innerHTML = '';
        const currentProcesses = getCurrentlyVisibleProcesses(true); 
        const allProcsData = isSimulationModeActive ? getAllProcessesFromData() : currentProcesses; 
        
        if (allProcsData.length === 0 || overallDiagramBounds.maxX - overallDiagramBounds.minX <= 0) {
             if(welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
            return;
        }
        if(welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';


        const viewBoxWidth = Math.max(1, overallDiagramBounds.maxX - overallDiagramBounds.minX);
        const viewBoxHeight = Math.max(1, overallDiagramBounds.maxY - overallDiagramBounds.minY);
        miniMapSvg.setAttribute('viewBox', `${overallDiagramBounds.minX} ${overallDiagramBounds.minY} ${viewBoxWidth} ${viewBoxHeight}`);
        
        // MODYFIKACJA START: Użycie simulationTargets do identyfikacji głównych celów
        const simulationTargetIds = new Set(isSimulationModeActive ? simulationTargets.map(t => t.id) : []);
        // MODYFIKACJA KONIEC

        allProcsData.forEach(proc => {
            const layout = nodeLayouts[proc.ID]; 
            if (!layout && !(isSimulationModeActive && simulationTargetIds.has(proc.ID))) { 
                 return;
            }

            const nodeEl = diagramPane.querySelector(`.process-node[data-id="${proc.ID}"]`);

            if (!isSimulationModeActive) { 
                if (!nodeEl || nodeEl.classList.contains('filtered-out-general') || nodeEl.classList.contains('filtered-out-axis') || nodeEl.classList.contains('tree-highlight-dimmed') || nodeEl.classList.contains('search-dimmed')) {
                    return;
                }
            } else { 
                if (nodeEl && nodeEl.classList.contains('simulation-dimmed-others')) {
                    return;
                }
            }

            const rect = document.createElementNS(SVG_NS, 'rect');
            let rectX, rectY, rectWidth, rectHeight;

            const isSimulatedNode = isSimulationModeActive && simulationTargetIds.has(proc.ID);
            const isShiftedOrAdded = isSimulatedNode && nodeEl && (nodeEl.classList.contains('simulation-shifted') || nodeEl.classList.contains('simulation-new-node'));

            if (isShiftedOrAdded) {
                const nodeRect = nodeEl.getBoundingClientRect();
                const diagramRect = diagramContainer.getBoundingClientRect();
                rectX = (nodeRect.left - diagramRect.left + diagramContainer.scrollLeft) / currentZoom;
                rectY = (nodeRect.top - diagramRect.top + diagramContainer.scrollTop) / currentZoom;
                rectWidth = nodeEl.offsetWidth / currentZoom;
                rectHeight = nodeEl.offsetHeight / currentZoom;
            } else if (layout) {
                rectX = layout.finalX;
                rectY = layout.finalY;
                rectWidth = layout.width;
                rectHeight = layout.height;
            } else {
                return; 
            }

            rect.setAttribute('x', rectX);
            rect.setAttribute('y', rectY);
            rect.setAttribute('width', rectWidth);
            rect.setAttribute('height', rectHeight);
            rect.classList.add('mini-map-node');

            if (isSimulationModeActive) {
                if (isSimulatedNode) {
                    rect.style.fill = 'gold'; // Główny cel symulacji
                    rect.style.stroke = 'black';
                    rect.style.strokeWidth = "1.5px";
                } else if (nodeEl && (nodeEl.classList.contains('simulation-input-conflict') || nodeEl.classList.contains('simulation-output-at-risk'))) {
                    rect.style.fill = '#dc3545'; // Konflikt lub Ryzyko (czerwony)
                } else if (nodeEl && nodeEl.classList.contains('simulation-affected-dependent')) {
                    rect.style.fill = '#ffc107'; // Inny wpływ (żółty/pomarańczowy)
                } else {
                     rect.style.fill = (proc._sheetColorIndex !== undefined) ? sheetColors[proc._sheetColorIndex % sheetColors.length] : configColors.node;
                     rect.style.opacity = 0.5;
                }
            } else {
                if (proc && proc._sheetColorIndex !== undefined && allDataSourceSheetNames.length > 1) {
                    rect.style.fill = sheetColors[proc._sheetColorIndex % sheetColors.length];
                } else {
                    rect.style.fill = configColors.node;
                }
                if(proc.ID === currentlySelectedProcessId){
                    rect.style.stroke = configColors.lightning;
                    rect.style.strokeWidth = "3px";
                }
            }
            miniMapSvg.appendChild(rect);
        });

        if (miniMapViewportRect && miniMapViewportRect.parentNode) {
            miniMapViewportRect.parentNode.removeChild(miniMapViewportRect);
        }
        miniMapViewportRect = document.createElementNS(SVG_NS, 'rect');
        miniMapViewportRect.setAttribute('id', 'mini-map-viewport-rect');
        miniMapSvg.appendChild(miniMapViewportRect);
    }

    function updateMiniMapViewPort() {
        if (miniMapWrapper.style.display === 'none') {
            return;
        }
        if (!miniMapViewportRect || getCurrentlyVisibleProcesses().length === 0 && !isSimulationModeActive || overallDiagramBounds.maxX - overallDiagramBounds.minX <= 0) {
            if (miniMapViewportRect) {
                miniMapViewportRect.setAttribute('width', '0');
                miniMapViewportRect.setAttribute('height', '0');
            }
            return;
        }

        const diagramVisibleWidth = diagramContainer.clientWidth / currentZoom;
        const diagramVisibleHeight = diagramContainer.clientHeight / currentZoom;
        const diagramScrollLeft = diagramContainer.scrollLeft / currentZoom;
        const diagramScrollTop = diagramContainer.scrollTop / currentZoom;

        miniMapViewportRect.setAttribute('x', diagramScrollLeft);
        miniMapViewportRect.setAttribute('y', diagramScrollTop);
        miniMapViewportRect.setAttribute('width', Math.max(0, diagramVisibleWidth));
        miniMapViewportRect.setAttribute('height', Math.max(0, diagramVisibleHeight));
    }

function clearSelectionHighlightsAndDimming() {
    if (isSimulationModeActive) return;
    svgLayer.innerHTML = '';
    simulationGhostLayer.innerHTML = '';
    const currentProcsForClear = getAllProcessesFromData(); 

    diagramPane.querySelectorAll('.process-node').forEach(node => {
        const procId = node.dataset.id;
        const nodeSheet = node.dataset.sourceSheet; 
        const procData = currentProcsForClear.find(p => p.ID === procId && p._sourceSheet === nodeSheet);

        node.classList.remove('selected', 'dependent-input', 'dependent-output', 'dimmed-selection');

        if (isTreeHighlightActive && node.classList.contains('tree-highlight-dimmed') && procId !== currentlySelectedProcessId) {
            node.classList.remove('can-hover'); 
            return; 
        }
        if ((!node.classList.contains('filtered-out-general') &&
            !node.classList.contains('filtered-out-axis') &&
            !node.classList.contains('search-dimmed')) ||
            node.classList.contains('search-highlight'))
        {
            if (!node.classList.contains('search-highlight')) {
                // --- POCZĄTEK ZMIENIONEGO BLOKU ---
                let colorToRestore = configColors.node;
                let borderToRestore = shadeColor(colorToRestore, -0.3);
                let boxShadowToRestore = '1px 1px 3px rgba(0,0,0,0.1)';

                if (procData) {
                    const processType = (procData["Process Type"] || "standard").toLowerCase();
                    node.classList.remove('standard-blocking'); // Zawsze resetujemy na początku

                    if (processType === "blocking") {
                        colorToRestore = configColors.blockingNode;
                        borderToRestore = shadeColor(colorToRestore, -0.3);
                    } else if (processType === "informational") {
                        colorToRestore = configColors.informationalNode;
                        borderToRestore = shadeColor(colorToRestore, -0.3);
                    } else if (processType === "standard-blocking") {
                        node.classList.add('standard-blocking'); // Ponownie dodajemy klasę
                        colorToRestore = configColors.node; // Tło jak standard (niebieski)
                        const blockingColor = configColors.blockingNode || '#ffcc80';
                        borderToRestore = shadeColor(blockingColor, -0.3); // Obramowanie w kolorze blocking
                        boxShadowToRestore = `0 0 6px ${blockingColor}`; // Cień w kolorze blocking
                    }
                }
                node.style.backgroundColor = colorToRestore;
                node.style.borderColor = borderToRestore;
                node.style.boxShadow = boxShadowToRestore;
                 // --- KONIEC ZMIENIONEGO BLOKU ---
            } else {
                node.style.borderColor = '#ff8c00'; 
            }

            node.style.opacity = 1;
            node.classList.add('can-hover');
        } else {
            node.classList.remove('can-hover');
        }
    });
    hideActionIcons(); 
    updateAllDependencyAndSimShortcutButtonsState();
}


    function resetVisualStates() {
        if (isSimulationModeActive) return; 
        clearSelectionHighlightsAndDimming();
        currentlySelectedProcessId = null;
        displayProcessDetails(null); 
        hideActionIcons();
        updateAllDependencyAndSimShortcutButtonsState();
    }

function fullReset() {
    if (isSimulationModeActive) endSimulation();
    temporaryActiveFilters = {};
    currentAppliedFilters = {};
    currentAxisFilter = { type: null, value: null, valueEnd: null };
    isTreeHighlightActive = false;
    highlightedTreeNodesIds.clear();


    if (allDataSourceSheetNames.length > 0) {
        selectedSheetViews = [...allDataSourceSheetNames];
    } else {
        selectedSheetViews = [];
    }
    updateSheetMultiSelectDropdown();

    if (filterOptionsContainer) {
        filterOptionsContainer.querySelectorAll('select, input[type="time"]').forEach(input => {
            if (input.tagName === 'SELECT' && input.multiple) {
                Array.from(input.options).forEach(option => option.selected = false);
            } else {
                input.value = "";
            }
        });
    }
    searchInput.value = '';

    resetVisualStates();
    updateAddProcessButtonState();

    renderDiagram(); 

    refreshDiagramStyles();

    requestAnimationFrame(() => {
        updateTopBarHeight();
        if (stickyYAxisContainer) stickyYAxisContainer.innerHTML = '';
        if (stickyXAxisContainer) stickyXAxisContainer.innerHTML = '';
        updateStickyAxesContainerPositions();
        updateStickyAxesLabels();
        drawMiniMap(); updateMiniMapViewPort();
        positionActionIcons();
    });
    updateAllDependencyAndSimShortcutButtonsState();
}


    function handleProcessNodeClick(processId) {
        if (isSimulationModeActive) {
             const clickedNodeEl = diagramPane.querySelector(`.process-node[data-id="${processId}"]`);
             if (clickedNodeEl && (clickedNodeEl.classList.contains('simulation-affected-dependent') || clickedNodeEl.classList.contains('simulation-input-conflict') || clickedNodeEl.classList.contains('simulation-output-at-risk'))) {
                 showNotification(`Clicked impacted node: ${processId}.`, 'info', 3000);
             }
            return;
        }

        if (isTreeHighlightActive) {
            if (highlightedTreeNodesIds.has(processId)) {
                if (currentlySelectedProcessId === processId) {
                    clearSelectionHighlightsAndDimming(); 
                    currentlySelectedProcessId = null;
                    displayProcessDetails(null);
                    hideActionIcons(); 
                    refreshDiagramStyles(); 
                } else {
                    selectProcess(processId, true); 
                }
            } else { 
                isTreeHighlightActive = false;
                highlightedTreeNodesIds.clear();
                selectProcess(processId, true); 
            }
        } else { 
            if (currentlySelectedProcessId === processId) { 
                clearSelectionHighlightsAndDimming();
                currentlySelectedProcessId = null; 
                displayProcessDetails(null);
                hideActionIcons();
                toggleDependencyPanel(false); 
            } else { 
                selectProcess(processId, true); 
                if (dependencyPanelContainer.classList.contains('visible')) {
                    generateAndShowDependencyTree(processId);
                }
            }
        }
        updateAllDependencyAndSimShortcutButtonsState();
    }
    
    function updateAllDependencyAndSimShortcutButtonsState() {
        const isProcessSelected = !!currentlySelectedProcessId;
        const enableActionOnSelectedProcess = isProcessSelected && !isSimulationModeActive && !dependencyEditingEnabled;

        if (shortcutShowDependenciesButton) {
            shortcutShowDependenciesButton.disabled = !enableActionOnSelectedProcess;
        }
        if (shortcutSimulateImpactButton) {
            shortcutSimulateImpactButton.disabled = !enableActionOnSelectedProcess;
        }

        if (menuDependencyPanelTrigger) {
            menuDependencyPanelTrigger.disabled = !enableActionOnSelectedProcess;
            if (menuDependencyPanelTrigger.disabled) {
                menuDependencyPanelTrigger.classList.add('disabled');
            } else {
                menuDependencyPanelTrigger.classList.remove('disabled');
            }
        }
    }


    function positionActionIcons() {
        if (linkHandleTrigger) linkHandleTrigger.style.display = 'none';
        diagramPane.querySelectorAll('.unlink-handle').forEach(handle => handle.remove());

        if (document.body.classList.contains('presentation-mode') || isSimulationModeActive) return;
        if (!currentlySelectedProcessId) return; 

        const sourceLayout = nodeLayouts[currentlySelectedProcessId];
        if (!sourceLayout) return; 
        
        const sourceNodeEl = sourceLayout.node;
        if (!sourceNodeEl || sourceNodeEl.classList.contains('filtered-out-general') || sourceNodeEl.classList.contains('filtered-out-axis') || sourceNodeEl.classList.contains('search-dimmed') || (isTreeHighlightActive && sourceNodeEl.classList.contains('tree-highlight-dimmed'))) {
            return;
        }

        if (dependencyEditingEnabled) { 
            const iconSizeScale = 1 / currentZoom;
            const linkHandleSize = 14;

            if (linkHandleTrigger) {
                linkHandleTrigger.style.left = `${sourceLayout.finalX + sourceLayout.width - (linkHandleSize * iconSizeScale / 2)}px`;
                linkHandleTrigger.style.top = `${sourceLayout.finalY + sourceLayout.height / 2 - (linkHandleSize * iconSizeScale / 2)}px`;
                linkHandleTrigger.style.transform = `scale(${iconSizeScale})`;
                linkHandleTrigger.style.display = 'flex';
            }

            const selectedProcessData = getCurrentlyVisibleProcesses(true).find(p => p.ID === currentlySelectedProcessId);
            if (selectedProcessData && selectedProcessData.Dependencies && String(selectedProcessData.Dependencies).trim() !== '') {
                const dependentRawEntries = String(selectedProcessData.Dependencies).split(',').map(entry => entry.trim()).filter(entry => entry);
                dependentRawEntries.forEach(rawDepEntry => {
                    const { id: depId } = parseDependencyEntry(rawDepEntry);
                    if (depId === currentlySelectedProcessId) return;

                    const dependentLayout = nodeLayouts[depId];
                    const dependentNodeEl = dependentLayout ? dependentLayout.node : null;

                    if (dependentLayout && dependentNodeEl &&
                        !dependentNodeEl.classList.contains('filtered-out-general') &&
                        !dependentNodeEl.classList.contains('filtered-out-axis') &&
                        !dependentNodeEl.classList.contains('search-dimmed') &&
                        !(isTreeHighlightActive && !highlightedTreeNodesIds.has(depId)) ) {

                        const unlinkHandle = document.createElement('div');
                        unlinkHandle.className = 'unlink-handle';
                        unlinkHandle.textContent = '–';
                        unlinkHandle.title = `Remove dependency to ${dependentLayout.process["Short name"] || depId}`;
                        unlinkHandle.dataset.sourceId = currentlySelectedProcessId;
                        unlinkHandle.dataset.targetRawDep = rawDepEntry;
                        unlinkHandle.dataset.sourceSheet = selectedProcessData._sourceSheet || (selectedSheetViews.length === 1 ? selectedSheetViews[0] : null);

                        unlinkHandle.style.left = `${dependentLayout.finalX + dependentLayout.width - (linkHandleSize * iconSizeScale / 2) - 2}px`;
                        unlinkHandle.style.top = `${dependentLayout.finalY - (linkHandleSize * iconSizeScale / 2) + 2}px`;
                        unlinkHandle.style.transform = `scale(${iconSizeScale})`;
                        unlinkHandle.style.display = 'flex';
                        diagramPane.appendChild(unlinkHandle);
                    }
                });
            }
        }
    }

    function hideActionIcons() {
        if(linkHandleTrigger) linkHandleTrigger.style.display = 'none';
        diagramPane.querySelectorAll('.unlink-handle').forEach(handle => handle.remove());
    }


    function toggleDependencyPanel(show) {
        if (show) {
            if (isSimulationModeActive) endSimulation();
            dependencyPanelContainer.style.display = 'flex';
            dependencyPanelContainer.classList.add('visible');
            requestAnimationFrame(() => {
                dependencyPanelContainer.style.right = '0';
            });
        } else {
            dependencyPanelContainer.classList.remove('visible');
            requestAnimationFrame(() => {
                // MODYFIKACJA: Użyj `offsetWidth` zamiast stałej wartości, aby animacja działała z dynamiczną szerokością.
                const panelWidth = dependencyPanelContainer.offsetWidth || 500;
                dependencyPanelContainer.style.right = `-${panelWidth}px`;
                setTimeout(() => {
                    if (!dependencyPanelContainer.classList.contains('visible')) {
                        dependencyPanelContainer.style.display = 'none';
                    }
                }, 350);
            });
        }
    }

    function toggleSimulationPanel(show) {
        if (show) {
            if (isTreeHighlightActive) { 
                 isTreeHighlightActive = false;
                 highlightedTreeNodesIds.clear();
                 renderDiagramAndRestoreState(); 
            }
            simulationPanel.classList.add('open');
            simulationPanel.style.right = '0';
        } else {
            simulationPanel.classList.remove('open');
            simulationPanel.style.right = `-${simulationPanel.offsetWidth}px`;
        }
    }


    function highlightTreeNodesOnDiagram() {
        console.log('🌟 Highlight Tree Nodes button clicked');
        if (isSimulationModeActive) endSimulation();

        const treeNodesElements = dependencyTreeSvg.querySelectorAll('.dep-tree-node');
        console.log('📊 Tree nodes found:', treeNodesElements.length);
        
        if (treeNodesElements.length === 0) {
            console.log('❌ No tree nodes found, clearing highlights');
            isTreeHighlightActive = false;
            highlightedTreeNodesIds.clear();
            renderDiagramAndRestoreState(); 
            toggleDependencyPanel(false);
            return;
        }

        const newHighlightedTreeIds = new Set();
        treeNodesElements.forEach(g => {
            // Use original ID for functionality, not sanitized ID
            if (g.dataset.originalId) {
                newHighlightedTreeIds.add(g.dataset.originalId);
                console.log('➕ Added to highlight set:', g.dataset.originalId);
            }
        });

        console.log('🎯 Total nodes to highlight:', newHighlightedTreeIds.size);
        console.log('📋 Node IDs:', Array.from(newHighlightedTreeIds));

        if (newHighlightedTreeIds.size === 0) {
            console.log('❌ No valid nodes to highlight');
            isTreeHighlightActive = false;
            highlightedTreeNodesIds.clear();
            renderDiagramAndRestoreState();
            toggleDependencyPanel(false);
            return;
        }

        console.log('✅ Activating tree highlight mode');
        isTreeHighlightActive = true;
        highlightedTreeNodesIds = newHighlightedTreeIds;

        if (currentlySelectedProcessId && !highlightedTreeNodesIds.has(currentlySelectedProcessId)) {
            currentlySelectedProcessId = null; 
            displayProcessDetails(null);
        }

        currentAppliedFilters = {};
        temporaryActiveFilters = {};
        currentAxisFilter = { type: null, value: null, valueEnd: null };
        if (searchInput) searchInput.value = '';

        if (filterOptionsContainer) {
            filterOptionsContainer.querySelectorAll('select, input[type="time"]').forEach(input => {
                if (input.tagName === 'SELECT' && input.multiple) {
                    Array.from(input.options).forEach(option => option.selected = false);
                } else {
                    input.value = "";
                }
            });
        }
        updateStickyAxesLabels();
        console.log('🔄 Rendering diagram with highlights...');
        renderDiagramAndRestoreState(); 
        console.log('🔒 Closing dependency panel...');
        toggleDependencyPanel(false);
        saveStateToLocalStorage();
        console.log('✅ Tree highlight completed');
    }

    function drawAllTreeDependencies() {
        if (!isTreeHighlightActive || highlightedTreeNodesIds.size === 0) {
            return;
        }
        const currentVisibleProcesses = getCurrentlyVisibleProcesses(true); 
        let arrowsDrawnCount = 0;

        highlightedTreeNodesIds.forEach(sourceId => {
            const sourceProcess = currentVisibleProcesses.find(p => p.ID === sourceId);
            const sourceNodeEl = diagramPane.querySelector(`.process-node[data-id="${sourceId}"]:not(.tree-highlight-dimmed)`);

            if (!sourceProcess || !sourceNodeEl) return; 

            const outputRawEntries = (sourceProcess.Dependencies ? String(sourceProcess.Dependencies) : '').split(',').map(id => id.trim()).filter(id => id);

            outputRawEntries.forEach(rawDepEntry => {
                const { id: targetId, type: depLinkType } = parseDependencyEntry(rawDepEntry);

                if (highlightedTreeNodesIds.has(targetId) && targetId !== sourceId) {
                    const targetNodeEl = diagramPane.querySelector(`.process-node[data-id="${targetId}"]:not(.tree-highlight-dimmed)`); 
                    const targetProcess = currentVisibleProcesses.find(p => p.ID === targetId); 

                    if (!targetProcess || !targetNodeEl) return;

                    let arrowColor = configColors.outputArrow;
                    if (depLinkType === 'blocking') arrowColor = configColors.outputArrowBlocking;
                    else if (depLinkType === 'informational') arrowColor = configColors.outputArrowInformational;
                    
                    drawArrow(sourceNodeEl, targetNodeEl, arrowColor, 'output-arrow tree-arrow', depLinkType);
                    arrowsDrawnCount++;
                }
            });
        });
    }

    function highlightDependenciesWithinTree(selectedProcess, allowedNodeIds) {
        if (!isTreeHighlightActive) return;
    }

    function highlightTreePath(event, doHighlight) {
        dependencyTreeSvg.querySelectorAll('.dep-tree-node.path-highlight, .dep-tree-link.path-highlight')
            .forEach(el => el.classList.remove('path-highlight'));

        if (!doHighlight || !event || !event.currentTarget) return;

        const targetNodeElement = event.currentTarget;
        let targetNodeId = targetNodeElement.dataset.id;

        const pathNodeIds = new Set();
        let currentNodeId = targetNodeId;

        while (currentNodeId) {
            pathNodeIds.add(currentNodeId);
            const nodeInfo = dependencyTreeNodeMap.get(currentNodeId); 

            if (nodeInfo && nodeInfo.parentId) {
                const parentId = nodeInfo.parentId;
                // SANITIZE: Use the same replacement to find the valid class names
                const sanitizedParentId = parentId.replace(/[^a-zA-Z0-9_-]/g, '_');
                const sanitizedCurrentNodeId = currentNodeId.replace(/[^a-zA-Z0-9_-]/g, '_');
                const linkForward = dependencyTreeSvg.querySelector(`.link-from-${sanitizedParentId}-to-${sanitizedCurrentNodeId}`);
                const linkBackward = dependencyTreeSvg.querySelector(`.link-from-${sanitizedCurrentNodeId}-to-${sanitizedParentId}`); 
                if(linkForward) linkForward.classList.add('path-highlight');
                if(linkBackward) linkBackward.classList.add('path-highlight');
                currentNodeId = parentId;
            } else {
                currentNodeId = null;
            }
        }

        pathNodeIds.forEach(id => {
            // SANITIZE: Use the same replacement to find the valid data-id
            const sanitizedId = id.replace(/[^a-zA-Z0-9_-]/g, '_');
            const nodeEl = dependencyTreeSvg.querySelector(`.dep-tree-node[data-id="${sanitizedId}"]`);
            if (nodeEl) nodeEl.classList.add('path-highlight');
        });
    }


    function drawDependencyTreeSVG(rootProcessData, inputsData, outputsData) {
        dependencyTreeSvg.innerHTML = '';
        dependencyTreeNodeMap.clear(); 

        const nodeWidth = 120; 
        const nodeHeight = 30;
        const horizontalGap = 70;
        const verticalGap = 20;
        const padding = 20;
        const toggleRadius = 5;

        let nodesToDraw = [];
        let linksToDraw = [];

        nodesToDraw.push({
            id: rootProcessData.ID,
            name: rootProcessData["Short name"],
            level: 0,
            isRoot: true,
            _sourceData: rootProcessData 
        });

        function layoutTree(dataArray, parentNodeData, isInputBranch) {
            if (!dataArray || dataArray.length === 0) return;

            dataArray.forEach(childData => {
                nodesToDraw.push({
                    id: childData.id,
                    name: childData.name,
                    level: childData.level,
                    notInView: childData.notInView,
                    isCollapsed: childData.isCollapsed,
                    hasChildren: childData.hasChildren,
                    parentId: parentNodeData.id, 
                    _sourceData: childData 
                });
                linksToDraw.push({
                    sourceId: isInputBranch ? childData.id : parentNodeData.id,
                    targetId: isInputBranch ? parentNodeData.id : childData.id,
                    sourceLevel: isInputBranch ? childData.level : parentNodeData.level,
                    targetLevel: isInputBranch ? parentNodeData.level : childData.level,
                });
                if (childData.children && childData.children.length > 0 && !childData.isCollapsed) {
                    layoutTree(childData.children, childData, isInputBranch); 
                }
            });
        }

        layoutTree(inputsData, rootProcessData, true);
        layoutTree(outputsData, rootProcessData, false);

        const rootNodeInDrawList = nodesToDraw.find(n => n.isRoot);
        if(rootNodeInDrawList) rootNodeInDrawList.parentId = null;


        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        const nodesByLevel = {};

        nodesToDraw.forEach(n => {
            if (!nodesByLevel[n.level]) nodesByLevel[n.level] = [];
            nodesByLevel[n.level].push(n);
            n.x = n.level * (nodeWidth + horizontalGap);
            minX = Math.min(minX, n.x);
            maxX = Math.max(maxX, n.x + nodeWidth);
        });

        let totalCalculatedHeight = padding;
        const levelHeights = {};
        const sortedLevels = Object.keys(nodesByLevel).map(Number).sort((a, b) => a - b);

        sortedLevels.forEach(level => {
            levelHeights[level] = nodesByLevel[level].length * (nodeHeight + verticalGap) - verticalGap;
            totalCalculatedHeight += levelHeights[level] + (nodesByLevel[level].length > 0 ? verticalGap : 0) ;
        });
        totalCalculatedHeight = Math.max(totalCalculatedHeight - verticalGap, padding + nodeHeight + padding);


        let currentY = padding;
        sortedLevels.forEach(level => {
            const nodesOnLevel = nodesByLevel[level];
            if (nodesOnLevel.length === 0) return;

            const levelHeight = levelHeights[level];
            const startYForLevel = currentY;
            nodesOnLevel.forEach((node, index) => {
                node.y = startYForLevel + index * (nodeHeight + verticalGap);
            });
            currentY += levelHeight + verticalGap;
        });

        minX = Infinity; maxX = -Infinity;
        nodesToDraw.forEach(n => {
            const panelContentWidth = dependencyTreeContent.clientWidth > 0 ? dependencyTreeContent.clientWidth : 400;
            const rootBaseX = panelContentWidth / 2 - nodeWidth / 2;
            n.x = rootBaseX + n.level * (nodeWidth + horizontalGap);

            minX = Math.min(minX, n.x);
            maxX = Math.max(maxX, n.x + nodeWidth);
            minY = Math.min(minY, n.y);
            maxY = Math.max(maxY, n.y + nodeHeight);
        });

        const graphWidth = maxX - minX;
        const panelWidth = dependencyTreeContent.clientWidth || 400;
        const finalSvgWidth = Math.max(panelWidth, graphWidth + 2 * padding);
        const finalSvgHeight = Math.max(dependencyTreeContent.clientHeight || 300, maxY + padding);


        const xOffset = (finalSvgWidth - graphWidth) / 2 - minX;

        nodesToDraw.forEach(node => {
            node.x += xOffset;
            dependencyTreeNodeMap.set(node.id, node);
        });


        dependencyTreeSvg.setAttribute('width', finalSvgWidth);
        dependencyTreeSvg.setAttribute('height', finalSvgHeight);


        let defs = dependencyTreeSvg.querySelector('defs');
        if (!defs) {
            defs = document.createElementNS(SVG_NS, 'defs');
            dependencyTreeSvg.insertBefore(defs, dependencyTreeSvg.firstChild);
        }
        if (!defs.querySelector('#dep-arrowhead')) {
            const marker = document.createElementNS(SVG_NS, 'marker');
            marker.setAttribute('id', 'dep-arrowhead');
            marker.setAttribute('viewBox', '0 -5 10 10'); marker.setAttribute('refX', '8');
            marker.setAttribute('refY', '0'); marker.setAttribute('markerWidth', '6');
            marker.setAttribute('markerHeight', '6'); marker.setAttribute('orient', 'auto');
            const path = document.createElementNS(SVG_NS, 'path');
            path.setAttribute('d', 'M0,-5L10,0L0,5'); path.style.fill = '#888';
            marker.appendChild(path); defs.appendChild(marker);
        }

        linksToDraw.forEach(link => {
            const sourceNode = nodesToDraw.find(n => n.id === link.sourceId && n.level === link.sourceLevel);
            const targetNode = nodesToDraw.find(n => n.id === link.targetId && n.level === link.targetLevel);

            if (sourceNode && targetNode) {
                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', sourceNode.x + nodeWidth / 2);
                line.setAttribute('y1', sourceNode.y + nodeHeight / 2);
                line.setAttribute('x2', targetNode.x + nodeWidth / 2);
                line.setAttribute('y2', targetNode.y + nodeHeight / 2);
                line.classList.add('dep-tree-link');
                // SANITIZE: Replace invalid characters in IDs to create valid CSS class names
                const sanitizedSourceId = sourceNode.id.replace(/[^a-zA-Z0-9_-]/g, '_');
                const sanitizedTargetId = targetNode.id.replace(/[^a-zA-Z0-9_-]/g, '_');
                line.classList.add(`link-from-${sanitizedSourceId}-to-${sanitizedTargetId}`);
                line.setAttribute('marker-end', 'url(#dep-arrowhead)');
                dependencyTreeSvg.appendChild(line);
            }
        });

        const currentDiagramProcesses = getCurrentlyVisibleProcesses(false);
        const diagramProcessIds = new Set(currentDiagramProcesses.map(p => p.ID));

        nodesToDraw.forEach(node => {
            const group = document.createElementNS(SVG_NS, 'g');
            group.setAttribute('class', 'dep-tree-node');
            // SANITIZE: Replace invalid characters in ID for data-id attribute
            const sanitizedId = node.id.replace(/[^a-zA-Z0-9_-]/g, '_');
            group.dataset.id = sanitizedId;
            group.dataset.originalId = node.id; // Store original ID for functionality
            group.setAttribute('transform', `translate(${node.x}, ${node.y})`);


            if (node.isRoot) group.classList.add('selected-root');
            if (node.notInView) group.classList.add('not-in-view');

            if (diagramProcessIds.has(node.id) && !node.notInView) {
                group.classList.add('clickable');
                group.addEventListener('click', () => {
                    if (isSimulationModeActive) return;

                    // Step 1: Force select the process by setting the global variable.
                    currentlySelectedProcessId = node.id;

                    // Step 2: Handle cases where tree highlighting might be active
                    if (isTreeHighlightActive && !highlightedTreeNodesIds.has(node.id)) {
                        isTreeHighlightActive = false;
                        highlightedTreeNodesIds.clear();
                    }

                    // Step 3: Explicitly call functions to update the UI
                    const proc = getCurrentlyVisibleProcesses(true).find(p => p.ID === node.id);
                    if (proc) {
                        displayProcessDetails(proc);
                    }
                    refreshDiagramStyles(); // This applies highlights, dimming, and arrows.
                    updateAllDependencyAndSimShortcutButtonsState();
                    
                    // Step 4: Scroll the main diagram to the selected node (existing logic)
                    const mainNodeLayout = nodeLayouts[node.id];
                    if (mainNodeLayout) {
                        const targetX = (mainNodeLayout.finalX + mainNodeLayout.width / 2) * currentZoom - diagramContainer.clientWidth / 2;
                        const targetY = (mainNodeLayout.finalY + mainNodeLayout.height / 2) * currentZoom - diagramContainer.clientHeight / 2;
                        diagramContainer.scrollTo({ left: Math.max(0, targetX), top: Math.max(0, targetY), behavior: 'smooth' });
                    }

                    // Step 5: Save the new state
                    saveStateToLocalStorage();
                });
            }
            group.addEventListener('mouseover', (e) => highlightTreePath(e, true));
            group.addEventListener('mouseout', (e) => highlightTreePath(e, false));


            const rect = document.createElementNS(SVG_NS, 'rect');
            rect.setAttribute('x', 0); rect.setAttribute('y', 0);
            rect.setAttribute('width', nodeWidth); rect.setAttribute('height', nodeHeight);
            
            // === OBSŁUGA KOLORÓW DLA RÓŻNYCH TYPÓW PROCESÓW ===
            if (node._sourceData) {
                const processType = (node._sourceData["Process Type"] || "standard").toLowerCase();
                if (processType === "blocking") {
                    rect.style.fill = configColors.blockingNode || '#ffcc80';
                    rect.style.stroke = shadeColor(configColors.blockingNode || '#ffcc80', -0.3);
                } else if (processType === "informational") {
                    rect.style.fill = configColors.informationalNode || '#b3e5fc';
                    rect.style.stroke = shadeColor(configColors.informationalNode || '#b3e5fc', -0.3);
                } else if (processType === "standard-blocking") {
                    // Standard-blocking: tło jak standard, obramowanie jak blocking
                    rect.style.fill = configColors.node || '#aedff7';
                    rect.style.stroke = shadeColor(configColors.blockingNode || '#ffcc80', -0.3);
                    rect.style.strokeDasharray = '4,2'; // Przerywaną obramowanie
                }
            }

            const text = document.createElementNS(SVG_NS, 'text');
            text.setAttribute('x', nodeWidth / 2);
            text.setAttribute('y', nodeHeight / 2);

            let displayName = node.name || `ID: ${node.id}`;
            const depthIndicator = ` (L${Math.abs(node.level)})`;
            displayName += depthIndicator;

            const approxCharWidth = 5;
            const maxChars = Math.floor((nodeWidth - (node.hasChildren ? 25 : 10)) / approxCharWidth);
            if (displayName.length > maxChars) {
                 displayName = displayName.substring(0, maxChars - 3) + "..." + depthIndicator;
            }
            text.textContent = displayName;
            if(node.notInView) text.textContent += " (NV)";

            group.appendChild(rect);
            group.appendChild(text);

            if (node.hasChildren) {
                const toggleText = document.createElementNS(SVG_NS, 'text');
                toggleText.setAttribute('class', 'toggle-text');
                toggleText.textContent = node.isCollapsed ? '[+]' : '[-]';
                toggleText.setAttribute('x', 5);
                toggleText.setAttribute('y', nodeHeight / 2);
                toggleText.style.dominantBaseline = "middle";

                toggleText.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (node._sourceData) {
                        node._sourceData.isCollapsed = !node._sourceData.isCollapsed;
                        drawDependencyTreeSVG(currentDependencyTreeRootProcess, currentTreeInputsData, currentTreeOutputsData);
                    }
                });
                group.appendChild(toggleText);
            }
            dependencyTreeSvg.appendChild(group);
        });
    }


    updateTopBarHeight();

    function updateButtonStylesForDarkMode(isDarkModeActive) {
        const filtersButton = document.getElementById('toggle-filter-panel-button');
        const miniMapButton = document.getElementById('toggle-mini-map-button');
        const loadJsonLabel = document.getElementById('json-file-input-label');

        if (isDarkModeActive) {
            if (filtersButton) { 
                filtersButton.style.setProperty('background-color', '#333', 'important'); 
                filtersButton.style.setProperty('color', '#e0e0e0', 'important'); 
                filtersButton.style.setProperty('border', '1px solid #555', 'important'); 
            }
            if (miniMapButton) { 
                miniMapButton.style.setProperty('background-color', '#333', 'important'); 
                miniMapButton.style.setProperty('color', '#e0e0e0', 'important'); 
                miniMapButton.style.setProperty('border', '1px solid #555', 'important'); 
            }
            if (loadJsonLabel) { 
                loadJsonLabel.style.setProperty('background-color', '#555', 'important'); 
                loadJsonLabel.style.setProperty('color', '#e0e0e0', 'important'); 
                loadJsonLabel.style.setProperty('border', '1px solid #777', 'important'); 
            }
        } else {
            if (filtersButton) { filtersButton.style.backgroundColor = ''; filtersButton.style.color = ''; filtersButton.style.border = ''; }
            if (miniMapButton) { miniMapButton.style.backgroundColor = ''; miniMapButton.style.color = ''; miniMapButton.style.border = ''; }
            if (loadJsonLabel) { loadJsonLabel.style.backgroundColor = ''; loadJsonLabel.style.color = ''; loadJsonLabel.style.border = ''; }
        }
    }
    
    const stateLoaded = loadStateFromLocalStorage();
    if (!stateLoaded) {
        updateSheetMultiSelectDropdown();
        if (Object.keys(processesData).length === 0) {
            displayProcessDetails(null); 
            if(filterOptionsContainer) filterOptionsContainer.innerHTML = '<p>Load data to see filter options.</p>';
            if (stickyYAxisContainer) stickyYAxisContainer.innerHTML = '';
            if (stickyXAxisContainer) stickyXAxisContainer.innerHTML = '';
            miniMapSvg.innerHTML = '';
            miniMapWrapper.style.display = 'none';
            if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
        }
        toggleColorsPanel(false);
        dependencyEditingEnabled = false; 
        updateDependencyEditButtonText();
    } else {
         if (Object.keys(processesData).length === 0 || getCurrentlyVisibleProcesses().length === 0) {
            if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
        } else {
            if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';
        }
    }
    initializeColorPickers();
    populateViewConfigSelector();
    initSimulationPanelUI();
    displayProcessDetails(null); 
    updateAllDependencyAndSimShortcutButtonsState();

    function updateDependencyEditButtonText() {
        if (dependencyEditingEnabled) {
            toggleDependencyEditButton.textContent = 'Disable Dependency Editing';
            toggleDependencyEditButton.title = 'Currently Enabled: Click to disable manual dependency editing.';
        } else {
            toggleDependencyEditButton.textContent = 'Enable Dependency Editing';
            toggleDependencyEditButton.title = 'Currently Disabled: Click to enable manual dependency editing.';
        }
    }

// Supabase Functions - replacing localStorage functionality
async function loadDataFromSupabase() {
    try {
        if (!currentSheetId) {
            showNotification("No sheet specified. Please access through project manager.", 'warning');
            return false;
        }

        showNotification("Loading data from database...", 'info');
        
        const { data, error } = await supabaseClient
            .from('processes')
            .select('*')
            .eq('sheet_id', currentSheetId)
            .order('working_day', { ascending: true });
        
        // Debug available if needed: console.log('Raw data from Supabase:', data);

        if (error) {
            console.error('Supabase error:', error);
            showNotification("Error loading data from database: " + error.message, 'error');
            return false;
        }

        // Convert Supabase data to the application's format
        const newProcessesData = {};
        const sheetName = currentSheetData ? currentSheetData.name : 'Current Sheet';
        
        newProcessesData[sheetName] = [];

        data.forEach(row => {
            // Convert database row to application format
            const process = {
                ID: row.short_name, // Using short_name as ID for compatibility
                "Short name": row.short_name,
                Description: row.description || '',
                WD: row.working_day,
                "Working day": row.working_day, // Alternative field name
                "Due time": row.due_time || '',
                Dependencies: row.dependencies || '',
                "Process Type": row.process_type || 'standard',
                "Process type": row.process_type || 'standard', // Alternative field name
                _databaseId: row.id, // Store database ID for updates
                _customData: row.custom_data || {}, // Store custom fields data
                // Add status-related fields for proper synchronization
                status: row.status || 'PENDING',
                completed_at: row.completed_at,
                completion_note: row.completion_note,
                assigned_to: row.assigned_to,
                due_date: row.due_date
            };

            // Add custom fields to process object
            if (row.custom_data && typeof row.custom_data === 'object') {
                Object.keys(row.custom_data).forEach(key => {
                    process[key] = row.custom_data[key];
                });
            }

            newProcessesData[sheetName].push(process);
        });

        // Update application state
        processesData = newProcessesData;
        allDataSourceSheetNames = [sheetName];
        selectedSheetViews = [sheetName];
        
        // Log successful data loading
        const processCount = Object.values(processesData).flat().length;
        console.log(`✅ Loaded ${processCount} processes from database`);

        // Update UI
        updateSheetMultiSelectDropdown();
        updateAddProcessButtonState();
        updateGlobalUniqueDueTimeHours();
        populateFilterPanel();
        renderDiagram();
        resetVisualStates();

        requestAnimationFrame(() => {
            updateTopBarHeight();
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
            drawMiniMap();
            updateMiniMapViewPort();
            positionActionIcons();
        });

        if (welcomeMessageOverlay) {
            welcomeMessageOverlay.style.display = 'none';
        }

        showNotification(`Successfully loaded ${data.length} processes from database.`, 'success');
        return true;

    } catch (error) {
        console.error('Error loading from Supabase:', error);
        showNotification("Error loading data from database.", 'error');
        return false;
    }
}

// Function to get available processes for autocomplete
async function getAvailableProcesses(sheetName = 'Current Sheet') {
    try {
        if (!currentSheetId) {
            return [];
        }

        const { data, error } = await supabaseClient
            .from('processes')
            .select('short_name')
            .eq('sheet_id', currentSheetId)
            .order('short_name');

        if (error) {
            console.error('Error fetching available processes:', error);
            return [];
        }

        return data.map(row => row.short_name);
    } catch (error) {
        console.error('Error in getAvailableProcesses:', error);
        return [];
    }
}

async function saveProcessToSupabase(processData, sheetName) {
    try {
        if (!currentSheetId) {
            showNotification("No sheet context available.", 'error');
            return false;
        }

        // Prepare custom data
        const customData = {};
        const excludeFields = ["Short name", "ID", "Description", "WD", "Working day", "Due time", "Dependencies", "Process Type", "Process type", "_databaseId", "_customData", "_sourceSheet", "status", "completed_at", "completion_note", "assigned_to", "due_date"];
        
        Object.keys(processData).forEach(key => {
            if (!excludeFields.includes(key)) {
                customData[key] = processData[key];
            }
        });

        const { data, error } = await supabaseClient
            .from('processes')
            .insert([{
                short_name: processData["Short name"] || processData.ID,
                description: processData.Description || '',
                working_day: processData.WD || parseInt(processData["Working day"]) || 1,
                due_time: processData["Due time"] || null,
                dependencies: processData.Dependencies || '',
                process_type: processData["Process Type"] || processData["Process type"] || 'standard',
                sheet_id: currentSheetId,
                custom_data: Object.keys(customData).length > 0 ? customData : null,
                status: processData.status || 'PENDING',
                completed_at: processData.completed_at || null,
                completion_note: processData.completion_note || null,
                assigned_to: processData.assigned_to || null,
                due_date: processData.due_date || null
            }])
            .select();

        if (error) {
            console.error('Supabase save error:', error);
            showNotification("Error saving process to database: " + error.message, 'error');
            return false;
        }

        return true;
    } catch (error) {
        console.error('Error saving to Supabase:', error);
        showNotification("Error saving process to database.", 'error');
        return false;
    }
}

async function updateProcessInSupabase(processData, sheetName, originalShortName = null) {
    try {
        if (!currentSheetId) {
            showNotification("No sheet context available.", 'error');
            return false;
        }

        // Prepare custom data
        const customData = {};
        const excludeFields = ["Short name", "ID", "Description", "WD", "Working day", "Due time", "Dependencies", "Process Type", "Process type", "_databaseId", "_customData", "_sourceSheet", "status", "completed_at", "completion_note", "assigned_to", "due_date"];
        
        Object.keys(processData).forEach(key => {
            if (!excludeFields.includes(key)) {
                customData[key] = processData[key];
            }
        });

        // Use database ID if available, otherwise use short_name
        let query = supabaseClient.from('processes');
        
        if (processData._databaseId) {
            query = query.update({
                short_name: processData["Short name"] || processData.ID,
                description: processData.Description || '',
                working_day: processData.WD || parseInt(processData["Working day"]) || 1,
                due_time: processData["Due time"] || null,
                dependencies: processData.Dependencies || '',
                process_type: processData["Process Type"] || processData["Process type"] || 'standard',
                custom_data: Object.keys(customData).length > 0 ? customData : null,
                status: processData.status || 'PENDING',
                completed_at: processData.completed_at || null,
                completion_note: processData.completion_note || null,
                assigned_to: processData.assigned_to || null,
                due_date: processData.due_date || null,
                updated_at: new Date().toISOString()
            })
            .eq('id', processData._databaseId);
        } else {
            const shortNameToUpdate = originalShortName || processData["Short name"] || processData.ID;
            query = query.update({
                short_name: processData["Short name"] || processData.ID,
                description: processData.Description || '',
                working_day: processData.WD || parseInt(processData["Working day"]) || 1,
                due_time: processData["Due time"] || null,
                dependencies: processData.Dependencies || '',
                process_type: processData["Process Type"] || processData["Process type"] || 'standard',
                custom_data: Object.keys(customData).length > 0 ? customData : null,
                status: processData.status || 'PENDING',
                completed_at: processData.completed_at || null,
                completion_note: processData.completion_note || null,
                assigned_to: processData.assigned_to || null,
                due_date: processData.due_date || null,
                updated_at: new Date().toISOString()
            })
            .eq('short_name', shortNameToUpdate)
            .eq('sheet_id', currentSheetId);
        }

        const { data, error } = await query.select();

        if (error) {
            console.error('Supabase update error:', error);
            showNotification("Error updating process in database: " + error.message, 'error');
            return false;
        }

        return true;
    } catch (error) {
        console.error('Error updating in Supabase:', error);
        showNotification("Error updating process in database.", 'error');
        return false;
    }
}

async function deleteProcessFromSupabase(shortName, sheetName, databaseId = null) {
    try {
        if (!currentSheetId) {
            showNotification("No sheet context available.", 'error');
            return false;
        }

        let query = supabaseClient.from('processes').delete();

        if (databaseId) {
            query = query.eq('id', databaseId);
        } else {
            query = query.eq('short_name', shortName).eq('sheet_id', currentSheetId);
        }

        const { data, error } = await query;

        if (error) {
            console.error('Supabase delete error:', error);
            showNotification("Error deleting process from database: " + error.message, 'error');
            return false;
        }

        return true;
    } catch (error) {
        console.error('Error deleting from Supabase:', error);
        showNotification("Error deleting process from database.", 'error');
        return false;
    }
}

async function importExcelToSupabase() {
    showNotification("Excel import is disabled. Please use the project manager to create and manage processes.", 'warning');
        return;
}

// Legacy function maintained for UI state only (no process data)
function saveStateToLocalStorage() {
    if (typeof Storage !== "undefined") {
        try {
            const state = {

                currentZoom: currentZoom,
                scrollTop: diagramContainer.scrollTop,
                scrollLeft: diagramContainer.scrollLeft,
                currentAppliedFilters: currentAppliedFilters,
                currentAxisFilter: currentAxisFilter,
                configColors: configColors,
                selectedSheetViews: selectedSheetViews,
                isMiniMapVisible: miniMapWrapper.style.display === 'block',
                isTreeHighlightActive: isTreeHighlightActive,
                highlightedTreeNodesIds: Array.from(highlightedTreeNodesIds),
                isColorsPanelVisible: colorsPanel ? colorsPanel.classList.contains('open') : false,
                dependencyEditingEnabled: dependencyEditingEnabled,
                dependencyPanelWidth: dependencyPanelContainer ? dependencyPanelContainer.style.width : '50vw'
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
            console.error("Error saving state to LocalStorage:", e);
        }
    }
}

function loadStateFromLocalStorage() {
    if (typeof Storage !== "undefined") {
        const savedStateJSON = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (savedStateJSON) {
            try {
                const savedState = JSON.parse(savedStateJSON);
                
                // Only load UI state, not process data (that comes from Supabase)
                selectedSheetViews = Array.isArray(savedState.selectedSheetViews) ? savedState.selectedSheetViews : [];

                currentZoom = savedState.currentZoom || 1;
                currentAppliedFilters = savedState.currentAppliedFilters || {};
                temporaryActiveFilters = { ...currentAppliedFilters };
                currentAxisFilter = savedState.currentAxisFilter || { type: null, value: null, valueEnd: null };
                configColors = { ...JSON.parse(JSON.stringify(THEMES[0])), ...(savedState.configColors || {}) };

                const savedPanelWidth = savedState.dependencyPanelWidth;
                if (savedPanelWidth && dependencyPanelContainer) {
                    dependencyPanelContainer.style.width = savedPanelWidth;
                }

                isTreeHighlightActive = savedState.isTreeHighlightActive || false;
                highlightedTreeNodesIds = new Set(savedState.highlightedTreeNodesIds || []);
                dependencyEditingEnabled = savedState.dependencyEditingEnabled === true; 
                updateDependencyEditButtonText();

                if (colorsPanel && savedState.isColorsPanelVisible) {
                    toggleColorsPanel(true);
                }

                Object.keys(configColors).forEach(key => {
                    const pickerId = key.replace(/([A-Z])/g, '-$1').toLowerCase() + '-color';
                    const picker = document.getElementById(pickerId);
                    if (picker) picker.value = configColors[key];
                });



                diagramPane.style.transform = `scale(${currentZoom})`;

                if (savedState.isMiniMapVisible) {
                    miniMapWrapper.style.display = 'block';
                } else {
                    miniMapWrapper.style.display = 'none';
                }

                requestAnimationFrame(() => {
                    diagramContainer.scrollTop = savedState.scrollTop || 0;
                    diagramContainer.scrollLeft = savedState.scrollLeft || 0;
                    updateTopBarHeight();
                    updateStickyAxesContainerPositions();
                    updateStickyAxesLabels();
                    drawMiniMap();
                    updateMiniMapViewPort();
                    positionActionIcons();
                });

                return true;
            } catch (e) {
                console.error("Error parsing state from LocalStorage:", e);
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                isTreeHighlightActive = false;
                highlightedTreeNodesIds.clear();
                toggleColorsPanel(false);
                dependencyEditingEnabled = false; 
                updateDependencyEditButtonText();
                return false;
            }
        }
    }
    
    toggleColorsPanel(false);
    dependencyEditingEnabled = false; 
    updateDependencyEditButtonText();
    return false;
}
    
	function initializeColorPickers() {
    const colorPickerMapping = [
        { id: 'node-color', key: 'node' },
        { id: 'blocking-node-color', key: 'blockingNode' },
        { id: 'informational-node-color', key: 'informationalNode' },
        { id: 'lightning-color', key: 'lightning' },
        { id: 'input-process-color', key: 'inputProcess' },
        { id: 'output-process-color', key: 'outputProcess' },
        { id: 'sim-input-conflict-color', key: 'simInputConflict' },
        { id: 'sim-output-at-risk-color', key: 'simOutputAtRisk' },
        { id: 'input-arrow-color', key: 'inputArrow' },
        { id: 'output-arrow-color', key: 'outputArrow' },
        { id: 'input-arrow-blocking-color', key: 'inputArrowBlocking' },
        { id: 'output-arrow-blocking-color', key: 'outputArrowBlocking' },
        { id: 'input-arrow-informational-color', key: 'inputArrowInformational' },
        { id: 'output-arrow-informational-color', key: 'outputArrowInformational' },
		{ id: 'sim-ok-input-color', key: 'simOkInput' },
		{ id: 'sim-ok-output-color', key: 'simOkOutput' },
    ];

    colorPickerMapping.forEach(item => {
        const picker = document.getElementById(item.id);
        if (picker) {
            picker.value = configColors[item.key] || picker.value;
            if (!configColors[item.key]) {
                configColors[item.key] = picker.value;
            } else {
                picker.value = configColors[item.key];
            }

            picker.addEventListener('input', (event) => {
                configColors[item.key] = event.target.value;
                refreshDiagramStyles();
                saveStateToLocalStorage();
            });
        }
    });
}
	
// ZASTĄP ISTNIEJĄCĄ FUNKCJĘ TĄ WERSJĄ
function resetColorsToDefault() {
    currentThemeIndex = 0; // Resetuj indeks do motywu domyślnego
    configColors = JSON.parse(JSON.stringify(THEMES[0])); // Ustaw domyślny motyw
    
    initializeColorPickers();
    refreshDiagramStyles();
    saveStateToLocalStorage();
    
    showNotification(`Theme reset to: ${THEMES[0].name}.`, "success");
}

	// NOWA FUNKCJA GENEROWANIA LOSOWEGO MOTYWU FlowCraft 2025
function generateNewTheme() {
    // Paleta kolorów jasnych dla ciemnego tła FlowCraft 2025
    const brightColors = [
        // Neony i jasne kolory główne
        '#00D4FF', '#FF006E', '#8338EC', '#3A86FF', '#06FFA5', '#FFBE0B',
        '#FB5607', '#FF9F1C', '#E71D36', '#2EC4B6', '#CBF3F0', '#FF4081',
        // Cyjan/Turkus odcienie
        '#00BCD4', '#26C6DA', '#4DD0E1', '#80DEEA', '#00E5FF', '#18FFFF',
        // Różowe/Magenta odcienie
        '#E91E63', '#F06292', '#FF4081', '#FF80AB', '#C2185B', '#AD1457',
        // Fioletowe odcienie
        '#9C27B0', '#BA68C8', '#CE93D8', '#E1BEE7', '#7B1FA2', '#8E24AA',
        // Pomarańczowe/Żółte jasne
        '#FFC107', '#FFD54F', '#FFEE58', '#FFF176', '#FF8F00', '#FFA000',
        // Zielone neonowe
        '#4CAF50', '#66BB6A', '#81C784', '#A5D6A7', '#00C853', '#00E676',
        // Niebieskie jasne
        '#2196F3', '#42A5F5', '#64B5F6', '#90CAF9', '#03A9F4', '#29B6F6',
        // Lime/Jasnozielone
        '#CDDC39', '#D4E157', '#DCE775', '#E6EE9C', '#AFD135', '#C0CA33'
    ];

    // Kolory dla strzałek (bardziej nasycone)
    const arrowColors = [
        '#FF0080', '#00FF80', '#8000FF', '#FF8000', '#0080FF', '#80FF00',
        '#FF4000', '#40FF00', '#0040FF', '#FF0040', '#00FFFF', '#FFFF00',
        '#FF00FF', '#00FF00', '#0000FF', '#FF0000', '#FFFFFF', '#C0C0C0'
    ];

    // Kolory lightning (bardzo jasne i kontrastowe)
    const lightningColors = [
        '#FFFFFF', '#00FFFF', '#FF00FF', '#FFFF00', '#00FF00', '#FF0000',
        '#00D4FF', '#FF006E', '#06FFA5', '#FFBE0B', '#E71D36', '#8338EC'
    ];

    // Generuj losowy motyw
    const randomTheme = {
        name: `FlowCraft ${Date.now().toString().slice(-6)}`, // Unikalny suffix
        
        // Węzły - jasne kolory na ciemnym tle
        node: getRandomColor(brightColors),
        blockingNode: getRandomColor(brightColors),
        informationalNode: getRandomColor(brightColors),
        
        // Lightning - bardzo jasny i kontrastowy
        lightning: getRandomColor(lightningColors),
        
        // Procesy wejściowe/wyjściowe - jaśniejsze odcienie
        inputProcess: getRandomColor(brightColors),
        outputProcess: getRandomColor(brightColors),
        
        // Strzałki - kontrastowe i dobrze widoczne
        inputArrow: getRandomColor(arrowColors),
        outputArrow: getRandomColor(arrowColors),
        inputArrowBlocking: getRandomColor(arrowColors),
        outputArrowBlocking: getRandomColor(arrowColors),
        inputArrowInformational: getRandomColor(arrowColors),
        outputArrowInformational: getRandomColor(arrowColors),
        
        // Symbol na węzłach - zawsze jasny na ciemnym tle
        nodeSymbolColor: '#FFFFFF',
        
        // Kolory symulacji (dobre dla wszystkich motywów)
        simOkInput: '#D4EDDA',
        simOkOutput: '#A3D9B1', 
        simInputConflict: '#F8D7DA',
        simOutputAtRisk: '#E4A1A6'
    };
    
    // Zastosuj nowy motyw
    configColors = JSON.parse(JSON.stringify(randomTheme));
    
    initializeColorPickers();
    refreshDiagramStyles();
    saveStateToLocalStorage();
    
    showNotification(`🎨 Generated new FlowCraft theme: ${randomTheme.name}`, "success");
}

// Funkcja pomocnicza do losowania koloru z palety
function getRandomColor(colorArray) {
    return colorArray[Math.floor(Math.random() * colorArray.length)];
}
	
    function getAllProcessesFromData() {
        let allProcs = [];
        Object.keys(processesData).forEach(sheetName => { 
            if(Array.isArray(processesData[sheetName])) {
                const sheetData = processesData[sheetName].map(p => ({...p, "_sourceSheet": sheetName}));
                allProcs.push(...sheetData);
            }
        });
        return allProcs;
    }


    function getCurrentlyVisibleProcesses(includeSourceSheetTag = false) {
        if (!selectedSheetViews || selectedSheetViews.length === 0 || Object.keys(processesData).length === 0) {
            return [];
        }

        let collectedProcesses = [];
        selectedSheetViews.forEach(sheetName => {
            if (processesData[sheetName] && Array.isArray(processesData[sheetName])) {
                processesData[sheetName].forEach(p => {
                    const processWithSheetInfo = { ...p };
                    if (includeSourceSheetTag) {
                        processWithSheetInfo._sourceSheet = sheetName;
                        if (allDataSourceSheetNames.length > 1) {
                            const colorIdx = allDataSourceSheetNames.indexOf(sheetName);
                            if (colorIdx !== -1) {
                                processWithSheetInfo._sheetColorIndex = colorIdx % sheetColors.length;
                            }
                        }
                    }
                    collectedProcesses.push(processWithSheetInfo);
                });
            }
        });


        return collectedProcesses;
    }


// MODYFIKACJA START: Cała funkcja refreshDiagramStyles została zastąpiona nową, poprawioną wersją
// =================== START KODU DO ZASTĄPIENIA ===================

function refreshDiagramStyles() {
    if (isSimulationModeActive) {
        applySimulationVisuals(simulatedNewProcessData); 
        return; 
    }
    
    const allProcsDataWithSheetInfo = getAllProcessesFromData();
    const diagramNodes = diagramPane.querySelectorAll('.process-node');

    svgLayer.innerHTML = '';
    simulationGhostLayer.innerHTML = '';

    diagramNodes.forEach(nodeEl => {
        const procId = nodeEl.dataset.id;
        const nodeSheet = nodeEl.dataset.sourceSheet;
        const procData = allProcsDataWithSheetInfo.find(p => p.ID === procId && p._sourceSheet === nodeSheet);

        // --- Resetowanie stylów przed ponownym nałożeniem ---
        nodeEl.classList.remove(
            'selected', 'dependent-input', 'dependent-output',
            'dimmed-selection', 'tree-highlight-dimmed', 'standard-blocking'
        );
        nodeEl.style.opacity = 1;
        nodeEl.style.boxShadow = '1px 1px 3px rgba(0,0,0,0.1)'; // Reset cienia
        nodeEl.classList.add('can-hover');

        // --- Logika wyboru koloru bazowego (uwzględnia motyw i tryb dark/light) ---
        let baseNodeColorToApply = configColors.node;
        const isDarkMode = document.body.classList.contains('dark-mode');
        
        if (procData && procData._sheetColorIndex !== undefined && allDataSourceSheetNames.length > 1) {
            const colorPalette = isDarkMode ? darkSheetColors : sheetColors;
            baseNodeColorToApply = colorPalette[procData._sheetColorIndex % colorPalette.length];
        }

        const processType = (procData ? (procData["Process Type"] || "standard").toLowerCase() : "standard");

        // Stosowanie stylów dla typów węzłów
        if (processType === "blocking") {
            baseNodeColorToApply = configColors.blockingNode;
        } else if (processType === "informational") {
            baseNodeColorToApply = configColors.informationalNode;
        } else if (processType === "standard-blocking") {
            nodeEl.classList.add('standard-blocking'); // Ta klasa zarządza obramowaniem
            baseNodeColorToApply = configColors.node; // Tło jak dla standardowego
        }
        
        // Domyślne nałożenie kolorów bazowych
        nodeEl.style.backgroundColor = baseNodeColorToApply;
        if (processType !== 'standard-blocking') {
             nodeEl.style.borderColor = shadeColor(baseNodeColorToApply, -0.3);
        }

        // --- Logika dla filtrów, wyszukiwania i podświetlania drzewa (bez zmian) ---
        if (nodeEl.classList.contains('filtered-out-general') || nodeEl.classList.contains('filtered-out-axis')) {
            nodeEl.classList.remove('can-hover');
        }

        if (isTreeHighlightActive) {
            nodeEl.classList.remove('can-hover');
            if (highlightedTreeNodesIds.has(procId)) {
                nodeEl.classList.add('can-hover');
                if (procId !== currentlySelectedProcessId) {
                    nodeEl.style.borderColor = configColors.lightning;
                    nodeEl.style.boxShadow = `0 0 5px ${configColors.lightning}`;
                }
            } else {
                nodeEl.classList.add('tree-highlight-dimmed');
            }
        }

        if (nodeEl.classList.contains('search-highlight')) {
            nodeEl.style.backgroundColor = '#ffe0b3';
            nodeEl.style.borderColor = '#ff8c00';
            nodeEl.classList.add('can-hover');
            nodeEl.style.opacity = 1;
        } else if (nodeEl.classList.contains('search-dimmed')) {
            nodeEl.classList.remove('can-hover');
        }

        // --- Główna modyfikacja: Obsługa stanu zaznaczenia ORAZ stanu domyślnego ---
        if (!isTreeHighlightActive && currentlySelectedProcessId) {
            // Kod dla aktywnego zaznaczenia (pozostaje bez zmian)
            if (procId === currentlySelectedProcessId) {
                nodeEl.classList.add('selected');
                nodeEl.style.borderColor = configColors.lightning;
                nodeEl.style.boxShadow = `0 0 10px ${configColors.lightning}`;
                nodeEl.style.opacity = 1;
                nodeEl.classList.add('can-hover');
            } else {
                let isDirectDependency = false;
                const selectedProcDataForDeps = allProcsDataWithSheetInfo.find(p => p.ID === currentlySelectedProcessId);

                if (selectedProcDataForDeps && selectedProcDataForDeps.Dependencies) {
                    const depsOfSelected = String(selectedProcDataForDeps.Dependencies).split(',').map(d => parseDependencyEntry(d).id);
                    if (depsOfSelected.includes(procId)) {
                        nodeEl.classList.add('dependent-input');
                        if (!nodeEl.classList.contains('search-highlight')) {
                            nodeEl.style.backgroundColor = configColors.inputProcess;
                            nodeEl.style.borderColor = shadeColor(configColors.inputProcess, -0.3);
                        }
                        isDirectDependency = true;
                    }
                }

                if (!isDirectDependency && procData && procData.Dependencies) {
                    const depsOfCurrentNode = String(procData.Dependencies).split(',').map(d => parseDependencyEntry(d).id);
                    if (depsOfCurrentNode.includes(currentlySelectedProcessId)) {
                        nodeEl.classList.add('dependent-output');
                        if (!nodeEl.classList.contains('search-highlight')) {
                            nodeEl.style.backgroundColor = configColors.outputProcess;
                            nodeEl.style.borderColor = shadeColor(configColors.outputProcess, -0.3);
                        }
                        isDirectDependency = true;
                    }
                }

                if (isDirectDependency) {
                    nodeEl.style.opacity = 1;
                    nodeEl.classList.add('can-hover');
                } else if (!nodeEl.classList.contains('search-highlight') && !nodeEl.classList.contains('search-dimmed') &&
                    !nodeEl.classList.contains('filtered-out-general') && !nodeEl.classList.contains('filtered-out-axis') &&
                    !nodeEl.classList.contains('tree-highlight-dimmed')) {
                    nodeEl.classList.add('dimmed-selection');
                    nodeEl.classList.remove('can-hover');
                }
            }
        } 
        // === KLUCZOWY DODATEK: Ten blok `else` obsługuje stan, gdy nic nie jest zaznaczone ===
        else {
            // Ten blok jest pusty, ponieważ domyślne kolory zostały już nałożone na początku funkcji.
            // Wszystkie węzły, które nie są przefiltrowane, mają już poprawny, aktualny kolor z motywu.
            // Zostawiamy to dla jasności, że ten przypadek jest teraz obsłużony.
        }

        // --- Końcowa stylizacja symbolu (bez zmian) ---
        const symbolSpan = nodeEl.querySelector('.node-type-symbol');
        if (symbolSpan) {
            symbolSpan.style.color = configColors.nodeSymbolColor || '#333';
        }
    });

    // --- Rysowanie strzałek (bez zmian) ---
    if (isTreeHighlightActive) {
        if (highlightedTreeNodesIds.size > 0) {
            drawAllTreeDependencies();
        }
    } else if (currentlySelectedProcessId) {
        const selectedProcessForArrows = allProcsDataWithSheetInfo.find(p => p.ID === currentlySelectedProcessId);
        if (selectedProcessForArrows) {
            drawSelectionDependenciesArrows(selectedProcessForArrows);
        }
    }

    // --- Aktualizacja pozostałych elementów UI (bez zmian) ---
    positionActionIcons();
    drawMiniMap();
    updateMiniMapViewPort();
}

// =================== KONIEC KODU DO ZASTĄPIENIA ===================

// MODYFIKACJA START: Zaktualizowana funkcja rysowania strzałek z poprawnymi grotami
function drawSelectionDependenciesArrows(selectedProcess) {
    if (!selectedProcess || !nodeLayouts[selectedProcess.ID]) return;

    const selectedId = selectedProcess.ID;
    const selectedNodeEl = diagramPane.querySelector(`.process-node[data-id="${selectedId}"]`);
    if (!selectedNodeEl || selectedNodeEl.classList.contains('filtered-out-general') || selectedNodeEl.classList.contains('filtered-out-axis')) return;

    const allProcsDataWithSheet = getAllProcessesFromData();

    // Rysowanie strzałek wejściowych (INPUTS)
    const inputRawEntries = (selectedProcess.Dependencies ? String(selectedProcess.Dependencies) : '').split(',').map(entry => entry.trim()).filter(entry => entry);
    inputRawEntries.forEach(rawDepEntry => {
        const { id: inputSourceId, type: depLinkType } = parseDependencyEntry(rawDepEntry);
        if (inputSourceId === selectedId) return;

        const inputSourceNodeEl = diagramPane.querySelector(`.process-node[data-id="${inputSourceId}"]`);
        if (inputSourceNodeEl &&
            !inputSourceNodeEl.classList.contains('filtered-out-general') &&
            !inputSourceNodeEl.classList.contains('filtered-out-axis') &&
            !inputSourceNodeEl.classList.contains('search-dimmed') &&
            !inputSourceNodeEl.classList.contains('dimmed-selection') &&
            !(isTreeHighlightActive && !highlightedTreeNodesIds.has(inputSourceId))) {
            const sourceProcessData = allProcsDataWithSheet.find(p => p.ID === inputSourceId);
            const sourceProcessType = sourceProcessData ? (sourceProcessData["Process Type"] || "standard").toLowerCase() : "standard";

            if (sourceProcessType === 'standard-blocking') {
                // 1. Rysuj grubszą, przerywaną strzałkę blokującą (spód) BEZ GROTA
                drawArrow(inputSourceNodeEl, selectedNodeEl, configColors.inputArrowBlocking, 'input-arrow selection-arrow thick-arrow-bottom', 'blocking', false);
                // 2. Rysuj cieńszą, ciągłą strzałkę standardową (wierzch) Z GROTEM
                drawArrow(inputSourceNodeEl, selectedNodeEl, configColors.inputArrow, 'input-arrow selection-arrow', 'standard', false);
            } else {
                let arrowColor = configColors.inputArrow;
                let finalDepType = depLinkType;
                if (sourceProcessType === 'blocking' || depLinkType === 'blocking') {
                    arrowColor = configColors.inputArrowBlocking;
                    finalDepType = 'blocking';
                } else if (sourceProcessType === 'informational' || depLinkType === 'informational') {
                    arrowColor = configColors.inputArrowInformational;
                    finalDepType = 'informational';
                }
                drawArrow(inputSourceNodeEl, selectedNodeEl, arrowColor, 'input-arrow selection-arrow', finalDepType, false);
            }
        }
    });

    // Rysowanie strzałek wyjściowych (OUTPUTS)
    const selectedProcessType = (selectedProcess["Process Type"] || "standard").toLowerCase();

    allProcsDataWithSheet.forEach(proc => {
        if (!proc.Dependencies || !nodeLayouts[proc.ID] || proc.ID === selectedId) return;

        const procDepRawEntries = String(proc.Dependencies).split(',').map(entry => entry.trim()).filter(entry => entry);
        procDepRawEntries.forEach(rawDepEntry => {
            const { id: depTargetIdInOther, type: depLinkType } = parseDependencyEntry(rawDepEntry);

            if (depTargetIdInOther === selectedId) {
                const outputTargetNodeEl = diagramPane.querySelector(`.process-node[data-id="${proc.ID}"]`);
                if (outputTargetNodeEl &&
                    !outputTargetNodeEl.classList.contains('filtered-out-general') &&
                    !outputTargetNodeEl.classList.contains('filtered-out-axis') &&
                    !outputTargetNodeEl.classList.contains('search-dimmed') &&
                    !outputTargetNodeEl.classList.contains('dimmed-selection') &&
                    !(isTreeHighlightActive && !highlightedTreeNodesIds.has(proc.ID))) {
                    if (selectedProcessType === 'standard-blocking') {
                        // 1. Rysuj grubszą, przerywaną strzałkę blokującą (spód) BEZ GROTA
                        drawArrow(selectedNodeEl, outputTargetNodeEl, configColors.outputArrowBlocking, 'output-arrow selection-arrow thick-arrow-bottom', 'blocking', false);
                        // 2. Rysuj cieńszą, ciągłą strzałkę standardową (wierzch) Z GROTEM
                        drawArrow(selectedNodeEl, outputTargetNodeEl, configColors.outputArrow, 'output-arrow selection-arrow', 'standard', false);
                    } else {
                        let arrowColor = configColors.outputArrow;
                        let finalDepType = depLinkType;
                        if (selectedProcessType === 'blocking' || depLinkType === 'blocking') {
                            arrowColor = configColors.outputArrowBlocking;
                            finalDepType = 'blocking';
                        } else if (selectedProcessType === 'informational' || depLinkType === 'informational') {
                            arrowColor = configColors.outputArrowInformational;
                            finalDepType = 'informational';
                        }
                        drawArrow(selectedNodeEl, outputTargetNodeEl, arrowColor, 'output-arrow selection-arrow', finalDepType, false);
                    }
                }
            }
        });
    });
}
// MODYFIKACJA KONIEC

    function renderDiagramAndRestoreState() {
    if (isSimulationModeActive) {
        applySimulationVisuals(simulatedNewProcessData); 
        return; 
    }
    
    const previouslySelectedId = currentlySelectedProcessId; 
    const wasTreeHighlightActive = isTreeHighlightActive;
    const previousHighlightedTreeIds = new Set(highlightedTreeNodesIds); 

    renderDiagram(); 

    isTreeHighlightActive = wasTreeHighlightActive; 
    if (isTreeHighlightActive) {
        highlightedTreeNodesIds = previousHighlightedTreeIds; 
        if (previouslySelectedId && highlightedTreeNodesIds.has(previouslySelectedId)) {
            currentlySelectedProcessId = previouslySelectedId;
        } else if (previouslySelectedId && !highlightedTreeNodesIds.has(previouslySelectedId)) {
            currentlySelectedProcessId = null; 
        }
    } else {
        if (previouslySelectedId) {
            const nodeToReselect = diagramPane.querySelector(`.process-node[data-id="${previouslySelectedId}"]`);
            if (nodeToReselect &&
                !nodeToReselect.classList.contains('filtered-out-general') &&
                !nodeToReselect.classList.contains('filtered-out-axis') &&
                !nodeToReselect.classList.contains('search-dimmed')
            ) {
                currentlySelectedProcessId = previouslySelectedId; 
            } else {
                currentlySelectedProcessId = null; 
            }
        } else {
            currentlySelectedProcessId = null;
        }
    }

    if (currentlySelectedProcessId) {
        const procData = getCurrentlyVisibleProcesses(true).find(p => p.ID === currentlySelectedProcessId);
        displayProcessDetails(procData);
    } else {
        displayProcessDetails(null);
    }
    
    refreshDiagramStyles(); 
    updateAllDependencyAndSimShortcutButtonsState();
}


    function parseTime(timeStr) {
        if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) return NaN;
        const parts = timeStr.split(':');
        const h = parseInt(parts[0], 10);
        const m = parseInt(parts[1], 10);
        const s = parseInt(parts[2], 10) || 0;
        if (isNaN(h) || h < 0 || h > 23 || isNaN(m) || m < 0 || m > 59 || isNaN(s) || s < 0 || s > 59) {
            return NaN;
        }
        return h * 3600 + m * 60 + s;
    }

    function formatTimeForAxis(seconds) {
        if (isNaN(seconds)) return "??:??";
        const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
        const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
        return `${h}:${m}`;
    }

    function getHourFromTimeSec(seconds) {
        if (isNaN(seconds)) return null;
        return Math.floor(seconds / 3600);
    }

    function updateGlobalUniqueDueTimeHours() {
        const currentProcesses = getCurrentlyVisibleProcesses();
        const dueTimeHours = new Set();
        currentProcesses.forEach(p => {
            const timeSec = parseTime(p["Due time"]);
            const hour = getHourFromTimeSec(timeSec);
            if (hour !== null) {
                dueTimeHours.add(hour);
            }
        });
        gUniqueDueTimeHours = Array.from(dueTimeHours).sort((a, b) => a - b);

        if (gUniqueDueTimeHours.length === 0 && currentProcesses.length > 0) {
            const hasAnyTime = currentProcesses.some(p => !isNaN(parseTime(p["Due time"])));
            if (hasAnyTime) gUniqueDueTimeHours.push(0); 
        }
    }

    function handleJsonFileSelect(event) {
        if (isSimulationModeActive) endSimulation();
        const inputElement = event.target;
        if (inputElement.files && inputElement.files.length > 0) {
            const file = inputElement.files[0];
            loadJsonFromFile(file);
        } else {
            jsonFileNameSpan.textContent = '';
            if (inputElement) inputElement.value = null;
            saveStateToLocalStorage();
        }
    }

    function loadJsonFromFile(fileObject) {
        menuContent.style.display = 'none';
        if (!fileObject) {
            jsonFileNameSpan.textContent = '';
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const fileContent = e.target.result;
                let loadedData = JSON.parse(fileContent);
                processAndLoadJsonData(loadedData, fileObject.name); 
            } catch (error) {
                showNotification('Error parsing JSON file: ' + error.message, 'error', 0); 
                 processesData = {};
                 selectedSheetViews = [];
                 allDataSourceSheetNames = [];

                 isTreeHighlightActive = false; highlightedTreeNodesIds.clear();
                 jsonFileNameSpan.textContent = '';
                 updateSheetMultiSelectDropdown();
                saveStateToLocalStorage(); renderDiagram();
            } finally {
                if (fileInput.files && fileInput.files[0] === fileObject) {
                    fileInput.value = null;
                }
            }
        };
        reader.onerror = (e) => {
            showNotification('Error reading file: ' + e, 'error', 0); 
             processesData = {};
             selectedSheetViews = [];
             allDataSourceSheetNames = [];

             isTreeHighlightActive = false; highlightedTreeNodesIds.clear();
             jsonFileNameSpan.textContent = '';
             updateSheetMultiSelectDropdown(); saveStateToLocalStorage();
             if (fileInput.files && fileInput.files[0] === fileObject) {
                fileInput.value = null;
             }
        };
        reader.readAsText(fileObject);
    }

    function validateProcessObject(process, sheetName, index) {
        const errors = [];
        const warnings = [];
        let validatedProcess = {...process}; 

        for (const key of JSON_VALIDATION_REQUIRED_KEYS) {
            if (validatedProcess[key] === undefined || validatedProcess[key] === null || String(validatedProcess[key]).trim() === "") {
                 if (key === "WD" && (validatedProcess[key] === 0 || String(validatedProcess[key]) === "0")) {
                    errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Working Day cannot be 0. Use positive numbers for current month or negative for previous month.`);
                } else if (key === "Due time" && String(validatedProcess[key]).trim() === "") {
                    validatedProcess[key] = "";
                } else {
                    errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Missing required field "${key}".`);
                }
            }
        }

        if (validatedProcess.ID !== undefined && validatedProcess.ID !== null) {
            const idStr = String(validatedProcess.ID).trim();
            if (idStr === "") {
                errors.push(`Sheet "${sheetName}", process index ${index}: Field "ID" cannot be empty.`);
            } else if (!/^[a-zA-Z0-9._-]+$/.test(idStr)) {
                errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${idStr}): Field "ID" contains invalid characters. Use letters, numbers, '.', '_', '-'.`);
            }
            validatedProcess.ID = idStr; 
        } else if (!errors.some(err => err.includes('Missing required field "ID"'))) { 
             errors.push(`Sheet "${sheetName}", process index ${index}: Field "ID" is missing or null.`);
        }


        if (validatedProcess.WD !== undefined && validatedProcess.WD !== null && String(validatedProcess.WD).trim() !== "") {
            const wdNum = parseInt(validatedProcess.WD, 10);
            if (isNaN(wdNum)) {
                errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Field "WD" ("${validatedProcess.WD}") is not a valid integer. Using 1.`);
                validatedProcess.WD = 1; 
            } else if (wdNum === 0) {
                errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Working Day cannot be 0. Using 1.`);
                validatedProcess.WD = 1;
            } else {
                validatedProcess.WD = wdNum; 
            }
        } else {
            validatedProcess.WD = 1; 
        }

        if (validatedProcess["Due time"] !== undefined && validatedProcess["Due time"] !== null && String(validatedProcess["Due time"]).trim() !== "") {
            const timeStr = String(validatedProcess["Due time"]).trim();
            if (!/^\d{1,2}:\d{2}(:\d{2})?$/.test(timeStr)) {
                errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Field "Due time" ("${timeStr}") format must be HH:MM or HH:MM:SS. Using empty.`);
                validatedProcess["Due time"] = "";
            } else {
                const tempTime = timeStr.includes(':') && timeStr.split(':').length === 2 ? timeStr + ":00" : timeStr;
                if (isNaN(parseTime(tempTime))) {
                    errors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Field "Due time" ("${timeStr}") is not a valid time (00:00:00 - 23:59:59). Using empty.`);
                    validatedProcess["Due time"] = "";
                } else {
                     validatedProcess["Due time"] = tempTime; 
                }
            }
        } else {
             validatedProcess["Due time"] = ""; 
        }
        
        const processType = (validatedProcess["Process Type"] || "standard").toLowerCase().trim();
        if (!["standard", "blocking", "informational"].includes(processType)) {
            warnings.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID || 'UNKNOWN'}): Invalid "Process Type" ("${validatedProcess["Process Type"] || ''}"). Defaulted to "standard".`);
            validatedProcess["Process Type"] = "standard";
        } else {
            validatedProcess["Process Type"] = processType; 
        }
        
        if (validatedProcess.Dependencies === undefined || validatedProcess.Dependencies === null) {
            validatedProcess.Dependencies = "";
        } else {
            validatedProcess.Dependencies = String(validatedProcess.Dependencies);
        }

        return { errors, warnings, validatedProcess };
    }


    async function processAndLoadJsonData(loadedData, sourceFileName) {
        if (isSimulationModeActive) endSimulation();
        if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';

        const newProcessesData = {};
        const newAllDataSourceSheetNames = [];
        let overallValidationErrors = [];
        let overallValidationWarnings = [];
        let uniqueIdCheck = {}; 

        if (Array.isArray(loadedData)) {
            const sheetName = "Default"; 
             newAllDataSourceSheetNames.push(sheetName);
            uniqueIdCheck[sheetName] = new Set();
            newProcessesData[sheetName] = [];

            loadedData.forEach((p, index) => {
                const { errors, warnings, validatedProcess } = validateProcessObject(p, sheetName, index);
                overallValidationErrors.push(...errors);
                overallValidationWarnings.push(...warnings);

                if (errors.length === 0) {
                    if (validatedProcess.ID && uniqueIdCheck[sheetName].has(validatedProcess.ID)) {
                        overallValidationErrors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID}): Duplicate ID found in this sheet.`);
                    } else {
                        if(validatedProcess.ID) uniqueIdCheck[sheetName].add(validatedProcess.ID);
                        newProcessesData[sheetName].push({
                            ...validatedProcess,
                            Description: String(validatedProcess.Description || '').replace(/\\n/g, '\n')
                        });
                    }
                }
            });
        } else if (typeof loadedData === 'object' && loadedData !== null) {
            Object.keys(loadedData).forEach(sheetName => {
                if (Array.isArray(loadedData[sheetName])) {
                    newAllDataSourceSheetNames.push(sheetName);
                    uniqueIdCheck[sheetName] = new Set();
                    newProcessesData[sheetName] = [];

                    loadedData[sheetName].forEach((p, index) => {
                        const { errors, warnings, validatedProcess } = validateProcessObject(p, sheetName, index);
                        overallValidationErrors.push(...errors);
                        overallValidationWarnings.push(...warnings);

                        if (errors.length === 0) {
                            if (validatedProcess.ID && uniqueIdCheck[sheetName].has(validatedProcess.ID)) {
                                overallValidationErrors.push(`Sheet "${sheetName}", process index ${index} (ID: ${validatedProcess.ID}): Duplicate ID found in this sheet.`);
                            } else {
                                if(validatedProcess.ID) uniqueIdCheck[sheetName].add(validatedProcess.ID);
                                newProcessesData[sheetName].push({
                                    ...validatedProcess,
                                    Description: String(validatedProcess.Description || '').replace(/\\n/g, '\n')
                                });
                            }
                        }
                    });
                } else {
                    overallValidationWarnings.push(`Sheet "${sheetName}" data is not an array and was skipped.`);
                }
            });
        } else {
            showNotification("JSON data must be an array of processes or an object of sheet-keyed arrays.", 'error', 0);
            jsonFileNameSpan.textContent = '';
            if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
            return;
        }
        
        if (overallValidationWarnings.length > 0) {
            showNotification("<strong>JSON Load Warnings:</strong><br>" + overallValidationWarnings.map(w => `- ${w}`).join("<br>"), 'warning', 10000);
        }
        if (overallValidationErrors.length > 0) {
            showNotification("<strong>JSON Load Errors (some data might be ignored):</strong><br>" + overallValidationErrors.map(e => `- ${e}`).join("<br>"), 'error', 15000);
            const totalValidProcesses = Object.values(newProcessesData).reduce((sum, sheet) => sum + (sheet ? sheet.length : 0), 0);
            if (totalValidProcesses === 0) {
                 showNotification("<strong>Critical JSON Load Error:</strong> No valid process data could be loaded due to errors. Please check the JSON structure and required fields (ID, WD, Due time).", 'error', 0);
                 processesData = {}; allDataSourceSheetNames = []; selectedSheetViews = [];
                 updateSheetMultiSelectDropdown(); renderDiagram(); saveStateToLocalStorage();
                 if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
                 return;
            }
        }

        if (Object.keys(newProcessesData).length === 0 && newAllDataSourceSheetNames.length === 0 && overallValidationErrors.length > 0) {
            showNotification("No valid process data found in the JSON after validation.", 'error', 0);
            jsonFileNameSpan.textContent = '';
            processesData = {}; allDataSourceSheetNames = []; selectedSheetViews = [];
            updateSheetMultiSelectDropdown(); renderDiagram(); saveStateToLocalStorage();
            if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
            return;
        }

        processesData = newProcessesData;
        allDataSourceSheetNames = newAllDataSourceSheetNames.sort(); 

        if (allDataSourceSheetNames.length > 0) {
            selectedSheetViews = [...allDataSourceSheetNames]; 
        } else {
            selectedSheetViews = [];
        }

        jsonFileNameSpan.textContent = sourceFileName || 'Loaded Data';
        updateSheetMultiSelectDropdown();
        updateAddProcessButtonState();

        isTreeHighlightActive = false;
        highlightedTreeNodesIds.clear();
        currentZoom = 1; 
        diagramPane.style.transform = `scale(${currentZoom})`;
        diagramContainer.scrollTop = 0; 
        diagramContainer.scrollLeft = 0;
        temporaryActiveFilters = {}; currentAppliedFilters = {}; 
        currentAxisFilter = { type: null, value: null, valueEnd: null };
        currentlySelectedProcessId = null; nodeLayouts = {}; 

        updateGlobalUniqueDueTimeHours();
        populateFilterPanel(); 
        renderDiagram(); 
        resetVisualStates(); 

        requestAnimationFrame(() => {
            updateTopBarHeight();
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
            drawMiniMap();
            updateMiniMapViewPort();
            positionActionIcons(); 
        });
        saveStateToLocalStorage(); 
        if (overallValidationErrors.length === 0 && overallValidationWarnings.length === 0) {
            showNotification(`Successfully loaded data from ${sourceFileName || 'JSON'}.`, 'success');
        }
        if (Object.keys(newProcessesData).length > 0 && getCurrentlyVisibleProcesses().length > 0) {
             if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';
        } else {
             if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
        }
    }

    // Function to update the button text showing selected sheets
    function updateTopSheetSelectionText() {
        const selectionTextElement = document.getElementById('top-sheet-selection-text');
        if (!selectionTextElement) return;

        if (allDataSourceSheetNames.length === 0) {
            selectionTextElement.textContent = 'No sheets';
        } else if (selectedSheetViews.length === 0) {
            selectionTextElement.textContent = 'Select sheets...';
        } else if (selectedSheetViews.length === allDataSourceSheetNames.length) {
            selectionTextElement.textContent = 'All sheets';
        } else if (selectedSheetViews.length === 1) {
            selectionTextElement.textContent = selectedSheetViews[0];
        } else {
            selectionTextElement.textContent = `${selectedSheetViews.length} sheets`;
        }
    }

    function updateSheetMultiSelectDropdown() {
        sheetMultiSelectOptions.innerHTML = ''; 

        if (allDataSourceSheetNames.length === 0) {
            sheetMultiSelectOptions.innerHTML = '<p style="font-size:0.85em; color:#777; margin: 8px; text-align: center;">No sheets available in this project.</p>';
            sheetSelectAllCheckbox.disabled = true;
            sheetSelectAllCheckbox.checked = false;
            selectedSheetViews = []; 
        } else {
            allDataSourceSheetNames.forEach(sheetName => {
                const label = document.createElement('label');
                label.style.display = 'block';
                label.style.padding = '6px 12px';
                label.style.cursor = 'pointer';
                label.style.fontSize = '0.85em';
                label.style.borderRadius = '3px';
                label.style.transition = 'background-color 0.2s';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = sheetName;
                checkbox.checked = selectedSheetViews.includes(sheetName);
                checkbox.style.marginRight = '8px';
                checkbox.addEventListener('change', handleSheetSelectionChange);

                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(sheetName));
                
                // Add hover effect
                label.addEventListener('mouseenter', () => {
                    label.style.backgroundColor = '#f8f9fa';
                });
                label.addEventListener('mouseleave', () => {
                    label.style.backgroundColor = 'transparent';
                });
                
                sheetMultiSelectOptions.appendChild(label);
            });
            sheetSelectAllCheckbox.disabled = false;
            checkSelectAllState(); 
        }
        updateAddProcessButtonState(); 
        updateTopSheetSelectionText(); // Update button text
    }

    function checkSelectAllState() {
        const checkboxes = sheetMultiSelectOptions.querySelectorAll('input[type="checkbox"]');
        if (checkboxes.length === 0) {
            sheetSelectAllCheckbox.checked = false;
            sheetSelectAllCheckbox.indeterminate = false;
            updateTopSheetSelectionText();
            return;
        }
        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        const someChecked = Array.from(checkboxes).some(cb => cb.checked);

        sheetSelectAllCheckbox.checked = allChecked;
        sheetSelectAllCheckbox.indeterminate = !allChecked && someChecked;
        updateTopSheetSelectionText();
    }

    async function handleSheetSelectionChange() {
        if (isSimulationModeActive) endSimulation();
        selectedSheetViews = Array.from(sheetMultiSelectOptions.querySelectorAll('input[type="checkbox"]:checked'))
                                .map(cb => cb.value);
        checkSelectAllState();
        updateAddProcessButtonState();

        isTreeHighlightActive = false;
        highlightedTreeNodesIds.clear();
        temporaryActiveFilters = {}; currentAppliedFilters = {};
        currentAxisFilter = { type: null, value: null, valueEnd: null };
        currentlySelectedProcessId = null; 

        // Load data from selected sheets
        await loadMultipleSheetsFromSupabase();

        updateGlobalUniqueDueTimeHours(); 
        populateFilterPanel(); 
        renderDiagram(); 
        resetVisualStates(); 
        saveStateToLocalStorage();
    }

    // Load data from multiple selected sheets
    async function loadMultipleSheetsFromSupabase() {
        if (!currentProjectId || selectedSheetViews.length === 0) {
            processesData = {};
            return;
        }

        try {
            showNotification("Loading data from selected sheets...", 'info');
            
            // Get sheet IDs for selected sheet names
            const { data: sheets, error: sheetsError } = await supabaseClient
                .from('sheets')
                .select('id, name')
                .eq('project_id', currentProjectId)
                .in('name', selectedSheetViews);

            if (sheetsError) throw sheetsError;

            const newProcessesData = {};

            // Load processes for each selected sheet
            for (const sheet of sheets) {
                const { data: processes, error: processesError } = await supabaseClient
                    .from('processes')
                    .select('*')
                    .eq('sheet_id', sheet.id)
                    .order('working_day', { ascending: true });

                if (processesError) {
                    console.error(`Error loading processes for sheet ${sheet.name}:`, processesError);
                    continue;
                }

                newProcessesData[sheet.name] = [];

                processes.forEach(row => {
                    // Convert database row to application format
                    const process = {
                        ID: row.short_name, // Using short_name as ID for compatibility
                        "Short name": row.short_name,
                        Description: row.description || '',
                        WD: row.working_day,
                        "Working day": row.working_day, // Alternative field name
                        "Due time": row.due_time || '',
                        Dependencies: row.dependencies || '',
                        "Process Type": row.process_type || 'standard',
                        "Process type": row.process_type || 'standard', // Alternative field name
                        _databaseId: row.id, // Store database ID for updates
                        _customData: row.custom_data || {}, // Store custom fields data
                        // Add status-related fields for proper synchronization
                        status: row.status || 'PENDING',
                        completed_at: row.completed_at,
                        completion_note: row.completion_note,
                        assigned_to: row.assigned_to,
                        due_date: row.due_date
                    };

                    // Add custom fields to process object
                    if (row.custom_data && typeof row.custom_data === 'object') {
                        Object.keys(row.custom_data).forEach(key => {
                            process[key] = row.custom_data[key];
                        });
                    }

                    newProcessesData[sheet.name].push(process);
                });
            }

            // Update application state
            processesData = newProcessesData;

            const totalProcesses = Object.values(processesData).reduce((total, sheetProcs) => total + sheetProcs.length, 0);
            
            if (welcomeMessageOverlay) {
                if (totalProcesses > 0) {
                    welcomeMessageOverlay.style.display = 'none';
                } else {
                    welcomeMessageOverlay.style.display = 'flex';
                }
            }

            showNotification(`Successfully loaded ${totalProcesses} processes from ${sheets.length} sheet(s).`, 'success');
            console.log(`✅ Loaded ${totalProcesses} processes with status fields from ${sheets.length} sheet(s)`);
            return true;

        } catch (error) {
            console.error('Error loading from multiple sheets:', error);
            showNotification("Error loading data from sheets: " + error.message, 'error');
            return false;
        }
    }

    function updateAddProcessButtonState() {
        document.getElementById('add-process-button').disabled = selectedSheetViews.length !== 1;
    }





    function parseDependencyEntry(depEntry) {
        const entry = String(depEntry).trim();
        if (entry.endsWith('_B')) {
            return { id: entry.slice(0, -2), type: 'blocking' };
        } else if (entry.endsWith('_I')) {
            return { id: entry.slice(0, -2), type: 'informational' };
        }
        return { id: entry, type: 'standard' };
    }

function renderDiagram() {
        if (isSimulationModeActive) {
             applySimulationVisuals(simulatedNewProcessData); return;
        }
        diagramPane.innerHTML = '';
        svgLayer.innerHTML = ''; 
        simulationGhostLayer.innerHTML = '';
        diagramPane.appendChild(svgLayer);
        diagramPane.appendChild(simulationGhostLayer);
        diagramPane.appendChild(linkHandleTrigger);
        if (welcomeMessageOverlay) diagramPane.appendChild(welcomeMessageOverlay);

        hideActionIcons();
        nodeLayouts = {};
        overallDiagramBounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };

        const currentProcesses = getCurrentlyVisibleProcesses(true);
        const allProcessesForLayout = getAllProcessesFromData();

        if (allProcessesForLayout.length === 0 && currentProcesses.length === 0) {
            diagramPane.style.width = '100%';
            diagramPane.style.height = '100%';
            displayProcessDetails(null);
            if (stickyYAxisContainer) stickyYAxisContainer.innerHTML = '';
            if (stickyXAxisContainer) stickyXAxisContainer.innerHTML = '';
            gUniqueDueTimeHours = [];
            if (filterOptionsContainer) filterOptionsContainer.innerHTML = `<p>No data loaded.</p>`;
            drawMiniMap();
            updateMiniMapViewPort();
             if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
            return;
        }
        if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'none';
        
        if (currentProcesses.length === 0 && allProcessesForLayout.length > 0) {
             diagramPane.style.width = '100%';
             diagramPane.style.height = '100%';
             displayProcessDetails(null);
             if (stickyYAxisContainer) stickyYAxisContainer.innerHTML = '';
             if (stickyXAxisContainer) stickyXAxisContainer.innerHTML = '';
             if (filterOptionsContainer) {
                const currentViewDesc = selectedSheetViews.length > 0 ? selectedSheetViews.join(', ') : 'None';
                filterOptionsContainer.innerHTML = `<p>No processes in view: ${currentViewDesc}.</p>`;
             }
             if (welcomeMessageOverlay) welcomeMessageOverlay.style.display = 'flex';
        } else if (welcomeMessageOverlay) {
             welcomeMessageOverlay.style.display = 'none';
        }


        const wdsInDataDisplay = allProcessesForLayout.map(p => p.WD).filter(wd => typeof wd === 'number' && !isNaN(wd));
        let uniqueDataWdsDisplay = [...new Set(wdsInDataDisplay)].sort((a, b) => a - b);
        if (uniqueDataWdsDisplay.length === 0 && allProcessesForLayout.length > 0) {
            const firstWD = allProcessesForLayout[0]?.WD; 
            uniqueDataWdsDisplay.push( (typeof firstWD === 'number' && !isNaN(firstWD)) ? firstWD : 1 );
        } else if (uniqueDataWdsDisplay.length === 0) { 
            uniqueDataWdsDisplay.push(1); 
        }
        gUniqueDataWds = uniqueDataWdsDisplay;
        const numberOfWdColumnsDisplay = gUniqueDataWds.length;

        const minTimeSecDisplay = 0; 
        const maxTimeSecDisplay = 24 * 3600; 
        const numTimeBinsDisplay = Math.ceil(maxTimeSecDisplay / gTimeBinSizeSec);
        gTimeBins = [];
        let totalTimeWeightDisplay = 0;

        for (let i = 0; i < numTimeBinsDisplay; i++) {
            gTimeBins.push({
                startSec: i * gTimeBinSizeSec,
                endSec: (i + 1) * gTimeBinSizeSec - 1,
                count: 0, weight: 1, height: 0, yOffset: 0 
            });
        }

        allProcessesForLayout.forEach(p => {
            const timeValue = parseTime(p["Due time"]);
            if (!isNaN(timeValue)) {
                const binIndex = Math.min(numTimeBinsDisplay - 1, Math.max(0, Math.floor(timeValue / gTimeBinSizeSec))); // Uzupełnienie
                if(gTimeBins[binIndex]) gTimeBins[binIndex].count++;
            }
        });

        gTimeBins.forEach(bin => {
            bin.weight = 1 + bin.count; 
            totalTimeWeightDisplay += bin.weight;
        });

        const baseHeightPerBinDisplay = (NODE_HEIGHT + VERTICAL_NODE_PADDING); 
        let estimatedContentHeightDisplay = 0;
        gTimeBins.forEach(bin => { estimatedContentHeightDisplay += bin.weight * baseHeightPerBinDisplay * 0.2; }); 
        estimatedContentHeightDisplay = Math.max(estimatedContentHeightDisplay, 500); 

        const estimatedMinWdContentWidthDisplay = numberOfWdColumnsDisplay * (NODE_BASE_WIDTH + 30); 

        let diagramClientWidth = diagramContainer.clientWidth;
        let diagramClientHeight = diagramContainer.clientHeight;
        if (document.body.classList.contains('presentation-mode')) { 
            diagramClientWidth = window.innerWidth;
            diagramClientHeight = window.innerHeight - topBarHeight;
        }

        const estimatedDiagramWidthDisplay = Math.max( diagramClientWidth / currentZoom, PADDING * 2 + Y_AXIS_LABEL_WIDTH_ORIGINAL + estimatedMinWdContentWidthDisplay );
        const estimatedDiagramHeightDisplay = Math.max( diagramClientHeight / currentZoom, PADDING * 2 + PADDING + estimatedContentHeightDisplay ); 
        diagramPane.style.width = `${estimatedDiagramWidthDisplay}px`;
        diagramPane.style.height = `${estimatedDiagramHeightDisplay}px`;

        const plotWidthDisplay = Math.max(0, diagramPane.clientWidth - Y_AXIS_LABEL_WIDTH_ORIGINAL - PADDING * 2);
        const plotHeightDisplay = Math.max(0, diagramPane.clientHeight - PADDING * 2); 
        gPlotWidth = plotWidthDisplay;
        gPlotHeight = plotHeightDisplay;
        gWdColumnWidth = numberOfWdColumnsDisplay > 0 ? plotWidthDisplay / numberOfWdColumnsDisplay : plotWidthDisplay; 

        let currentYOffsetDisplay = PADDING; 
        gTimeBins.forEach(bin => {
            bin.height = totalTimeWeightDisplay > 0 ? (bin.weight / totalTimeWeightDisplay) * plotHeightDisplay : (numTimeBinsDisplay > 0 ? plotHeightDisplay / numTimeBinsDisplay : plotHeightDisplay);
            bin.yOffset = currentYOffsetDisplay;
            currentYOffsetDisplay += bin.height;
        });

        const tempNodeLayouts = {}; 

        allProcessesForLayout.forEach(process => { 
            const node = document.createElement('div'); 
            node.className = 'process-node'; 
            node.textContent = process["Short name"];
            
            let nodeWidth = NODE_BASE_WIDTH;
            let nodeHeight = NODE_HEIGHT;
            
            node.style.position = 'absolute'; 
            node.style.visibility = 'hidden'; 
            node.style.left = '-9999px'; 
            document.body.appendChild(node); 
            nodeWidth = node.offsetWidth || NODE_BASE_WIDTH; 
            document.body.removeChild(node);


            const wdValue = process.WD;
            const wdIndex = gUniqueDataWds.indexOf(wdValue);
            let idealXNodeCenter;
            if (wdIndex !== -1) { 
                idealXNodeCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (wdIndex * gWdColumnWidth) + (gWdColumnWidth / 2);
            } else { 
                if (gUniqueDataWds.length > 0) idealXNodeCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (gWdColumnWidth / 2);
                else idealXNodeCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (plotWidthDisplay / 2); 
            }

            const timeValue = parseTime(process["Due time"]);
            let idealYNodeCenter = PADDING + gPlotHeight / 2; 

            if (!isNaN(timeValue) && gTimeBins.length > 0) {
                const binIndex = Math.min(gTimeBins.length - 1, Math.max(0, Math.floor(timeValue / gTimeBinSizeSec)));
                const targetBin = gTimeBins[binIndex];
                if (targetBin) {
                    const timeWithinBin = timeValue - targetBin.startSec;
                    const binDuration = targetBin.endSec - targetBin.startSec + 1; 
                    const relativePosInBin = binDuration > 0 ? timeWithinBin / binDuration : 0.5; 
                    idealYNodeCenter = targetBin.yOffset + relativePosInBin * targetBin.height;
                }
            }

            tempNodeLayouts[process.ID] = {
                process, 
                node: null, 
                idealX: idealXNodeCenter - nodeWidth / 2, 
                idealY: idealYNodeCenter - nodeHeight / 2, 
                finalX: idealXNodeCenter - nodeWidth / 2, 
                finalY: idealYNodeCenter - nodeHeight / 2,
                width: nodeWidth, height: nodeHeight,
                wd: wdValue, time: timeValue 
            };
        });

        const layoutsByWd = Object.values(tempNodeLayouts).reduce((acc, layout) => {
            const wd = layout.wd; 
            if (!acc[wd]) acc[wd] = [];
            acc[wd].push(layout);
            return acc;
        }, {});

        Object.keys(layoutsByWd).forEach(wdKey => {
            const columnLayouts = layoutsByWd[wdKey].sort((a, b) => a.idealY - b.idealY); 
            let lastBottom = -Infinity; 

            columnLayouts.forEach(layout => {
                if (layout.idealY < lastBottom + VERTICAL_NODE_PADDING) {
                    layout.finalY = lastBottom + VERTICAL_NODE_PADDING; 
                } else {
                    layout.finalY = layout.idealY; 
                }
                lastBottom = layout.finalY + layout.height;
            });
        });
        
        nodeLayouts = tempNodeLayouts; 

        currentProcesses.forEach(process => {
            const layout = nodeLayouts[process.ID];
            if (!layout) return; 

            const node = createNodeElement(process, layout); 
            layout.node = node; 

            node.style.position = 'absolute';
            node.style.visibility = 'visible'; 
            node.style.top = `${layout.finalY}px`;
            node.style.left = `${layout.finalX}px`;
            node.classList.add('can-hover'); 

            if (isTreeHighlightActive) { 
                if (!highlightedTreeNodesIds.has(layout.process.ID)) {
                    node.classList.add('tree-highlight-dimmed');
                    node.classList.remove('can-hover');
                }
            } else { 
                if (isProcessFilteredOutByGeneralFilters(layout.process)) {
                     node.classList.add('filtered-out-general'); node.classList.remove('can-hover');
                }
                if (isProcessFilteredOutByAxisFilter(layout.process)) {
                     node.classList.add('filtered-out-axis'); node.classList.remove('can-hover');
                }
            }

            node.addEventListener('click', (e) => {
                if (node.classList.contains('filtered-out-general') ||
                    node.classList.contains('filtered-out-axis') ||
                    node.classList.contains('search-dimmed') ||
                    (isTreeHighlightActive && node.classList.contains('tree-highlight-dimmed') && !highlightedTreeNodesIds.has(layout.process.ID))
                   ) {
                     return;
                   }
                e.stopPropagation(); 
                handleProcessNodeClick(layout.process.ID);
            });

            diagramPane.appendChild(node); 

            overallDiagramBounds.minX = Math.min(overallDiagramBounds.minX, layout.finalX);
            overallDiagramBounds.minY = Math.min(overallDiagramBounds.minY, layout.finalY);

            overallDiagramBounds.maxX = Math.max(overallDiagramBounds.maxX, layout.finalX + layout.width);
            overallDiagramBounds.maxY = Math.max(overallDiagramBounds.maxY, layout.finalY + layout.height);
        });

        if (currentProcesses.length === 0 && overallDiagramBounds.minX === Infinity) { 
             overallDiagramBounds = { minX: 0, minY: 0, maxX: PADDING * 2, maxY: PADDING * 2 };
        } else if (overallDiagramBounds.minX !== Infinity) { 
            overallDiagramBounds.minX -= PADDING;
            overallDiagramBounds.minY -= PADDING;
            overallDiagramBounds.maxX += PADDING;
            overallDiagramBounds.maxY += PADDING;
        }


        gDiagramPanePadding = PADDING; 
        gYAxisLabelWidthOriginal = Y_AXIS_LABEL_WIDTH_ORIGINAL; 

        initializeStickyAxesElements(); 
        requestAnimationFrame(() => { 
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
        });
        applySearchHighlight(searchInput.value); 
        updateMiniMapViewPort(); 
    }

    function initializeStickyAxesElements() {
        if (stickyAxisInitialized) return; 
        if (!stickyYAxisContainer) {
            stickyYAxisContainer = document.createElement('div');
            stickyYAxisContainer.id = 'sticky-y-axis';
            document.body.appendChild(stickyYAxisContainer); 
        }
        if (!stickyXAxisContainer) {
            stickyXAxisContainer = document.createElement('div');
            stickyXAxisContainer.id = 'sticky-x-axis';
            document.body.appendChild(stickyXAxisContainer);
        }
        stickyAxisInitialized = true;
    }

    function updateStickyAxesContainerPositions() {
        if (!stickyAxisInitialized || !stickyYAxisContainer || !stickyXAxisContainer || !diagramContainer) return;
        
        // Batch DOM reads first to avoid forced reflow
        let dcRect, dcStyle;
        if (document.body.classList.contains('presentation-mode')) { 
            dcRect = { top: topBarHeight, left: 0, right: window.innerWidth, bottom: window.innerHeight, width: window.innerWidth, height: window.innerHeight - topBarHeight }; 
            dcStyle = { borderTopWidth: '0px', borderLeftWidth: '0px', borderRightWidth: '0px', borderBottomWidth: '0px' };
        } else { 
            dcRect = diagramContainer.getBoundingClientRect(); 
            dcStyle = window.getComputedStyle(diagramContainer);
        }
        const dcBorderTopWidth = document.body.classList.contains('presentation-mode') ? 0 : (parseFloat(dcStyle.borderTopWidth) || 0);
        const dcBorderLeftWidth = document.body.classList.contains('presentation-mode') ? 0 : (parseFloat(dcStyle.borderLeftWidth) || 0);
        const dcBorderRightWidth = document.body.classList.contains('presentation-mode') ? 0 :(parseFloat(dcStyle.borderRightWidth) || 0);
        const dcBorderBottomWidth = document.body.classList.contains('presentation-mode') ? 0 :(parseFloat(dcStyle.borderBottomWidth) || 0);
        const viewportTop = 0; const viewportLeft = 0; const viewportRight = window.innerWidth; const viewportBottom = window.innerHeight;
        const effectiveDiagramTop = Math.max(viewportTop, dcRect.top + dcBorderTopWidth);
        const effectiveDiagramLeft = Math.max(viewportLeft, dcRect.left + dcBorderLeftWidth);
        const effectiveDiagramRight = Math.min(viewportRight, dcRect.right - dcBorderRightWidth);
        const effectiveDiagramBottom = Math.min(viewportBottom, dcRect.bottom - dcBorderBottomWidth);
        const minVisibleHeightForY = STICKY_X_AXIS_HEIGHT + SCROLLBAR_HEIGHT_ESTIMATE + 20; 
        const minVisibleWidthForX = STICKY_Y_AXIS_WIDTH + 20; 
        const minSpaceForXAxisAndScrollbar = STICKY_X_AXIS_HEIGHT + SCROLLBAR_HEIGHT_ESTIMATE;
        stickyXAxisContainer.style.top = (effectiveDiagramBottom - minSpaceForXAxisAndScrollbar) + 'px';
        stickyXAxisContainer.style.left = (effectiveDiagramLeft + STICKY_Y_AXIS_WIDTH) + 'px';
        stickyXAxisContainer.style.height = STICKY_X_AXIS_HEIGHT + 'px';
        stickyXAxisContainer.style.width = Math.max(0, effectiveDiagramRight - (effectiveDiagramLeft + STICKY_Y_AXIS_WIDTH)) + 'px';
        if (parseFloat(stickyXAxisContainer.style.width) <= 0 || parseFloat(stickyXAxisContainer.style.top) < effectiveDiagramTop || dcRect.bottom < viewportTop + minSpaceForXAxisAndScrollbar || dcRect.top > viewportBottom - minSpaceForXAxisAndScrollbar || dcRect.right < viewportLeft + STICKY_Y_AXIS_WIDTH + 20 || dcRect.left > viewportRight - STICKY_Y_AXIS_WIDTH) { stickyXAxisContainer.style.display = 'none'; } else { stickyXAxisContainer.style.display = 'block'; }
        stickyYAxisContainer.style.top = effectiveDiagramTop + 'px';
        stickyYAxisContainer.style.left = effectiveDiagramLeft + 'px';
        stickyYAxisContainer.style.width = STICKY_Y_AXIS_WIDTH + 'px';
        let yAxisBottomEdge = effectiveDiagramBottom;
        if (stickyXAxisContainer.style.display !== 'none' && parseFloat(stickyXAxisContainer.style.top) > effectiveDiagramTop) { yAxisBottomEdge = Math.min(yAxisBottomEdge, parseFloat(stickyXAxisContainer.style.top)); } else { yAxisBottomEdge = Math.min(yAxisBottomEdge, effectiveDiagramBottom - SCROLLBAR_HEIGHT_ESTIMATE); }
        stickyYAxisContainer.style.height = Math.max(0, yAxisBottomEdge - effectiveDiagramTop) + 'px';
        if (parseFloat(stickyYAxisContainer.style.height) <= 0 || dcRect.bottom < viewportTop + minVisibleHeightForY || dcRect.top > viewportBottom - minVisibleHeightForY || dcRect.right < viewportLeft + minVisibleWidthForX || dcRect.left > viewportRight - minVisibleWidthForX) { stickyYAxisContainer.style.display = 'none'; } else { stickyYAxisContainer.style.display = 'block'; }
    }

    function updateStickyAxesLabels() {
        if (!stickyAxisInitialized || !stickyYAxisContainer || !stickyXAxisContainer || getCurrentlyVisibleProcesses().length === 0 || gUniqueDataWds.length === 0) {
            if(stickyYAxisContainer) stickyYAxisContainer.innerHTML = '';
            if(stickyXAxisContainer) stickyXAxisContainer.innerHTML = '';
            return;
        }
        stickyYAxisContainer.innerHTML = ''; stickyXAxisContainer.innerHTML = '';
        const scrollTop = diagramContainer.scrollTop; const scrollLeft = diagramContainer.scrollLeft;
        // Batch DOM reads to avoid forced reflow
        let dcRect, dcStyle;
        if (document.body.classList.contains('presentation-mode')) { 
            dcRect = { top: topBarHeight, left: 0 }; 
            dcStyle = { borderTopWidth: '0px', borderLeftWidth: '0px' };
        } else { 
            dcRect = diagramContainer.getBoundingClientRect(); 
            dcStyle = window.getComputedStyle(diagramContainer);
        }
        const dcBorderTopWidth = document.body.classList.contains('presentation-mode') ? 0 : (parseFloat(dcStyle.borderTopWidth) || 0);
        const dcBorderLeftWidth = document.body.classList.contains('presentation-mode') ? 0 : (parseFloat(dcStyle.borderLeftWidth) || 0);
        const stickyYContainerViewportTop = parseFloat(stickyYAxisContainer.style.top) || 0;
        const stickyXContainerViewportLeft = parseFloat(stickyXAxisContainer.style.left) || 0;
        const labelHeightEstimate = 18; const yAxisOffset = -7; 
        if (stickyYAxisContainer.style.display !== 'none' && gUniqueDueTimeHours && gUniqueDueTimeHours.length > 0 && gTimeBins.length > 0) {
            const hoursToDisplay = new Set(gUniqueDueTimeHours);
            Array.from(hoursToDisplay).sort((a,b) => a-b).forEach(hour => {
                const timeSec = hour * 3600; let originalLabelYUnzoomed = -1;
                const binIndex = Math.min(gTimeBins.length - 1, Math.max(0, Math.floor(timeSec / gTimeBinSizeSec)));
                if (gTimeBins[binIndex]) { originalLabelYUnzoomed = gTimeBins[binIndex].yOffset; }
                if (originalLabelYUnzoomed !== -1) {
                    const labelAbsoluteYInViewport = (dcRect.top + dcBorderTopWidth) + ((originalLabelYUnzoomed + yAxisOffset) * currentZoom) - scrollTop;
                    const labelTopInStickyContainer = labelAbsoluteYInViewport - stickyYContainerViewportTop;
                    if (labelTopInStickyContainer + labelHeightEstimate > 0 && labelTopInStickyContainer < parseFloat(stickyYAxisContainer.style.height)) {
                        const label = document.createElement('div'); label.className = 'axis y-axis-label';
                        label.textContent = formatTimeForAxis(timeSec); 
                        label.style.position = 'absolute'; label.style.top = labelTopInStickyContainer + 'px'; label.style.left = (STICKY_Y_AXIS_WIDTH - 45) + 'px'; 
                        label.dataset.timeValue = timeSec; 
                        if (currentAxisFilter.type === 'TIME' && currentAxisFilter.value === timeSec) { label.classList.add('active-axis-filter'); } else { label.classList.remove('active-axis-filter'); }
                        label.addEventListener('click', (e) => { e.stopPropagation(); handleAxisLabelClick('TIME', timeSec); });
                        stickyYAxisContainer.appendChild(label);
                    }
                }
            });
        }
        if (stickyXAxisContainer.style.display !== 'none') {
            const labelWidthEstimate = 50;
            gUniqueDataWds.forEach((wd, index) => {
                const originalLabelXCenterUnzoomed = gYAxisLabelWidthOriginal + gDiagramPanePadding + (index * gWdColumnWidth) + (gWdColumnWidth / 2);
                const labelAbsoluteXInDiagramPane = (originalLabelXCenterUnzoomed * currentZoom); 
                const labelVisibleLeftInDC = labelAbsoluteXInDiagramPane - scrollLeft; 
                 const dcScreenLeft = dcRect.left + dcBorderLeftWidth;
                const labelScreenLeft = dcScreenLeft + labelVisibleLeftInDC;
                const labelCenterInStickyContainer = labelScreenLeft - stickyXContainerViewportLeft;
                if (labelCenterInStickyContainer > -labelWidthEstimate / 2 && labelCenterInStickyContainer < parseFloat(stickyXAxisContainer.style.width) + labelWidthEstimate / 2) {
                    const label = document.createElement('div'); label.className = 'axis x-axis-label'; label.textContent = `WD ${wd}`;
                    label.style.position = 'absolute'; label.style.left = labelCenterInStickyContainer + 'px'; label.style.top = '50%'; label.style.transform = 'translate(-50%, -50%)';
                    label.dataset.wdValue = wd;
                    if (currentAxisFilter.type === 'WD' && currentAxisFilter.value === wd) { label.classList.add('active-axis-filter'); } else { label.classList.remove('active-axis-filter'); }
                    label.addEventListener('click', (e) => { e.stopPropagation(); handleAxisLabelClick('WD', wd); });
                    stickyXAxisContainer.appendChild(label);
                }
            });
        }
    }

    function updateWdAxisLabels() {
        console.log('🔄 Updating WD axis labels for:', gUniqueDataWds);
        
        if (!stickyXAxisContainer || stickyXAxisContainer.style.display === 'none') {
            console.log('ℹ️ Sticky X-axis container not visible, skipping update');
            return;
        }
        
        // Clear existing WD labels
        const existingLabels = stickyXAxisContainer.querySelectorAll('.x-axis-label');
        existingLabels.forEach(label => label.remove());
        
        // Get current viewport info
        const dcRect = diagramContainer.getBoundingClientRect();
        const dcBorderLeftWidth = parseFloat(getComputedStyle(diagramContainer).borderLeftWidth) || 0;
        const scrollLeft = diagramContainer.scrollLeft;
        const stickyXContainerViewportLeft = parseFloat(stickyXAxisContainer.style.left) || 0;
        
        // Recreate labels with updated positions
        const labelWidthEstimate = 50;
        gUniqueDataWds.forEach((wd, index) => {
            const originalLabelXCenterUnzoomed = gYAxisLabelWidthOriginal + gDiagramPanePadding + (index * gWdColumnWidth) + (gWdColumnWidth / 2);
            const labelAbsoluteXInDiagramPane = (originalLabelXCenterUnzoomed * currentZoom);
            const labelVisibleLeftInDC = labelAbsoluteXInDiagramPane - scrollLeft;
            const dcScreenLeft = dcRect.left + dcBorderLeftWidth;
            const labelScreenLeft = dcScreenLeft + labelVisibleLeftInDC;
            const labelCenterInStickyContainer = labelScreenLeft - stickyXContainerViewportLeft;
            
            if (labelCenterInStickyContainer > -labelWidthEstimate / 2 && labelCenterInStickyContainer < parseFloat(stickyXAxisContainer.style.width) + labelWidthEstimate / 2) {
                const label = document.createElement('div');
                label.className = 'axis x-axis-label';
                label.textContent = `WD ${wd}`;
                label.style.position = 'absolute';
                label.style.left = labelCenterInStickyContainer + 'px';
                label.style.top = '50%';
                label.style.transform = 'translate(-50%, -50%)';
                label.dataset.wdValue = wd;
                
                if (currentAxisFilter.type === 'WD' && currentAxisFilter.value === wd) {
                    label.classList.add('active-axis-filter');
                } else {
                    label.classList.remove('active-axis-filter');
                }
                
                label.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleAxisLabelClick('WD', wd);
                });
                
                stickyXAxisContainer.appendChild(label);
                // console.log(`📍 Added WD ${wd} label at position ${labelCenterInStickyContainer}px`);
            }
        });
        
        console.log('✅ WD axis labels updated successfully');
    }

    function throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        }
    }

    function shadeColor(color, percent) {
        if (!color || color.length < 4 || color[0] !== '#') return '#cccccc'; 
        let R = parseInt(color.substring(1,3),16);
        let G = parseInt(color.substring(3,5),16);
        let B = parseInt(color.substring(5,7),16);
        R = parseInt(String(R * (100 + percent) / 100));
        G = parseInt(String(G * (100 + percent) / 100));
        B = parseInt(String(B * (100 + percent) / 100));
        R = Math.max(0, Math.min(255, R)); G = Math.max(0, Math.min(255, G)); B = Math.max(0, Math.min(255, B));
        const RR = R.toString(16).padStart(2, '0');
        const GG = G.toString(16).padStart(2, '0');
        const BB = B.toString(16).padStart(2, '0');
        return "#"+RR+GG+BB;
    }

function selectProcess(processId, updateDetails = true) {
    if (isSimulationModeActive) return;
    
    const previouslySelectedId = currentlySelectedProcessId;

    if (isTreeHighlightActive) {
        if (highlightedTreeNodesIds.has(processId)) {
            currentlySelectedProcessId = processId; 
        } else {
            isTreeHighlightActive = false;
            highlightedTreeNodesIds.clear();
            currentlySelectedProcessId = processId;
        }
    } else {
        if (currentlySelectedProcessId === processId) {
            currentlySelectedProcessId = null; 
        } else {
            currentlySelectedProcessId = processId; 
        }
    }

    if (updateDetails && !document.body.classList.contains('presentation-mode')) {
        if (currentlySelectedProcessId) {
            const proc = getCurrentlyVisibleProcesses(true).find(p => p.ID === currentlySelectedProcessId);
            displayProcessDetails(proc);
        } else {
            displayProcessDetails(null); 
        }
    }
    
    refreshDiagramStyles();
    updateAllDependencyAndSimShortcutButtonsState();

    if (previouslySelectedId !== currentlySelectedProcessId && dependencyPanelContainer.classList.contains('visible')) {
        if (currentlySelectedProcessId) {
            generateAndShowDependencyTree(currentlySelectedProcessId);
        } else {
            toggleDependencyPanel(false);
        }
    }
    
    saveStateToLocalStorage(); 
}


    function applySelectionDimming(selectedId) {
        if (isTreeHighlightActive || isSimulationModeActive) return; 

        diagramPane.querySelectorAll('.process-node').forEach(node => {
            const isSelected = node.dataset.id === selectedId;
            const isDependent = node.classList.contains('dependent-input') || node.classList.contains('dependent-output');
            const isFilteredGeneral = node.classList.contains('filtered-out-general');
            const isFilteredAxis = node.classList.contains('filtered-out-axis');
            const isSearchDimmed = node.classList.contains('search-dimmed'); 
            const isSearchHighlight = node.classList.contains('search-highlight'); 

            if (!isSelected && !isDependent && !isFilteredGeneral && !isFilteredAxis && !isSearchDimmed && !isSearchHighlight) {
                 node.classList.add('dimmed-selection');
            } else {
                node.classList.remove('dimmed-selection');
            }
        });
    }

function displayProcessDetails(process) {
    const detailsPanel = document.getElementById('process-details');
    const contentWrapper = document.getElementById('details-content-wrapper');
    const titleText = document.getElementById('details-title-text');

    if (document.body.classList.contains('presentation-mode')) {
        detailsPanel.style.display = 'none';
        return;
    } else {
        detailsPanel.style.display = 'block';
    }

    if (!process) {
        detailsPanel.classList.remove('active', 'expanded');
        titleText.textContent = 'Process Details';
        contentWrapper.innerHTML = '';
        document.getElementById('details-action-buttons').innerHTML = '';
        updateAllDependencyAndSimShortcutButtonsState();
        return;
    }

    if (!detailsPanel.classList.contains('active')) {
         detailsPanel.classList.remove('expanded');
    }
    detailsPanel.classList.add('active');
    
    titleText.textContent = `${process["Short name"]} (ID: ${process.ID})`;

    let html = `<p><strong>Source Sheet:</strong> ${process._sourceSheet || 'N/A'}</p>`;
    const displayedKeys = new Set(["ID", "Short name", "_sourceSheet", "_sheetColorIndex", "_databaseId", "_customData"]);

    // Display standard fields first
    html += `<h4>Standard Fields</h4>`;
    allProcessFields.forEach(fieldInfo => {
        if (process.hasOwnProperty(fieldInfo.jsonKey) && !displayedKeys.has(fieldInfo.jsonKey)) {
            let value = process[fieldInfo.jsonKey];
            html += `<p><strong>${fieldInfo.jsonKey}:</strong> ${value !== null && value !== undefined ? String(value).replace(/\\n/g, '<br>') : 'N/A'}</p>`;
            displayedKeys.add(fieldInfo.jsonKey);
        }
    });

    // Display custom fields with better organization
    if (currentCustomFields && Object.keys(currentCustomFields).length > 0) {
        const customFieldsPresent = Object.keys(currentCustomFields).filter(key => 
            process.hasOwnProperty(key) && !displayedKeys.has(key)
        );
        
        if (customFieldsPresent.length > 0) {
            html += `<h4>Custom Fields</h4>`;
            customFieldsPresent.forEach(key => {
                const fieldConfig = currentCustomFields[key];
                let value = process[key];
                let displayValue = value !== null && value !== undefined ? String(value).replace(/\\n/g, '<br>') : 'N/A';
                
                // Add type information for better understanding
                let typeInfo = '';
                if (fieldConfig && fieldConfig.type) {
                    typeInfo = ` <small>(${fieldConfig.type})</small>`;
                }
                
                html += `<p><strong>${key}${typeInfo}:</strong> ${displayValue}</p>`;
                displayedKeys.add(key);
            });
        }
    }

    // Display any remaining legacy fields
    const legacyFields = Object.keys(process).filter(key => 
        !displayedKeys.has(key) && !key.startsWith('_')
    );
    
    if (legacyFields.length > 0) {
        html += `<h4>Legacy Fields</h4>`;
        legacyFields.forEach(key => {
            let value = process[key];
            html += `<p><strong>${key}:</strong> ${value !== null && value !== undefined ? String(value).replace(/\\n/g, '<br>') : 'N/A'}</p>`;
        });
    }

    contentWrapper.innerHTML = html;
    
    // Dodaj przyciski akcji do osobnego kontenera
    const actionButtonsContainer = document.getElementById('details-action-buttons');
    actionButtonsContainer.innerHTML = `
        <h4>Actions</h4>
        <button class="edit-process-button" onclick="openEditModal('${process.ID}', '${process._sourceSheet || ''}')" title="Edit this process">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
            Edit Process
        </button>
        <button class="simulate-impact-button" id="initiate-simulation-button" title="Simulate the impact of removing or shifting this process">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
            </svg>
            Simulate Impact
        </button>
    `;
    
    updateAllDependencyAndSimShortcutButtonsState();

    const simButtonInstance = document.getElementById('initiate-simulation-button');
    if (simButtonInstance) {
        simButtonInstance.addEventListener('click', openSimulationPanelForSelectedProcess);
    }
}

function openSimulationPanelForSelectedProcess() {
    if (!currentlySelectedProcessId) {
        showNotification("No process selected to simulate.", "warning");
        return;
    }
    const allProcs = getAllProcessesFromData();
    const targetProcess = allProcs.find(p => p.ID === currentlySelectedProcessId);
    if (!targetProcess) {
        showNotification("Selected process data not found for simulation.", "error");
        return;
    }

    simulationTargets = [{
        id: targetProcess.ID,
        sheet: targetProcess._sourceSheet,
        type: 'shift',
        params: {
            wd: targetProcess.WD,
            dueTime: targetProcess["Due time"] || '00:00:00'
        },
        originalData: targetProcess
    }];

    document.getElementById('multi-process-simulation-manager').style.display = 'block';
    document.getElementById('run-simulation-button').textContent = 'Run Simulation';
    document.getElementById('end-simulation-button').style.display = 'none';
    document.getElementById('export-simulation-report-button').style.display = 'none';
    updateSimulationTargetsList();
    toggleSimulationPanel(true);

    if (isTreeHighlightActive) {
        isTreeHighlightActive = false;
        highlightedTreeNodesIds.clear();
        renderDiagramAndRestoreState();
    }
}

function updateSimulationTargetsList() {
    const containerEl = document.getElementById('simulation-targets-list');
    const selectEl = document.getElementById('simulation-add-another-process-select');

    const activeCardElement = containerEl.querySelector('.sim-card.active-card');
    const activeIndex = activeCardElement ? parseInt(activeCardElement.dataset.index, 10) : -1;

    containerEl.innerHTML = '';
    selectEl.innerHTML = '<option value="">- Select a process to add -</option>';

    const allProcs = getAllProcessesFromData();
    const simulatedIds = new Set(simulationTargets.map(t => t.id));

    simulationTargets.forEach((target, index) => {
        const card = document.createElement('div');
        card.className = 'sim-card';

        if ((activeIndex === -1 && index === 0) || activeIndex === index) {
            card.classList.add('active-card');
        }
        card.dataset.index = index;

        const header = document.createElement('div');
        header.className = 'sim-card-header';
        header.innerHTML = `<span class="sim-card-title">${target.originalData["Short name"]} (ID: ${target.id})</span>`;

        const removeBtn = document.createElement('button');
        removeBtn.className = 'sim-card-remove-btn';
        removeBtn.innerHTML = '×';
        removeBtn.title = 'Remove from simulation';
        removeBtn.onclick = (e) => {
            e.stopPropagation();
            simulationTargets.splice(index, 1);
            if (simulationTargets.length === 0) {
                endSimulation();
            } else {
                updateSimulationTargetsList();
                runOrUpdateSimulation();
            }
        };
        header.appendChild(removeBtn);

        header.onclick = () => {
            if (card.classList.contains('active-card')) return;
            document.querySelectorAll('#simulation-targets-list .sim-card').forEach(c => c.classList.remove('active-card'));
            card.classList.add('active-card');
        };

        const controls = document.createElement('div');
        controls.className = 'sim-card-controls';

        const typeGroup = document.createElement('div');
        typeGroup.className = 'sim-type-group';
        ['Shift', 'Remove'].forEach(type => {
            const btn = document.createElement('button');
            btn.textContent = type;
            const typeLower = type.toLowerCase();
            btn.dataset.type = typeLower;
            if (target.type === typeLower) {
                btn.classList.add('active');
            }
            
// NOWA WERSJA (POPRAWIONA)
            btn.onclick = (e) => {
                e.stopPropagation(); // <-- DODANA LINIA: Zapobiega propagacji kliknięcia
                target.type = typeLower;
                // **TYLKO** przebudowujemy interfejs, aby pokazać/ukryć pola.
                // **NIE** uruchamiamy symulacji automatycznie!
                updateSimulationTargetsList(); 
            };
            
            typeGroup.appendChild(btn);
        });

        const paramGroup = document.createElement('div');
        paramGroup.className = 'sim-param-group';
        if (target.type === 'shift') {
            const wdInputId = `sim-wd-input-${index}`;
            const timeInputId = `sim-time-input-${index}`;
            
            paramGroup.innerHTML = `
                <div style="margin-top: 8px;">
                    <label for="${wdInputId}">New WD:</label>
                    <input type="number" id="${wdInputId}" name="${wdInputId}" value="${target.params.wd}" oninput="updateSimTargetParam(${index}, 'wd', this.value)">
                </div>
                <div style="margin-top: 5px;">
                    <label for="${timeInputId}">New Due Time:</label>
                    <input type="text" id="${timeInputId}" name="${timeInputId}" value="${target.params.dueTime || ''}" placeholder="HH:MM:SS" oninput="updateSimTargetParam(${index}, 'dueTime', this.value)">
                </div>
            `;
        }

        controls.appendChild(typeGroup);
        controls.appendChild(paramGroup);
        card.appendChild(header);
        card.appendChild(controls);
        containerEl.appendChild(card);
    });

    allProcs.sort((a, b) => a["Short name"].localeCompare(b["Short name"])).forEach(proc => {
        if (!simulatedIds.has(proc.ID)) {
            const option = document.createElement('option');
            option.value = proc.ID;
            option.dataset.sheet = proc._sourceSheet;
            option.textContent = `${proc['Short name']} (ID: ${proc.ID})`;
            selectEl.appendChild(option);
        }
    });
}

function drawArrow(fromNode, toNode, color, arrowTypeClassesString, dependencyLinkType = 'standard', isImpactPath = false) {
    if (!fromNode || !toNode) return;

    const isSimulatedSource = isSimulationModeActive && (simulationTargets.some(t => t.id === fromNode.dataset.id && (t.type === 'shift' || t.type === 'add')));
    const isSimulatedTarget = isSimulationModeActive && (simulationTargets.some(t => t.id === toNode.dataset.id && (t.type === 'shift' || t.type === 'add')));

    let fromLayout = nodeLayouts[fromNode.dataset.id];
    let toLayout = nodeLayouts[toNode.dataset.id];

    let x1, y1, x2, y2;

    if (isSimulatedSource) {
        const fromRect = fromNode.getBoundingClientRect();
        const diagramRect = diagramContainer.getBoundingClientRect();
        x1 = (fromRect.left - diagramRect.left + diagramContainer.scrollLeft + (fromRect.width / 2)) / currentZoom;
        y1 = (fromRect.top - diagramRect.top + diagramContainer.scrollTop + (fromRect.height / 2)) / currentZoom;
    } else if (fromLayout) {
        x1 = (fromLayout.finalX + fromLayout.width / 2);
        y1 = (fromLayout.finalY + fromLayout.height / 2);
    } else { return; }

    if (isSimulatedTarget) {
        const toRect = toNode.getBoundingClientRect();
        const diagramRect = diagramContainer.getBoundingClientRect();
        x2 = (toRect.left - diagramRect.left + diagramContainer.scrollLeft + (toRect.width / 2)) / currentZoom;
        y2 = (toRect.top - diagramRect.top + diagramContainer.scrollTop + (toRect.height / 2)) / currentZoom;
    } else if (toLayout) {
        x2 = (toLayout.finalX + toLayout.width / 2);
        y2 = (toLayout.finalY + toLayout.height / 2);
    } else { return; }

    const line = document.createElementNS(SVG_NS, 'line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.style.stroke = color;
    
    // Define classes first to avoid reference errors
    const classes = arrowTypeClassesString.split(' ').filter(c => c.trim() !== '');
    
    // Set line style based on dependency type
    if (dependencyLinkType === 'blocking') {
        line.style.strokeWidth = '2px';
        if (!classes.includes('simulation-arrow-broken')) line.style.strokeDasharray = '8,4';
    } else if (dependencyLinkType === 'informational') {
        line.style.strokeWidth = '1px';
        if (!classes.includes('simulation-arrow-broken')) line.style.strokeDasharray = 'none';
    } else {
        line.style.strokeWidth = '2px';
        if (!classes.includes('simulation-arrow-broken')) line.style.strokeDasharray = 'none';
    }
    classes.forEach(cls => line.classList.add(cls));
    if (isImpactPath) {
        line.classList.add('simulation-impact-path-arrow');
    }

    let defs = svgLayer.querySelector('defs');
    if (!defs) {
        defs = document.createElementNS(SVG_NS, 'defs');
        svgLayer.appendChild(defs);
    }

    let markerId = 'arrowhead';
    if(isImpactPath) markerId = 'arrowhead-impact';

    let marker = defs.querySelector('#' + markerId);
    if (!marker) {
        marker = document.createElementNS(SVG_NS, 'marker');
        marker.setAttribute('id', markerId);
        marker.setAttribute('viewBox', '0 0 10 10');
        marker.setAttribute('refX', '8');
        marker.setAttribute('refY', '5');
        marker.setAttribute('markerUnits', 'strokeWidth');
        marker.setAttribute('markerWidth', isImpactPath ? '10' : '8');
        marker.setAttribute('markerHeight', isImpactPath ? '8' : '6');
        marker.setAttribute('orient', 'auto');
        const path = document.createElementNS(SVG_NS, 'path');
        path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
        path.style.fill = 'currentColor';
        marker.appendChild(path);
        defs.appendChild(marker);
    }

    line.style.color = color;
    line.setAttribute('marker-end', `url(#${markerId})`);

    svgLayer.appendChild(line);

    // Add animated elements based on dependency type
    if (!isImpactPath && !classes.includes('simulation-arrow-broken')) {
        if (dependencyLinkType === 'blocking') {
            // Animated rectangles for blocking dependencies
            const flowRect = document.createElementNS(SVG_NS, 'rect');
            flowRect.setAttribute('width', '4');
            flowRect.setAttribute('height', '2');
            flowRect.setAttribute('x', '-2');
            flowRect.setAttribute('y', '-1');
            flowRect.classList.add('flow-rect');
            flowRect.style.fill = color;

            const animateMotion = document.createElementNS(SVG_NS, 'animateMotion');
            animateMotion.setAttribute('dur', '2.5s');
            animateMotion.setAttribute('repeatCount', 'indefinite');
            animateMotion.setAttribute('path', `M${x1},${y1} L${x2},${y2}`);

            flowRect.appendChild(animateMotion);
            svgLayer.appendChild(flowRect);
        } else if (dependencyLinkType === 'standard') {
            // Animated circles for standard dependencies (original behavior)
            const flowDot = document.createElementNS(SVG_NS, 'circle');
            flowDot.setAttribute('r', '2.5');
            flowDot.classList.add('flow-dot');
            flowDot.style.fill = color;

            const animateMotion = document.createElementNS(SVG_NS, 'animateMotion');
            animateMotion.setAttribute('dur', '3s');
            animateMotion.setAttribute('repeatCount', 'indefinite');
            animateMotion.setAttribute('path', `M${x1},${y1} L${x2},${y2}`);

            flowDot.appendChild(animateMotion);
            svgLayer.appendChild(flowDot);
        }
        // For 'informational' type - no animation (no elements added)
    }
}

    function populateFilterPanel() {
        filterOptionsContainer.innerHTML = '';
        const currentProcesses = getCurrentlyVisibleProcesses();
        if (currentProcesses.length === 0) {
            const currentViewDesc = selectedSheetViews.length > 0 ? selectedSheetViews.join(', ') : 'None';
            filterOptionsContainer.innerHTML = `<p>No data in view ${currentViewDesc} to filter.</p>`;
            return;
        }
        const filterableKeys = new Set();
        currentProcesses.forEach(process => { Object.keys(process).forEach(key => { if (!excludedFilterKeys.has(key) && key !== '_sourceSheet' && key !== '_sheetColorIndex') { filterableKeys.add(key); } }); });
        if (filterableKeys.size === 0) { filterOptionsContainer.innerHTML = '<p>No filterable fields found for current view.</p>'; return; }
        Array.from(filterableKeys).sort().forEach(key => {
            const group = document.createElement('div'); group.className = 'filter-item-group';
            const label = document.createElement('label'); label.htmlFor = `filter-${key}`; label.textContent = key + ':'; group.appendChild(label);
            if (key === "Due time") {
                const fromLabel = document.createElement('label'); fromLabel.textContent = "From:"; fromLabel.style.fontWeight = 'normal'; fromLabel.style.fontSize = '0.9em';
                const timeInputFrom = document.createElement('input'); timeInputFrom.type = "time"; timeInputFrom.id = `filter-${key}-from`; timeInputFrom.dataset.filterKey = key; timeInputFrom.step = 1; timeInputFrom.addEventListener('change', handleTemporaryFilterChange); group.appendChild(fromLabel); group.appendChild(timeInputFrom);
                const toLabel = document.createElement('label'); toLabel.textContent = "To:"; toLabel.style.fontWeight = 'normal'; toLabel.style.fontSize = '0.9em';
                const timeInputTo = document.createElement('input'); timeInputTo.type = "time"; timeInputTo.id = `filter-${key}-to`; timeInputTo.dataset.filterKey = key; timeInputTo.step = 1; timeInputTo.addEventListener('change', handleTemporaryFilterChange); group.appendChild(toLabel); group.appendChild(timeInputTo);
            } else {
                const uniqueValues = [...new Set( currentProcesses.flatMap(p => { const val = p[key]; if (multiSelectFilterKeys.has(key) && typeof val === 'string' && val.includes(',')) { return val.split(',').map(s => String(s).trim()).filter(s => s); } return val; }).filter(val => val !== null && val !== undefined && String(val).trim() !== '' && String(val).toLowerCase() !== 'nan') )].sort((a,b) => { if (key === "WD") return Number(a) - Number(b); return String(a).localeCompare(String(b)); });
                if (uniqueValues.length > 0) {
                    const select = document.createElement('select'); select.id = `filter-${key}`; select.dataset.filterKey = key;
                    if (multiSelectFilterKeys.has(key) || key === "Process Type") { select.multiple = true; }
                    const defaultOption = document.createElement('option'); defaultOption.value = ""; defaultOption.textContent = `All ${key}s`;
                    if (!select.multiple) select.appendChild(defaultOption);
                    uniqueValues.forEach(value => { const option = document.createElement('option'); option.value = value; option.textContent = value; select.appendChild(option); });
                    select.addEventListener('change', handleTemporaryFilterChange); group.appendChild(select);
                } else { group.appendChild(document.createTextNode('No unique values for this filter.')); }
            }
            filterOptionsContainer.appendChild(group);
        });
    }

    function handleTemporaryFilterChange(event) {
        const key = event.target.dataset.filterKey;
        if (key === "Due time") {
            const fromVal = document.getElementById(`filter-${key}-from`).value; const toVal = document.getElementById(`filter-${key}-to`).value;
            if (fromVal || toVal) { temporaryActiveFilters[key] = { from: fromVal || null, to: toVal || null }; } else { delete temporaryActiveFilters[key]; }
        } else if (event.target.multiple) {
            const selectedValues = Array.from(event.target.selectedOptions).map(opt => opt.value).filter(val => val !== "");
            if (selectedValues.length > 0) { temporaryActiveFilters[key] = selectedValues; } else { delete temporaryActiveFilters[key]; }
        } else {
            const value = event.target.value;
            if (value === "") { delete temporaryActiveFilters[key]; } else { temporaryActiveFilters[key] = value; }
        }
    }

    function applyGeneralFilters() {
        if (isSimulationModeActive) endSimulation();
        isTreeHighlightActive = false;
        highlightedTreeNodesIds.clear();
        svgLayer.innerHTML = '';
        simulationGhostLayer.innerHTML = '';

        currentAppliedFilters = { ...temporaryActiveFilters };
        currentAxisFilter = { type: null, value: null, valueEnd: null }; 
        currentlySelectedProcessId = null; 

        resetVisualStates(); 
        renderDiagram(); 
        filterPanel.classList.remove('open');
        saveStateToLocalStorage();
    }

    function isProcessFilteredOutByGeneralFilters(process) {
        for (const key in currentAppliedFilters) {
            let processValue = process[key]; 
            let filterValue = currentAppliedFilters[key]; 

            if (processValue === null || processValue === undefined || String(processValue).toLowerCase() === 'nan') {
                processValue = ''; 
            }

            if (key === "Due time" && typeof filterValue === 'object' && filterValue !== null) {
                const processTimeSec = parseTime(String(processValue));
                if (isNaN(processTimeSec) && (filterValue.from || filterValue.to)) {
                    return true;
                }
                if (!filterValue.from && !filterValue.to) {
                    continue;
                }

                const filterFromSec = filterValue.from ? parseTime(filterValue.from) : -Infinity;
                const filterToSec = filterValue.to ? parseTime(filterValue.to) : Infinity;

                if (!(processTimeSec >= filterFromSec && processTimeSec <= filterToSec)) {
                    return true;
                }
            }
            else if (Array.isArray(filterValue)) {
                let actualProcessValuesForComparison;
                if (typeof processValue === 'string' && processValue.includes(',')) {
                    actualProcessValuesForComparison = processValue.split(',').map(s => String(s).trim()).filter(s => s); 
                } else {
                    actualProcessValuesForComparison = [String(processValue).trim()];
                }

                if (actualProcessValuesForComparison.length === 1 && actualProcessValuesForComparison[0] === '' && filterValue.length > 0 && !filterValue.includes('')) {
                    return true;
                }

                const matchFound = filterValue.some(fv_from_filter_array =>
                    actualProcessValuesForComparison.includes(String(fv_from_filter_array).trim())
                );

                if (!matchFound) {
                    return true;
                }
            }
            else {
                const normalizedProcessValue = String(processValue).trim();
                const normalizedFilterValue = String(filterValue).trim();

                if (normalizedProcessValue !== normalizedFilterValue) {
                    return true;
                }
            }
        }
        return false; 
    }

    function isProcessFilteredOutByAxisFilter(process) {
        if (!currentAxisFilter.type) return false;
        if (currentAxisFilter.type === 'WD') { return process.WD !== currentAxisFilter.value; }
        if (currentAxisFilter.type === 'TIME') {
            const processTimeSec = parseTime(process["Due time"]); if (isNaN(processTimeSec)) return true; 
            return !(processTimeSec >= currentAxisFilter.value && processTimeSec <= currentAxisFilter.valueEnd);
        }
        return false;
    }

    function handleAxisLabelClick(type, value) {
        if (isSimulationModeActive) endSimulation();
        isTreeHighlightActive = false; 
        highlightedTreeNodesIds.clear();
        svgLayer.innerHTML = ''; 
        simulationGhostLayer.innerHTML = '';

        if (currentlySelectedProcessId) { 
            clearSelectionHighlightsAndDimming();
            currentlySelectedProcessId = null;
            displayProcessDetails(null);
            hideActionIcons();
        }

        let previousAxisFilterType = currentAxisFilter.type; let previousAxisFilterValue = currentAxisFilter.value;
        if (currentAxisFilter.type === type && currentAxisFilter.value === value) {
            currentAxisFilter = { type: null, value: null, valueEnd: null }; 
        } else {
            if (type === 'TIME') {
                const hourStartSec = value; const hourEndSec = hourStartSec + (gTimeBinSizeSec > 0 ? gTimeBinSizeSec -1 : 3599) ; 
                currentAxisFilter = { type, value: hourStartSec, valueEnd: hourEndSec };
            } else { 
                currentAxisFilter = { type, value, valueEnd: null };
            }
        }
        if (currentAxisFilter.type !== previousAxisFilterType || currentAxisFilter.value !== previousAxisFilterValue) {
            temporaryActiveFilters = {}; currentAppliedFilters = {};
            if (filterOptionsContainer) { filterOptionsContainer.querySelectorAll('select, input[type="time"]').forEach(input => { if (input.tagName === 'SELECT' && input.multiple) { Array.from(input.options).forEach(option => option.selected = false); } else { input.value = ""; } }); }
        }
        renderDiagram(); 
        saveStateToLocalStorage();
    }

    function openAddModal() {
        if (isSimulationModeActive) endSimulation();
        if (!currentSheetId) {
            showNotification("No sheet context available. Please access through project manager.", "warning");
            return;
        }
        
        const targetSheet = currentSheetData ? currentSheetData.name : 'Current Sheet';
        modalTitle.textContent = `Add New Process to Sheet: ${targetSheet}`;
        document.getElementById('process-edit-id').value = ''; 
        // Store original sheet in a data attribute for internal logic
        document.getElementById('process-edit-id').dataset.originalSheet = targetSheet; 

        // Hide sheet selector (we're working with a specific sheet)
        const targetSheetSelector = document.getElementById('process-target-sheet-modal');
        if (targetSheetSelector) {
            targetSheetSelector.style.display = 'none';
        }

        // Clear dynamic fields and validation errors
        dynamicFieldsContainer.innerHTML = '';
        clearModalValidationErrors();
        
        // Set default values for standard fields
        allProcessFields.forEach(f => {
            const el = document.getElementById(`process-${f.idSuffix}`);
            if (el) {
                el.value = ''; 
                el.readOnly = false; 
                if (f.jsonKey === "ID") { el.value = `PROC_${Date.now()}`; } 
                if (f.jsonKey === "WD" && f.type === "number") el.value = '1'; 
                if (f.jsonKey === "Due time" && f.type === "custom-time") el.value = '00:00:00'; 
                if (f.jsonKey === "Process Type" && el.tagName === 'SELECT') el.value = f.default || 'standard';
            }
        });

        // Generate custom fields from current sheet
        generateCustomFieldsForModal();
        
        deleteProcessButton.style.display = 'none'; 
        modal.style.display = 'block';
    }

    // Generate custom fields dynamically based on current sheet's custom_fields
    function generateCustomFieldsForModal(processData = null) {
        if (!currentCustomFields || Object.keys(currentCustomFields).length === 0) {
            return;
        }

        Object.keys(currentCustomFields).forEach(fieldName => {
            const fieldConfig = currentCustomFields[fieldName];
            const fieldContainer = document.createElement('div');
            fieldContainer.className = 'custom-field-container';
            
            const label = document.createElement('label');
            label.textContent = `${fieldName}:`;
            label.htmlFor = `custom-field-${fieldName}`;
            
            let inputElement;
            
            // Create input based on field type
            switch (fieldConfig.type) {
                case 'text':
                case 'string':
                    inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.value = processData ? (processData[fieldName] || '') : (fieldConfig.default || '');
                    break;
                case 'textarea':
                    inputElement = document.createElement('textarea');
                    inputElement.rows = 3;
                    inputElement.value = processData ? (processData[fieldName] || '') : (fieldConfig.default || '');
                    break;
                case 'number':
                    inputElement = document.createElement('input');
                    inputElement.type = 'number';
                    inputElement.value = processData ? (processData[fieldName] || '') : (fieldConfig.default || '');
                    break;
                case 'select':
                    inputElement = document.createElement('select');
                    if (fieldConfig.options && Array.isArray(fieldConfig.options)) {
                        fieldConfig.options.forEach(option => {
                            const optionElement = document.createElement('option');
                            optionElement.value = option;
                            optionElement.textContent = option;
                            inputElement.appendChild(optionElement);
                        });
                    }
                    inputElement.value = processData ? (processData[fieldName] || '') : (fieldConfig.default || '');
                    break;
                case 'date':
                    inputElement = document.createElement('input');
                    inputElement.type = 'date';
                    inputElement.value = processData ? (processData[fieldName] || '') : (fieldConfig.default || '');
                    break;
                case 'email':
                    inputElement = document.createElement('input');
                    inputElement.type = 'email';
                    inputElement.value = processData ? (processData[fieldName] || '') : (fieldConfig.default || '');
                    break;
                default:
                    inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.value = processData ? (processData[fieldName] || '') : (fieldConfig.default || '');
            }
            
            inputElement.id = `custom-field-${fieldName}`;
            inputElement.dataset.customField = fieldName;
            
            // Add required attribute if field is required
            if (fieldConfig.required) {
                inputElement.required = true;
                label.textContent = `${fieldName}*:`;
            }
            
            const errorSpan = document.createElement('span');
            errorSpan.className = 'error-message';
            errorSpan.id = `error-custom-field-${fieldName}`;
            
            fieldContainer.appendChild(label);
            fieldContainer.appendChild(inputElement);
            fieldContainer.appendChild(errorSpan);
            dynamicFieldsContainer.appendChild(fieldContainer);
        });
    }

    function openEditModal(processId, sourceSheetHint) {
        if (isSimulationModeActive) endSimulation();
        let process; let actualSourceSheet = sourceSheetHint;

        if (!actualSourceSheet || actualSourceSheet === 'Multiple' || !processesData[actualSourceSheet]) {
            for (const sheetName of allDataSourceSheetNames) { 
                if (processesData[sheetName]) {
                    const found = processesData[sheetName].find(p => p.ID === processId);
                    if (found) { process = found; actualSourceSheet = sheetName; break; }
                }
            }
        } else if (processesData[actualSourceSheet]) { 
            process = processesData[actualSourceSheet].find(p => p.ID === processId);
        }

        if (!process || !actualSourceSheet) { 
            showNotification(`Process ID ${processId} not found for editing.`, 'error'); 
            return; 
        }

        modalTitle.textContent = `Edit Process: ${process["Short name"] || process.ID}`;
        document.getElementById('process-edit-id').value = process.ID;
        // Store original sheet in a data attribute
        document.getElementById('process-edit-id').dataset.originalSheet = actualSourceSheet; 
        
        // Hide sheet selector (we're working with current sheet context)
        const targetSheetSelector = document.getElementById('process-target-sheet-modal');
        if (targetSheetSelector) {
            targetSheetSelector.style.display = 'none';
        }

        // Clear dynamic fields and validation errors
        dynamicFieldsContainer.innerHTML = ''; 
        clearModalValidationErrors();
        
        const handledKeys = new Set();
        
        // Set values for standard fields
        allProcessFields.forEach(f => {
            const el = document.getElementById(`process-${f.idSuffix}`);
            if (el) { 
                const key = f.jsonKey; 
                let value = process[key];
                if (key === "Description") { 
                    el.value = value ? String(value).replace(/\\n/g, '\n') : ''; 
                }
                else if (key === "Process Type" && el.tagName === 'SELECT') { 
                    el.value = value || f.default || 'standard'; 
                }
                else { 
                    el.value = value === 'nan' ? '' : (value === null || value === undefined ? '' : value); 
                }
                handledKeys.add(key);
            }
        });

        // Generate custom fields with process data
        generateCustomFieldsForModal(process);

        // Handle any remaining fields that aren't in custom_fields or standard fields
        Object.keys(process).forEach(key => {
            if (!handledKeys.has(key) && 
                key !== '_sourceSheet' && 
                key !== '_sheetColorIndex' && 
                key !== '_databaseId' && 
                key !== '_customData' &&
                !currentCustomFields.hasOwnProperty(key)) {
                
                const value = process[key]; 
                const fieldContainer = document.createElement('div'); 
                fieldContainer.className = 'legacy-field-container';
                
                const label = document.createElement('label'); 
                label.textContent = `${key} (Legacy):`; 
                label.htmlFor = `legacy-field-${key}`;
                
                let inputElement;
                if (key === "Description" || (typeof value === 'string' && value.length > 60)) { 
                    inputElement = document.createElement('textarea'); 
                    inputElement.value = value ? String(value).replace(/\\n/g, '\n') : ''; 
                    inputElement.rows = 3; 
                }
                else { 
                    inputElement = document.createElement('input'); 
                    inputElement.type = 'text'; 
                    inputElement.value = value === 'nan' ? '' : (value === null || value === undefined ? '' : value); 
                }
                
                inputElement.id = `legacy-field-${key}`; 
                inputElement.dataset.legacyKey = key;
                
                const errorSpan = document.createElement('span'); 
                errorSpan.className = 'error-message'; 
                errorSpan.id = `error-legacy-field-${key}`;
                
                fieldContainer.appendChild(label); 
                fieldContainer.appendChild(inputElement); 
                fieldContainer.appendChild(errorSpan); 
                dynamicFieldsContainer.appendChild(fieldContainer);
            }
        });
        
        deleteProcessButton.style.display = 'inline-block'; 
        modal.style.display = 'block';
    }

    function closeModal() {
        modal.style.display = 'none'; clearModalValidationErrors();
    }

    function clearModalValidationErrors() {
        allProcessFields.forEach(f => {
            const el = document.getElementById(`process-${f.idSuffix}`); const errorEl = document.getElementById(`error-process-${f.idSuffix}`);
           if (el) el.classList.remove('invalid'); if (errorEl) errorEl.textContent = '';
        });
        
        // Clear error for target sheet selector (legacy)
        const targetSheetErrorEl = document.getElementById('error-process-target-sheet-modal');
        if (targetSheetErrorEl) targetSheetErrorEl.textContent = '';
        const targetSheetSelectEl = document.getElementById('process-target-sheet-modal');
        if (targetSheetSelectEl) targetSheetSelectEl.classList.remove('invalid');

        // Clear errors for dynamic fields (including custom fields and legacy fields)
        dynamicFieldsContainer.querySelectorAll('input, textarea, select').forEach(el => { 
            el.classList.remove('invalid'); 
            const errorEl = document.getElementById(`error-${el.id}`); 
            if(errorEl) errorEl.textContent = ''; 
        });
        
        // Clear errors for custom fields specifically
        dynamicFieldsContainer.querySelectorAll('[data-custom-field]').forEach(el => {
            el.classList.remove('invalid');
            const fieldName = el.dataset.customField;
            const errorEl = document.getElementById(`error-custom-field-${fieldName}`);
            if (errorEl) errorEl.textContent = '';
        });
        
        // Clear errors for legacy fields specifically
        dynamicFieldsContainer.querySelectorAll('[data-legacy-key]').forEach(el => {
            el.classList.remove('invalid');
            const fieldKey = el.dataset.legacyKey;
            const errorEl = document.getElementById(`error-legacy-field-${fieldKey}`);
            if (errorEl) errorEl.textContent = '';
        });
    }

    function validateProcessForm(isEditMode) {
        clearModalValidationErrors(); 
        let isValid = true;
        
        const targetSheetForValidation = currentSheetData ? currentSheetData.name : 'Current Sheet';
        const originalSheetForEdit = isEditMode ? document.getElementById('process-edit-id').dataset.originalSheet : null;
        const currentIdBeingEdited = isEditMode ? document.getElementById('process-id-modal').value.trim() : null;


        allProcessFields.forEach(f => {
            const el = document.getElementById(`process-${f.idSuffix}`); const errorEl = document.getElementById(`error-process-${f.idSuffix}`); if (!el || !errorEl) return;
            let value = el.value; 
            if (el.type !== "select-one" && f.type !== "textarea") value = value.trim(); 
            
            if (f.required && (value === null || value === undefined || String(value).trim() === '')) { 
                errorEl.textContent = `${f.jsonKey} is required.`; el.classList.add('invalid'); isValid = false; return; 
            }

            if (f.jsonKey === "ID") {
                const idValue = value.trim();
                if (!/^[a-zA-Z0-9._-]+$/.test(idValue)) { errorEl.textContent = "ID can only contain letters, numbers, '.', '_', '-'."; el.classList.add('invalid'); isValid = false; }
                else if (processesData[targetSheetForValidation]) { 
                    // Check for ID uniqueness in the current sheet
                    let idIsDuplicate = false;
                    if (isEditMode) {
                        // If ID changed, check for duplication
                        if (idValue !== document.getElementById('process-edit-id').value.trim()) {
                             idIsDuplicate = processesData[targetSheetForValidation].some(p => p.ID === idValue);
                        }
                    } else { // Add mode
                        idIsDuplicate = processesData[targetSheetForValidation].some(p => p.ID === idValue);
                    }

                    if (idIsDuplicate) { 
                        errorEl.textContent = `ID "${idValue}" already exists in this sheet. Choose a unique ID.`; 
                        el.classList.add('invalid'); 
                        isValid = false; 
                    }
                }
            }
            if (f.jsonKey === "WD" && value !== '' && isNaN(parseInt(value, 10))) { errorEl.textContent = "WD must be a valid number."; el.classList.add('invalid'); isValid = false; }
            if (f.jsonKey === "Due time") {
                if (value && !/^\d{1,2}:\d{2}(:\d{2})?$/.test(value)) { errorEl.textContent = "Due time format must be HH:MM or HH:MM:SS."; el.classList.add('invalid'); isValid = false; }
                else if (value) { const tempTime = value.includes(':') && value.split(':').length === 2 ? value + ":00" : value; const parsed = parseTime(tempTime); if (isNaN(parsed)) { errorEl.textContent = "Due time is not a valid time (00:00:00 - 23:59:59)."; el.classList.add('invalid'); isValid = false; } }
            }
            if (f.jsonKey === "Dependencies" && value) {
                const depEntries = value.split(',').map(entry => entry.trim()).filter(entry => entry);
                if (depEntries.some(entry => {
                    const parsed = parseDependencyEntry(entry); 
                    return !/^[a-zA-Z0-9._-]+$/.test(parsed.id); 
                })) {
                    errorEl.textContent = "Dependency short names can only contain letters, numbers, '.', '_', '-'. Separate with commas."; el.classList.add('invalid'); isValid = false;
                }
            }
            if (f.jsonKey === "Process Type" && el.tagName === 'SELECT' && !f.options.includes(value)) { 
                 errorEl.textContent = "Invalid Process Type selected."; el.classList.add('invalid'); isValid = false;
            }
        });

        // Validate custom fields
        dynamicFieldsContainer.querySelectorAll('[data-custom-field]').forEach(el => {
            const fieldName = el.dataset.customField;
            const fieldConfig = currentCustomFields[fieldName];
            const errorEl = document.getElementById(`error-custom-field-${fieldName}`);
            
            if (!errorEl) return;
            
            let value = el.value;
            if (el.tagName !== 'TEXTAREA' && el.tagName !== 'SELECT') {
                value = value.trim();
            }
            
            // Check if required field is empty
            if (fieldConfig && fieldConfig.required && (!value || value === '')) {
                errorEl.textContent = `${fieldName} is required.`;
                el.classList.add('invalid');
                isValid = false;
                return;
            }
            
            // Type-specific validation
            if (value && fieldConfig) {
                switch (fieldConfig.type) {
                    case 'number':
                        if (isNaN(parseFloat(value))) {
                            errorEl.textContent = `${fieldName} must be a valid number.`;
                            el.classList.add('invalid');
                            isValid = false;
                        }
                        break;
                    case 'email':
                        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                        if (!emailRegex.test(value)) {
                            errorEl.textContent = `${fieldName} must be a valid email address.`;
                            el.classList.add('invalid');
                            isValid = false;
                        }
                        break;
                    case 'date':
                        if (value && isNaN(Date.parse(value))) {
                            errorEl.textContent = `${fieldName} must be a valid date.`;
                            el.classList.add('invalid');
                            isValid = false;
                        }
                        break;
                }
            }
        });

        return isValid;
    }


    async function saveProcess() {
        const originalProcessIdForEdit = document.getElementById('process-edit-id').value;
        const originalSourceSheet = document.getElementById('process-edit-id').dataset.originalSheet;
        const isEditMode = !!originalProcessIdForEdit;

        const newTargetSheet = currentSheetData ? currentSheetData.name : 'Current Sheet';
        const newProcessIdFromForm = document.getElementById('process-id-modal').value.trim();

        if (!currentSheetId) { 
            showNotification("Cannot save process: No sheet context available.", 'error'); 
            return; 
        }
        if (!validateProcessForm(isEditMode)) return; 

        const newProcessData = {}; const processedKeys = new Set();
        allProcessFields.forEach(f => {
            const el = document.getElementById(`process-${f.idSuffix}`);
            if (el) { const key = f.jsonKey; let val = el.value;
                if (f.type !== "textarea" && f.type !== "custom-time" && el.type !== "select-one") val = val.trim(); 

                if (f.type === "number" && key === "WD") { val = val === '' ? 1 : parseInt(val, 10); } 
                else if (f.type === "custom-time" && key === "Due time") { if (val && val.includes(':') && val.split(':').length === 2) val += ":00"; } 
                else if (key === "Description") { val = String(val).replace(/\r\n|\r|\n/g, '\\n'); } 
                else if (key === "Process Type" && el.tagName === 'SELECT') { /* val is already correct from el.value */ }
                else { val = val === '' ? '' : val; } 
                newProcessData[key] = val; processedKeys.add(key);
            }
        });
        if (typeof newProcessData.WD !== 'number' || isNaN(newProcessData.WD)) newProcessData.WD = 1;
        if (!newProcessData["Process Type"]) newProcessData["Process Type"] = "standard"; 
        newProcessData.ID = newProcessIdFromForm;

        // Handle custom fields
        dynamicFieldsContainer.querySelectorAll('[data-custom-field]').forEach(el => {
            const key = el.dataset.customField; 
            let value = el.value;
            if (el.tagName === 'TEXTAREA') { 
                value = String(value).replace(/\r\n|\r|\n/g, '\\n'); 
            }
            else { 
                value = value.trim(); 
            } 
            newProcessData[key] = value === '' ? '' : value; 
            processedKeys.add(key);
        });

        // Handle legacy fields
        dynamicFieldsContainer.querySelectorAll('[data-legacy-key]').forEach(el => {
            const key = el.dataset.legacyKey; 
            let value = el.value;
            if (el.tagName === 'TEXTAREA' && key === 'Description') { 
                value = String(value).replace(/\r\n|\r|\n/g, '\\n'); 
            }
            else { 
                value = value.trim(); 
            } 
            newProcessData[key] = value === '' ? '' : value; 
            processedKeys.add(key);
        });
        
        let success = false;

        if (isEditMode) {
            // Find original process to preserve database ID and other metadata
            const originalProcess = processesData[newTargetSheet] ? 
                processesData[newTargetSheet].find(p => p.ID === originalProcessIdForEdit) : null;
            
            if (originalProcess && originalProcess._databaseId) {
                newProcessData._databaseId = originalProcess._databaseId;
            }

            // Update in Supabase
            const updateSuccess = await updateProcessInSupabase(newProcessData, newTargetSheet, originalProcessIdForEdit);
            if (updateSuccess) {
                // Update local data
                if (processesData[newTargetSheet]) {
                    const originalIndex = processesData[newTargetSheet].findIndex(p => p.ID === originalProcessIdForEdit);
                    if (originalIndex > -1) {
                        const originalProcessObject = processesData[newTargetSheet][originalIndex];
                        // Preserve any unhandled fields
                        Object.keys(originalProcessObject).forEach(key => { 
                            if (!processedKeys.has(key)) newProcessData[key] = originalProcessObject[key]; 
                        });
                        processesData[newTargetSheet][originalIndex] = newProcessData;
                        success = true;
                        showNotification(`Process "${newProcessData["Short name"] || newProcessData.ID}" updated successfully.`, 'success');
                    }
                }
            }
        } else {
            // Add mode
            const insertSuccess = await saveProcessToSupabase(newProcessData, newTargetSheet);
            if (insertSuccess) {
                // Update local data
                if (!processesData[newTargetSheet]) processesData[newTargetSheet] = [];
                processesData[newTargetSheet].push(newProcessData);
                success = true;
                showNotification(`Process "${newProcessData["Short name"] || newProcessData.ID}" added successfully.`, 'success');
            }
        }
        
        if (success) {
            if (!isEditMode || (isEditMode && originalProcessIdForEdit !== newProcessData.ID) || (isEditMode && originalSourceSheet !== newTargetSheet)) {
                 currentlySelectedProcessId = newProcessData.ID;
            }

            // Update allDataSourceSheetNames if needed
            if (!allDataSourceSheetNames.includes(newTargetSheet)) {
                allDataSourceSheetNames.push(newTargetSheet);
                allDataSourceSheetNames.sort();
            }

            updateGlobalUniqueDueTimeHours(); 
            populateFilterPanel(); 
            renderDiagramAndRestoreState();
            closeModal(); 
            saveStateToLocalStorage();
        }
    }

    async function deleteCurrentProcess() {
        const editId = document.getElementById('process-edit-id').value;
        const sourceSheet = document.getElementById('process-edit-id').dataset.originalSheet; 
        
        if (editId && sourceSheet && confirm(`Delete process with ID: ${editId}?`)) {
            // Find the process to get database ID
            const process = processesData[sourceSheet] ? 
                processesData[sourceSheet].find(p => p.ID === editId) : null;
            
            const databaseId = process && process._databaseId ? process._databaseId : null;
            
            const deleteSuccess = await deleteProcessFromSupabase(editId, sourceSheet, databaseId);
            if (deleteSuccess) {
                // Update local data
                if (processesData[sourceSheet]) { 
                    processesData[sourceSheet] = processesData[sourceSheet].filter(p => p.ID !== editId); 
                }
                updateGlobalUniqueDueTimeHours(); 
                populateFilterPanel(); 
                renderDiagramAndRestoreState();
                closeModal(); 
                saveStateToLocalStorage();
                showNotification(`Process "${editId}" deleted.`, 'info');
            }
        }
    }

    function sanitizeSheetNameForExcel(name) {
        if (!name) return "Sheet"; let sanitized = String(name).replace(/[:\\/?*[\]]/g, '_'); if (sanitized.length > 31) { sanitized = sanitized.substring(0, 31); } return sanitized;
    }

    function exportToXlsx() {
        menuContent.style.display = 'none';
        if (Object.keys(processesData).length === 0) { showNotification("No data loaded to export.", 'warning'); return; }
        const workbook = XLSX.utils.book_new(); let sheetsExported = 0;
        for (const sheetName in processesData) {
            if (processesData.hasOwnProperty(sheetName) && Array.isArray(processesData[sheetName])) {
                const sheetData = processesData[sheetName]; if (sheetData.length === 0) { continue; }
                const dataForSheetExport = sheetData.map(p => { const { _sourceSheet, _sheetColorIndex, ...exportedProcess } = p; if (exportedProcess.Description && typeof exportedProcess.Description === 'string') { exportedProcess.Description = exportedProcess.Description.replace(/\\n/g, '\n'); } if (typeof exportedProcess.WD !== 'number') { const wdNum = parseInt(exportedProcess.WD, 10); exportedProcess.WD = isNaN(wdNum) ? 0 : wdNum; } return exportedProcess; });
                const explicitHeaderOrder = allProcessFields.map(field => field.jsonKey); const allUniqueKeysInSheetData = Array.from(new Set(dataForSheetExport.flatMap(obj => Object.keys(obj)))); const existingExplicitHeaders = explicitHeaderOrder.filter(h => allUniqueKeysInSheetData.includes(h)); const finalHeaders = [ ...existingExplicitHeaders, ...allUniqueKeysInSheetData.filter(k => !existingExplicitHeaders.includes(k)).sort() ];
                let worksheet; if (dataForSheetExport.length > 0 && finalHeaders.length > 0) { worksheet = XLSX.utils.json_to_sheet(dataForSheetExport, { header: finalHeaders }); } else { worksheet = XLSX.utils.json_to_sheet(dataForSheetExport); } 
                XLSX.utils.book_append_sheet(workbook, worksheet, sanitizeSheetNameForExcel(sheetName)); sheetsExported++;
            }
        }
        if (sheetsExported === 0) { showNotification("No valid sheets with data found to export.", 'warning'); return; }
        let baseFilename = "processes_export_multisheet"; if (jsonFileNameSpan.textContent) { baseFilename = jsonFileNameSpan.textContent.replace(/\.json$/i, '').replace(/\.xlsx$/i, '') + "_export"; }
        XLSX.writeFile(workbook, `${sanitizeSheetNameForExcel(baseFilename)}.xlsx`);
        showNotification("XLSX file exported.", 'success');
    }

    diagramContainer.addEventListener('mousedown', (e) => {
        if (e.target === diagramContainer || e.target === diagramPane || e.target === svgLayer) {
            if (e.target.closest('#mini-map-viewport-rect') || e.target.closest('.mini-map-node') ||
                e.target === menuDependencyPanelTrigger || menuDependencyPanelTrigger.contains(e.target) ||
                e.target === linkHandleTrigger || e.target.classList.contains('unlink-handle') ||
                e.target.closest('.process-node') || e.target.closest('.axis')) { 
                return; 
            }
            isPanning = true; diagramContainer.style.cursor = 'grabbing'; 
            panStartX = e.pageX - diagramContainer.offsetLeft; 
            panStartY = e.pageY - diagramContainer.offsetTop; 
            initialScrollLeft = diagramContainer.scrollLeft; 
            initialScrollTop = diagramContainer.scrollTop; 
            e.preventDefault();
        }
    });
    diagramContainer.addEventListener('mousemove', (e) => {
        if (!isPanning || isLinking) return; e.preventDefault(); const x = e.pageX - diagramContainer.offsetLeft; const y = e.pageY - diagramContainer.offsetTop; const dx = x - panStartX; const dy = y - panStartY; diagramContainer.scrollLeft = initialScrollLeft - dx; diagramContainer.scrollTop = initialScrollTop - dy;
    });

    function zoom(factor, event = null) {
        const prevZoom = currentZoom;
        currentZoom = Math.max(0.1, Math.min(5, currentZoom * factor));

        let rect;
        if (document.body.classList.contains('presentation-mode')) {
            rect = { top: topBarHeight, left: 0, width: window.innerWidth, height: window.innerHeight - topBarHeight };
        } else {
            rect = diagramContainer.getBoundingClientRect();
        }

        let mouseX = rect.width / 2;
        let mouseY = rect.height / 2;
        if (event && (event.target === diagramContainer || diagramContainer.contains(event.target))) {
            mouseX = event.clientX - rect.left;
            mouseY = event.clientY - rect.top;
        }

        const scrollX = diagramContainer.scrollLeft;
        const scrollY = diagramContainer.scrollTop;

        const targetScrollLeft = (scrollX + mouseX) * (currentZoom / prevZoom) - mouseX;
        const targetScrollTop = (scrollY + mouseY) * (currentZoom / prevZoom) - mouseY;

        diagramPane.style.transform = `scale(${currentZoom})`;
        diagramContainer.scrollLeft = targetScrollLeft;
        diagramContainer.scrollTop = targetScrollTop;

        requestAnimationFrame(() => {
            updateStickyAxesContainerPositions();
            updateStickyAxesLabels();
            drawMiniMap(); 
            updateMiniMapViewPort(); 
            positionActionIcons(); 
        });

        saveStateToLocalStorage();
    }

async function convertXlsxFileToStructuredJson(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = new Uint8Array(event.target.result);
                const workbook = XLSX.read(data, { type: 'array', cellDates: true });
                
                const validationResult = validateXlsxWorkbook(workbook, expectedDiagramKeys, XLSX_REQUIRED_KEYS);
                if (!validationResult.isValid) {
                    const errorMsg = "XLSX Validation Failed:\n" + validationResult.errors.join("\n");
                    reject({ message: errorMsg, warnings: validationResult.warnings, isValidationError: true });
                    return;
                }
                if (validationResult.warnings.length > 0) {
                    console.warn("XLSX Validation Warnings:", validationResult.warnings);
                }

                const multiSheetJsonData = {};
                let firstSheetDataForPreview = null;

                workbook.SheetNames.forEach((sheetName, index) => {
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonDataFromSheet = XLSX.utils.sheet_to_json(worksheet, { defval: null });

                    if (jsonDataFromSheet.length === 0) {
                        multiSheetJsonData[sheetName] = [];
                        return;
                    }

                    const processedSheetJson = jsonDataFromSheet.map(rowFromSheet => {
                        const newRowObject = {};
                        const excelHeadersInRow = Object.keys(rowFromSheet);

                        expectedDiagramKeys.forEach(expectedKey => {
                            let actualExcelHeader = expectedKey;
                            if (!rowFromSheet.hasOwnProperty(actualExcelHeader)) {
                                const foundHeader = excelHeadersInRow.find(h => h.trim().toLowerCase() === expectedKey.toLowerCase());
                                if (foundHeader) actualExcelHeader = foundHeader;
                            }
                            if (expectedKey === "Due time" && !rowFromSheet.hasOwnProperty(actualExcelHeader)) {
                                 const dueTimeHeaders = ["Due time", "Due Time", "due time"];
                                 for (const dth of dueTimeHeaders) {
                                    if (rowFromSheet.hasOwnProperty(dth)) { actualExcelHeader = dth; break; }
                                    const foundDth = excelHeadersInRow.find(h => h.trim().toLowerCase() === dth.toLowerCase());
                                    if (foundDth) { actualExcelHeader = foundDth; break;}
                                 }
                            }

                            let originalValue = rowFromSheet[actualExcelHeader];
                            let processedValue;

                            if (originalValue === null || originalValue === undefined || String(originalValue).trim() === "") {
                                processedValue = (expectedKey === "WD") ? 1 : "";
                                if (expectedKey === "Due time") processedValue = "";
                                if (expectedKey === "Process Type") processedValue = "standard";
                            } else if (expectedKey === "Due time") {
                                let timeStr = String(originalValue).trim();
                                if (typeof originalValue === 'number' && originalValue >= 0 && originalValue < 1) {
                                    const excelEpoch = new Date(Date.UTC(1899, 11, 30)); 
                                    const dateFromExcel = new Date(excelEpoch.getTime() + originalValue * 24 * 60 * 60 * 1000);
                                    const hours = dateFromExcel.getUTCHours();
                                    const minutes = dateFromExcel.getUTCMinutes();
                                    const seconds = dateFromExcel.getUTCSeconds();
                                    processedValue = String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
                                } else if (/^(\d{1,2}):(\d{2})(:(\d{2}))?$/.test(timeStr)) {
                                    const parts = timeStr.match(/^(\d{1,2}):(\d{2})(:(\d{2}))?$/);
                                                                        const h = String(parts[1]).padStart(2, '0');
                                    const m = String(parts[2]).padStart(2, '0');
                                    const s = parts[4] ? String(parts[4]).padStart(2, '0') : '00';
                                    processedValue = `${h}:${m}:${s}`;
                                } else {
                                    processedValue = "";
                                }
                            } else if (expectedKey === "Description") {
                                processedValue = String(originalValue).replace(/\r\n|\r|\n/g, '\\n');
                            } else if (expectedKey === "WD") {
                                            const numWD = parseInt(String(originalValue), 10);
            processedValue = isNaN(numWD) ? 1 : (numWD === 0 ? 1 : numWD);
                            } else if (expectedKey === "Process Type") {
                                let ptValue = String(originalValue).trim().toLowerCase();
                                if (["standard", "blocking", "informational"].includes(ptValue)) {
                                    processedValue = ptValue;
                                } else {
                                    processedValue = "standard";
                                }
                            }
                             else {
                                processedValue = String(originalValue).trim();
                            }
                            newRowObject[expectedKey] = processedValue;
                        });

                        if (!newRowObject.hasOwnProperty("Process Type")) {
                            newRowObject["Process Type"] = "standard";
                        }

                        excelHeadersInRow.forEach(excelHeader => {
                            if (excelHeader.startsWith("__EMPTY")) return;
                            const trimmedExcelHeader = excelHeader.trim();
                            let isExpectedAlready = expectedDiagramKeys.some(ek => ek.toLowerCase() === trimmedExcelHeader.toLowerCase());
                            
                            if (!isExpectedAlready && !newRowObject.hasOwnProperty(trimmedExcelHeader)) {
                                const originalValue = rowFromSheet[excelHeader];
                                let processedValue;
                                if (originalValue === null || originalValue === undefined || String(originalValue).trim() === "") {
                                    processedValue = "";
                                } else {
                                    processedValue = String(originalValue).trim();
                                }
                                newRowObject[trimmedExcelHeader] = processedValue;
                            }
                        });
                        return newRowObject;
                    });
                    multiSheetJsonData[sheetName] = processedSheetJson;
                    if (index === 0) {
                        firstSheetDataForPreview = processedSheetJson;
                    }
                });
                resolve({ multiSheetJsonData, firstSheetDataForPreview, warnings: validationResult.warnings });
            } catch (error) {
                reject(error); 
            }
        };
        reader.onerror = (error) => reject(error);
        reader.readAsArrayBuffer(file);
    });
}

function validateXlsxWorkbook(workbook, allExpectedKeys, requiredKeysSet) {
    let errors = [];
    let warnings = [];
    let isValid = true;

    workbook.SheetNames.forEach(sheetName => {
        const worksheet = workbook.Sheets[sheetName];
        const jsonDataFromSheet = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null }); 

        if (!jsonDataFromSheet || jsonDataFromSheet.length === 0) {
            warnings.push(`Sheet "${sheetName}" is empty or unreadable.`);
            return; 
        }

        const headerRow = jsonDataFromSheet[0].map(h => String(h || "").trim());
        const headerRowLower = headerRow.map(h => h.toLowerCase());
        const dataRows = jsonDataFromSheet.slice(1);

        requiredKeysSet.forEach(reqKey => {
            if (!headerRowLower.includes(reqKey.toLowerCase())) {
                errors.push(`Sheet "${sheetName}": Missing required column: "${reqKey}".`);
                isValid = false;
            }
        });

        allExpectedKeys.forEach(expKey => {
            if (!requiredKeysSet.has(expKey) && !headerRowLower.includes(expKey.toLowerCase())) {
                warnings.push(`Sheet "${sheetName}": Missing optional column: "${expKey}".`);
            }
        });

        if (dataRows.length > 0) {
            const sampleSize = Math.min(dataRows.length, XLSX_KEY_VALIDATION_SAMPLES);
            for (let i = 0; i < sampleSize; i++) {
                const rowArray = dataRows[i];
                const rowObject = {};
                headerRow.forEach((header, idx) => {
                    rowObject[header] = rowArray[idx];
                });

                const idHeader = headerRow.find(h => h.toLowerCase() === "id");
                if (idHeader && (rowObject[idHeader] === null || String(rowObject[idHeader]).trim() === "")) {
                    errors.push(`Sheet "${sheetName}", Row ${i + 2}: Column "ID" cannot be empty.`);
                    isValid = false;
                }

                const wdHeader = headerRow.find(h => h.toLowerCase() === "wd");
                if (wdHeader && rowObject[wdHeader] !== null && isNaN(parseInt(rowObject[wdHeader], 10))) {
                    errors.push(`Sheet "${sheetName}", Row ${i + 2}: Column "WD" ("${rowObject[wdHeader]}") is not a valid number.`);
                    isValid = false;
                }
                
                const dueTimeHeader = headerRow.find(h => h.toLowerCase() === "due time");
                if (dueTimeHeader && rowObject[dueTimeHeader] !== null && String(rowObject[dueTimeHeader]).trim() !== "") {
                    let timeStr = String(rowObject[dueTimeHeader]).trim();
                    let validTimeFormat = false;
                    if (typeof rowObject[dueTimeHeader] === 'number' && rowObject[dueTimeHeader] >= 0 && rowObject[dueTimeHeader] < 1) {
                       validTimeFormat = true; 
                    } else if (/^(\d{1,2}):(\d{2})(:(\d{2}))?$/.test(timeStr)) {
                       validTimeFormat = true; 
                    }
                    if (!validTimeFormat) {
                         errors.push(`Sheet "${sheetName}", Row ${i + 2}: Column "Due time" ("${timeStr}") has an unrecognized format. Expected HH:MM:SS or Excel time number.`);
                         isValid = false;
                    }
                }
            }
        }
    });
    return { isValid, errors, warnings };
}

async function handleConvertXlsxToJson() {
    menuContent.style.display = 'none';
    if (!xlsxFileInputConverter.files || xlsxFileInputConverter.files.length === 0) {
        converterStatusDiv.textContent = 'Please select an XLSX file.';
        converterStatusDiv.style.color = 'red';
        showNotification("Please select an XLSX file for conversion.", "warning");
        return;
    }
    const file = xlsxFileInputConverter.files[0];
    converterStatusDiv.innerHTML = 'Processing file for download...'; 
    converterStatusDiv.style.color = 'orange';
    convertButtonConverter.disabled = true;
    convertAndLoadButtonConverter.disabled = true;
    converterJsonPreview.textContent = '';

    try {
        const { multiSheetJsonData, firstSheetDataForPreview, warnings } = await convertXlsxFileToStructuredJson(file);

        let statusMessage = "";
        if (warnings && warnings.length > 0) {
            statusMessage += "<strong>Validation Warnings:</strong><br><pre>" + warnings.join("\n") + "</pre><br>";
        }

        if (Object.keys(multiSheetJsonData).length === 0) {
            statusMessage += 'No data found in any sheets.';
            converterStatusDiv.innerHTML = statusMessage;
            converterStatusDiv.style.color = 'red';
            showNotification("XLSX Conversion: No data found in any sheets.", "error");
            return;
        }

        const jsonString = JSON.stringify(multiSheetJsonData, null, 2);
        downloadJson(jsonString, 'processes_multisheet_converted.json');
        statusMessage += 'Conversion complete! Multi-sheet JSON downloaded.';
        converterStatusDiv.innerHTML = statusMessage;
        converterStatusDiv.style.color = 'green';
        showNotification("XLSX converted and JSON downloaded.", "success");
        if (firstSheetDataForPreview) {
             converterJsonPreview.textContent = JSON.stringify(firstSheetDataForPreview.slice(0, 3), null, 2);
        }
    } catch (error) {
        let errorMessageToShow = error.message || "An unknown error occurred during conversion.";
        if (error.isValidationError && error.warnings && error.warnings.length > 0) {
             errorMessageToShow += "\n\nAdditionally, there were warnings:\n" + error.warnings.join("\n");
        }
        converterStatusDiv.innerHTML = `<strong>Error:</strong><br><pre>${errorMessageToShow}</pre>`;
        converterStatusDiv.style.color = 'red';
        showNotification("Error during XLSX conversion. See converter panel for details.", "error", 0);
    } finally {
        convertButtonConverter.disabled = false;
        convertAndLoadButtonConverter.disabled = false;
        if (xlsxFileInputConverter) { xlsxFileInputConverter.value = null; }
    }
}

async function handleConvertAndLoadXlsxToDiagram() {
    if (isSimulationModeActive) endSimulation();
    menuContent.style.display = 'none';
    if (!xlsxFileInputConverter.files || xlsxFileInputConverter.files.length === 0) {
        converterStatusDiv.textContent = 'Please select an XLSX file to load.';
        converterStatusDiv.style.color = 'red';
        showNotification("Please select an XLSX file to convert and load.", "warning");
        return;
    }
    const file = xlsxFileInputConverter.files[0];
    converterStatusDiv.innerHTML = 'Processing and loading file to diagram...';
    converterStatusDiv.style.color = 'orange';
    convertButtonConverter.disabled = true;
    convertAndLoadButtonConverter.disabled = true;
    converterJsonPreview.textContent = '';

    try {
        const { multiSheetJsonData, firstSheetDataForPreview, warnings } = await convertXlsxFileToStructuredJson(file);

        let statusMessage = "";
        if (warnings && warnings.length > 0) {
            statusMessage += "<strong>Validation Warnings (data still loaded):</strong><br><pre>" + warnings.join("\n") + "</pre><br>";
        }

        if (Object.keys(multiSheetJsonData).length === 0) {
            statusMessage += 'No data found in any sheets to load.';
            converterStatusDiv.innerHTML = statusMessage;
            converterStatusDiv.style.color = 'red';
            showNotification("XLSX Conversion: No data found in any sheets to load.", "error");
            return;
        }

        processAndLoadJsonData(multiSheetJsonData, file.name);
        statusMessage += 'Conversion and loading complete!';
        converterStatusDiv.innerHTML = statusMessage;
        converterStatusDiv.style.color = 'green';
         if (firstSheetDataForPreview) {
             converterJsonPreview.textContent = JSON.stringify(firstSheetDataForPreview.slice(0, 3), null, 2);
        }
        converterPanel.classList.remove('open');
    } catch (error) {
        let errorMessageToShow = error.message || "An unknown error occurred during conversion and loading.";
         if (error.isValidationError && error.warnings && error.warnings.length > 0) {
             errorMessageToShow += "\n\nAdditionally, there were warnings (data NOT loaded):\n" + error.warnings.join("\n");
        }
        converterStatusDiv.innerHTML = `<strong>Error (Data NOT Loaded):</strong><br><pre>${errorMessageToShow}</pre>`;
        converterStatusDiv.style.color = 'red';
        showNotification("Error converting/loading XLSX. Data NOT loaded. See converter panel.", "error", 0);
        processAndLoadJsonData({}, ""); 
    } finally {
        convertButtonConverter.disabled = false;
        convertAndLoadButtonConverter.disabled = false;
        if (xlsxFileInputConverter) { xlsxFileInputConverter.value = null; }
    }
}

    function handleLoadFromSharePoint() {
        menuContent.style.display = 'none';
        if (!SHAREPOINT_DOWNLOAD_LINK || SHAREPOINT_DOWNLOAD_LINK === "YOUR_SHAREPOINT_DIRECT_DOWNLOAD_LINK_HERE.xlsx") {
            showNotification("SharePoint download link is not configured. Please contact the administrator.", "error");
            return;
        }

        // Rozpocznij pobieranie pliku z SharePoint
        showNotification("Downloading file from SharePoint...", "info");
        const a = document.createElement('a');
        a.href = SHAREPOINT_DOWNLOAD_LINK;
        a.download = 'sharepoint_processes.xlsx'; // Nadaj konkretną nazwę pliku
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        // Automatycznie otwórz Load Excel interface po krótkim opóźnieniu
        setTimeout(() => {
            // Rozwiń sekcję Load w menu
            const loadHeader = document.getElementById('load-section-toggle');
            const loadContent = document.getElementById('load-section-content');
            if (loadHeader && loadContent && !loadContent.classList.contains('expanded')) {
                loadHeader.click(); // Symuluj kliknięcie żeby rozwinąć
            }
            
            // Pokaż Load Excel section
            showNotification("File downloaded! The Load Excel section is now open. Click 'Choose Excel File' and select 'sharepoint_processes.xlsx' from your Downloads folder.", "success", 12000);
            
            // Opcjonalnie możemy automatycznie przewinąć do Load Excel i otworzyć dialog
            setTimeout(() => {
                const loadExcelSection = document.querySelector('.load-excel-section');
                if (loadExcelSection) {
                    loadExcelSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
                // Automatycznie otwórz dialog wyboru pliku
                setTimeout(() => {
                    const fileInput = document.getElementById('excel-file-input');
                    if (fileInput) {
                        fileInput.click(); // Automatycznie otwórz dialog wyboru pliku
                        showNotification("File dialog opened! Select 'sharepoint_processes.xlsx' from your Downloads folder.", "info", 8000);
                    }
                }, 1000);
            }, 500);
            
        }, 1500); // Daj czas na rozpoczęcie pobierania
    }


    function downloadJson(jsonString, filename) {
        const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    function applySearchHighlight(searchTerm) {
        if (isSimulationModeActive) return;
        const term = searchTerm.toLowerCase().trim();
        let foundAny = false;

        diagramPane.querySelectorAll('.process-node').forEach(node => {
            const procId = node.dataset.id; 

            node.classList.remove('search-highlight', 'search-dimmed');
            node.classList.remove('can-hover'); 

            if (node.classList.contains('filtered-out-general') ||
                node.classList.contains('filtered-out-axis') ||
                (isTreeHighlightActive && node.classList.contains('tree-highlight-dimmed') && !highlightedTreeNodesIds.has(procId))) {
                return; 
            }

            if (!term) {
                if (!node.classList.contains('dimmed-selection') &&
                    !(isTreeHighlightActive && !highlightedTreeNodesIds.has(procId))) {
                    node.classList.add('can-hover');
                }
                return;
            }

            const processData = getAllProcessesFromData().find(p => p.ID === procId && p._sourceSheet === node.dataset.sourceSheet);
            let matchesSearch = false;
            if (processData) {
                const shortName = (processData["Short name"] || "").toLowerCase();
                const idMatch = (processData.ID || "").toLowerCase();
                const description = (processData.Description || "").toLowerCase().replace(/\\n/g, ' ');
                if (idMatch.includes(term) || shortName.includes(term) || description.includes(term)) {
                    matchesSearch = true;
                }
            }

            if (matchesSearch) {
                if (!isTreeHighlightActive || (isTreeHighlightActive && highlightedTreeNodesIds.has(procId))) {
                    node.classList.add('search-highlight');
                    node.classList.add('can-hover'); 
                    foundAny = true;
                } else {
                    node.classList.add('search-dimmed');
                }
            }
        });

        if (term) {
            diagramPane.querySelectorAll('.process-node').forEach(node => {
                if (node.classList.contains('filtered-out-general') ||
                    node.classList.contains('filtered-out-axis') ||
                    node.classList.contains('tree-highlight-dimmed')) {
                    return;
                }

                if (!node.classList.contains('search-highlight')) { 
                    node.classList.add('search-dimmed');
                    node.classList.remove('can-hover');
                }
            });
        }

        if (!isTreeHighlightActive && currentlySelectedProcessId) {
            applySelectionDimming(currentlySelectedProcessId);
        }
        positionActionIcons(); 
    }


    function getRecursiveDependenciesGraph(targetId, type, allProcesses, maxDepth, currentDepth = 0, visited = new Set(), parentNodeId = null) {
        // === POCZĄTEK KLUCZOWYCH POPRAWEK ===
        // 1. Zabezpieczenie przed nieskończoną pętlą: Jeśli już odwiedziliśmy ten węzeł w tej ścieżce, natychmiast zakończ.
        if (visited.has(targetId)) {
            return []; 
        }
        
        // 2. Ograniczenie głębokości pozostaje jako dodatkowe zabezpieczenie.
        if (currentDepth > maxDepth) {
            return [];
        }

        // 3. Dodaj bieżący węzeł do zbioru odwiedzonych, aby uniknąć cykli w dalszej części tej gałęzi.
        visited.add(targetId);
        // === KONIEC KLUCZOWYCH POPRAWEK ===

        let directDepsData = [];
        if (type === 'inputs') {
            allProcesses.forEach(p => {
                // Dodatkowe zabezpieczenie: nie przetwarzaj ponownie węzła, który jest już w ścieżce.
                if (visited.has(p.ID) && p.ID !== targetId) return;

                if (p.Dependencies) {
                    const pDepRawEntries = String(p.Dependencies).split(',').map(entry => entry.trim()).filter(entry => entry);
                    pDepRawEntries.forEach(rawEntry => {
                        const { id: depTargetIdInP, type: depLinkType } = parseDependencyEntry(rawEntry);
                        if (depTargetIdInP === targetId) {
                            // Jeśli p.ID to ten sam węzeł co targetId (samo-zależność), nie wchodź w rekurencję.
                            if (p.ID === targetId) return; 
                            
                            // Przekazuj ten sam zbiór 'visited' w dół rekurencji, nie twórz nowego.
                            const children = getRecursiveDependenciesGraph(p.ID, 'inputs', allProcesses, maxDepth, currentDepth + 1, visited, p.ID);
                            directDepsData.push({
                                id: p.ID,
                                name: p["Short name"],
                                level: -(currentDepth + 1),
                                depLinkType: depLinkType,
                                children: children,
                                parentId: targetId,
                                isCollapsed: false,
                                hasChildren: children.length > 0
                            });
                        }
                    });
                }
            });
        } else { // type === 'outputs'
            const targetProcess = allProcesses.find(p => p.ID === targetId);
            if (targetProcess && targetProcess.Dependencies) {
                const outputRawEntries = String(targetProcess.Dependencies).split(',').map(entry => entry.trim()).filter(entry => entry);
                outputRawEntries.forEach(rawEntry => {
                    const { id: outId, type: depLinkType } = parseDependencyEntry(rawEntry);
                    if (outId === targetId) return; // Zabezpieczenie przed samo-zależnością

                    // Jeśli węzeł wyjściowy był już odwiedzony w tej ścieżce, nie przetwarzaj go.
                    if (visited.has(outId)) return;

                    const outProc = allProcesses.find(p => p.ID === outId);
                    if (outProc) {
                         // Przekazuj ten sam zbiór 'visited' w dół rekurencji.
                        const children = getRecursiveDependenciesGraph(outProc.ID, 'outputs', allProcesses, maxDepth, currentDepth + 1, visited, outProc.ID);
                        directDepsData.push({
                            id: outProc.ID,
                            name: outProc["Short name"],
                            level: currentDepth + 1,
                            depLinkType: depLinkType,
                            children: children,
                            parentId: targetId,
                            isCollapsed: false,
                            hasChildren: children.length > 0
                        });
                    } else {
                         const nameFromAnySheet = (() => { for (const sheet of Object.values(processesData)) { const found = sheet.find(p => p.ID === outId); if (found) return found["Short name"]; } return null; })();
                        directDepsData.push({
                            id: outId,
                            name: nameFromAnySheet || `${outId.substring(0,15)}... (NV)`,
                            level: currentDepth + 1,
                            depLinkType: depLinkType,
                            children: [],
                            notInView: true,
                            parentId: targetId,
                            isCollapsed: false,
                            hasChildren: false
                        });
                    }
                });
            }
        }
        
        // Po przetworzeniu wszystkich dzieci danego węzła, usuń go ze zbioru odwiedzonych.
        // Umożliwia to poprawne wyświetlanie go w innych, niezależnych gałęziach drzewa.
        visited.delete(targetId);
        
        return directDepsData;
    }

    function generateAndShowDependencyTree(processId) {
        try {
            console.log('🌳 generateAndShowDependencyTree called with processId:', processId);
            
            // Validate DOM elements first
            if (!dependencyTreeSvg) {
                console.error('❌ dependencyTreeSvg element not found');
                throw new Error('Dependency tree SVG element not found in DOM');
            }
            
            if (!dependencyPanelTitle) {
                console.error('❌ dependencyPanelTitle element not found');
                throw new Error('Dependency panel title element not found in DOM');
            }
            
            const currentProcessesForRoot = getCurrentlyVisibleProcesses(true);
            console.log('📊 Current processes for root:', currentProcessesForRoot?.length || 0);
            
            if (!currentProcessesForRoot || currentProcessesForRoot.length === 0) {
                console.error('❌ No processes available for dependency tree');
                dependencyTreeSvg.innerHTML = '<text x="10" y="20" fill="red">No processes available for dependency tree.</text>';
                return;
            }
            
            const rootProcess = currentProcessesForRoot.find(p => p.ID === processId);
            console.log('🎯 Root process found:', rootProcess ? `${rootProcess["Short name"]} (${rootProcess.ID})` : 'NOT FOUND');
            
            if (!rootProcess) {
                console.error('❌ Cannot find process with ID:', processId);
                console.log('📋 Available process IDs:', currentProcessesForRoot.map(p => p.ID));
                dependencyTreeSvg.innerHTML = '<text x="10" y="20" fill="red">Cannot find selected process.</text>';
                return;
            }

            currentDependencyTreeRootProcess = rootProcess;
            dependencyPanelTitle.textContent = `Dependencies for: ${rootProcess["Short name"]} (${rootProcess.ID})`;

            const allProcessesCombined = getAllProcessesFromData();
            console.log('📚 All processes combined:', allProcessesCombined?.length || 0);
            
            if (!allProcessesCombined || allProcessesCombined.length === 0) {
                console.error('❌ No combined processes data available');
                dependencyTreeSvg.innerHTML = '<text x="10" y="20" fill="red">No processes data available.</text>';
                return;
            }

            console.log('🔄 Generating dependency graphs...');
            
            currentTreeInputsData = getRecursiveDependenciesGraph(processId, 'inputs', allProcessesCombined, DEP_TREE_MAX_DEPTH, 0, new Set(), null);
            console.log('⬅️ Tree inputs data generated:', currentTreeInputsData?.length || 0, 'nodes');
            
            currentTreeOutputsData = getRecursiveDependenciesGraph(processId, 'outputs', allProcessesCombined, DEP_TREE_MAX_DEPTH, 0, new Set(), null);
            console.log('➡️ Tree outputs data generated:', currentTreeOutputsData?.length || 0, 'nodes');
            
            console.log('🎯 Initializing tree states...');
            
            function initializeTreeStates(nodes) {
                if (!nodes) return;
                nodes.forEach(node => {
                    if (node.isCollapsed === undefined) node.isCollapsed = false;
                    node.hasChildren = node.children && node.children.length > 0;
                    if (node.children) initializeTreeStates(node.children);
                });
            }
            initializeTreeStates(currentTreeInputsData);
            initializeTreeStates(currentTreeOutputsData);

            console.log('🎨 Drawing dependency tree SVG...');
            drawDependencyTreeSVG(rootProcess, currentTreeInputsData, currentTreeOutputsData);
            
            console.log('✅ Dependency tree generated successfully');
            
        } catch (error) {
            console.error('💥 Critical error in generateAndShowDependencyTree:', error);
            console.error('Stack trace:', error.stack);
            
            if (dependencyTreeSvg) {
                dependencyTreeSvg.innerHTML = `<text x="10" y="20" fill="red">Error: ${error.message}</text>`;
            }
            
            throw error;
        }
    }

function initSimulationPanelUI() {
    populateScenarioSelector();
    const updateButton = document.getElementById('run-simulation-button');
    if (updateButton) updateButton.addEventListener('click', (e) => { e.stopPropagation(); runOrUpdateSimulation(); });
    
    const addButton = document.getElementById('simulation-add-process-button');
    if (addButton) addButton.addEventListener('click', (e) => { e.stopPropagation(); addProcessToSimulation(); });
    
    const endButton = document.getElementById('end-simulation-button');
    if (endButton) endButton.addEventListener('click', (e) => { e.stopPropagation(); endSimulation(); });
    
    const exportButton = document.getElementById('export-simulation-report-button');
    if (exportButton) exportButton.addEventListener('click', (e) => { e.stopPropagation(); exportSimulationReport(e); });
    
    const saveScenarioButton = document.getElementById('save-simulation-scenario-button');
    if (saveScenarioButton) saveScenarioButton.addEventListener('click', (e) => { e.stopPropagation(); saveSimulationScenario(e); });
    
    const loadScenarioButton = document.getElementById('load-simulation-scenario-button');
    if (loadScenarioButton) loadScenarioButton.addEventListener('click', (e) => { e.stopPropagation(); loadSelectedSimulationScenario(e); });

    const deleteScenarioButton = document.getElementById('delete-simulation-scenario-button');
    if (deleteScenarioButton) {
        deleteScenarioButton.addEventListener('click', (e) => {
            e.stopPropagation(); // Zapobiegamy zamknięciu panelu

            // 1. Znajdź główny selektor i pobierz z niego nazwę scenariusza
            const selector = document.getElementById('simulation-scenario-selector');
            const scenarioNameToDelete = selector.value;

            // 2. Sprawdź, czy cokolwiek jest wybrane
            if (!scenarioNameToDelete) {
                showNotification("Please select a scenario from the dropdown to delete.", "warning");
                return;
            }

            // 3. Natychmiast pokaż okno z potwierdzeniem
            if (confirm(`Are you sure you want to delete the scenario "${scenarioNameToDelete}"?`)) {
                // 4. Jeśli użytkownik potwierdzi, wywołaj funkcję usuwającą
                deleteSpecificSimScenario(scenarioNameToDelete);
            }
        });
    }
}
// === POCZĄTEK NOWEJ, POPRAWIONEJ FUNKCJI ===
function updateSimTargetParam(index, key, value) {
    if (simulationTargets[index]) {
        // Zapisz nową wartość w parametrach odpowiedniego procesu
        simulationTargets[index].params[key] = value;
        
        // Auto-update simulation when parameters change
        console.log(`🔄 Parameter ${key} updated for process ${simulationTargets[index].id}: ${value}`);
        
        // Debounce mechanism to avoid excessive updates
        clearTimeout(window.simulationUpdateTimeout);
        window.simulationUpdateTimeout = setTimeout(() => {
            if (isSimulationModeActive) {
                console.log('🚀 Auto-updating simulation after parameter change...');
                runOrUpdateSimulation();
            }
        }, 300); // 300ms delay to allow multiple rapid changes
    }
}
// === KONIEC NOWEJ, POPRAWIONEJ FUNKCJI ===

// === POCZĄTEK OSTATECZNEJ WERSJI FUNKCJI ===
function addProcessToSimulation() {
    const selectEl = document.getElementById('simulation-add-another-process-select');
    const selectedOption = selectEl.options[selectEl.selectedIndex];
    if (!selectedOption || !selectedOption.value) {
        showNotification("Please select a process to add.", "warning");
        return;
    }

    const processId = selectedOption.value;
    const processSheet = selectedOption.dataset.sheet;
    const processData = getAllProcessesFromData().find(p => p.ID === processId && p._sourceSheet === processSheet);

    if (processData) {
        simulationTargets.push({
            id: processId,
            sheet: processSheet,
            type: 'shift', 
            params: {
                 wd: processData.WD, // Ustawiamy początkowe WD
                 dueTime: processData["Due time"] || '00:00:00' // Ustawiamy początkowy czas
            },
            originalData: processData
        });
        
        // Odśwież widok panelu i uruchom symulację ponownie, aby uwzględnić nowy proces
        updateSimulationTargetsList();
        runOrUpdateSimulation();
    }
}
// === KONIEC OSTATECZNEJ WERSJI FUNKCJI ===

    function validateSimulationShiftInputs() {
        let isValid = true;
        const wdErrorEl = document.getElementById('error-simulation-new-wd');
        const timeErrorEl = document.getElementById('error-simulation-new-due-time');
        wdErrorEl.textContent = '';
        timeErrorEl.textContent = '';

        const wdVal = simulationNewWdInput.value;
        if (wdVal === '' || isNaN(parseInt(wdVal, 10))) {
            wdErrorEl.textContent = "WD must be a valid number.";
            isValid = false;
        }

        const timeVal = simulationNewDueTimeInput.value;
        if (!timeVal) {
        } else if (!/^\d{1,2}:\d{2}(:\d{2})?$/.test(timeVal)) {
            timeErrorEl.textContent = "Format HH:MM or HH:MM:SS.";
            isValid = false;
        } else {
            const tempTime = timeVal.includes(':') && timeVal.split(':').length === 2 ? timeVal + ":00" : timeVal;
            if (isNaN(parseTime(tempTime))) {
                timeErrorEl.textContent = "Not a valid time (00:00:00-23:59:59).";
                isValid = false;
            }
        }
        return isValid;
    }
    
    function validateSimulationAddInputs() {
        let isValid = true;
        const fields = [
            {id: 'sim-add-id', name: 'ID', required: true, pattern: /^[a-zA-Z0-9._-]+$/},
            {id: 'sim-add-short-name', name: 'Short Name', required: true},
            {id: 'sim-add-wd', name: 'WD', required: true, isNumber: true},
            {id: 'sim-add-due-time', name: 'Due Time', required: true, isTime: true},
            {id: 'sim-add-dependencies', name: 'Dependencies', required: false, isDeps: true},
            {id: 'sim-add-process-type', name: 'Process Type', required: true}
        ];

        fields.forEach(field => {
            const inputEl = document.getElementById(field.id);
            const errorEl = document.getElementById(`error-${field.id}`);
            errorEl.textContent = '';
            let value = inputEl.value.trim();

            if (field.required && !value && !(field.name === "WD" && value === "0")) {
                errorEl.textContent = `${field.name} is required.`;
                isValid = false;
                return;
            }
            if (field.pattern && value && !field.pattern.test(value)) {
                errorEl.textContent = `Invalid format for ${field.name}. Use letters, numbers, '.', '_', '-'.`;
                isValid = false;
            }
            if (field.isNumber && value && isNaN(parseInt(value, 10))) {
                errorEl.textContent = `${field.name} must be a number.`;
                isValid = false;
            }
            if (field.isTime && value) {
                if (!/^\d{1,2}:\d{2}(:\d{2})?$/.test(value)) {
                     errorEl.textContent = "Format HH:MM or HH:MM:SS."; isValid = false;
                } else {
                     const tempTime = value.includes(':') && value.split(':').length === 2 ? value + ":00" : value;
                     if (isNaN(parseTime(tempTime))) { errorEl.textContent = "Not a valid time (00:00-23:59)."; isValid = false; }
                }
            }
            if (field.isDeps && value) {
                const depEntries = value.split(',').map(entry => entry.trim()).filter(entry => entry);
                if (depEntries.some(entry => {
                    const parsed = parseDependencyEntry(entry);
                    return !/^[a-zA-Z0-9._-]+$/.test(parsed.id);
                })) {
                    errorEl.textContent = "Dependency short names can only contain letters, numbers, '.', '_', '-'. Separate with commas.";
                    isValid = false;
                }
            }
            if (field.id === 'sim-add-id' && value) {
                 const existingProcess = getAllProcessesFromData().find(p => p.ID === value);
                 if (existingProcess) {
                    errorEl.textContent = `ID "${value}" already exists in the diagram. Choose a unique ID for simulation.`;
                    isValid = false;
                 }
            }

        });
        return isValid;
    }


// === POCZĄTEK OSTATECZNEJ WERSJI FUNKCJI ===
// NOWA WERSJA (POPRAWIONA)
function runOrUpdateSimulation() {
    console.log('🚀 runOrUpdateSimulation called with', simulationTargets.length, 'targets');
    
    if (simulationTargets.length === 0) {
        console.log('❌ No simulation targets found, ending simulation');
        endSimulation();
        return;
    }

    let isValid = true;
    // Krok 1: Walidacja danych wejściowych dla wszystkich procesów typu 'shift'
    console.log('📋 Validating simulation targets...');
    simulationTargets.forEach((target, index) => {
        console.log(`   Target ${index}: ${target.id} (${target.type}) - WD: ${target.params?.wd}, Time: ${target.params?.dueTime}`);
        if (target.type === 'shift') {
            const wdValue = parseInt(target.params.wd, 10);
            if (isNaN(wdValue)) {
                showNotification(`Validation Error: Invalid WD for process ${target.id}. Must be a number.`, 'error');
                isValid = false;
            } else {
                target.params.wd = wdValue; // Zapisz poprawną wartość jako liczbę
            }

            const timeVal = target.params.dueTime;
            if (timeVal && timeVal.trim() !== "") {
                const tempTime = timeVal.includes(':') && timeVal.split(':').length === 2 ? timeVal + ":00" : timeVal;
                if (!/^\d{1,2}:\d{2}:\d{2}$/.test(tempTime) || isNaN(parseTime(tempTime))) {
                    showNotification(`Validation Error: Invalid time format for process ${target.id}. Use HH:MM or HH:MM:SS.`, 'error');
                    isValid = false;
                }
            }
        }
    });

    if (!isValid) {
        return; // Przerwij, jeśli walidacja się nie powiodła
    }

    // Krok 2: Ustaw tryb symulacji i zaktualizuj interfejs
    isSimulationModeActive = true;
    
    // Zastosuj wizualizacje na diagramie
    applySimulationVisuals();

    // Zaktualizuj przyciski w panelu, aby odzwierciedlały aktywny stan symulacji
    runSimulationButton.textContent = 'Update Simulation';
    endSimulationButton.style.display = 'block'; // Pokaż przycisk "End Simulation"
    exportSimulationReportButton.style.display = 'block'; // Pokaż przycisk "Export Report"

    // Upewnij się, że panel pozostaje otwarty
    if (!simulationPanel.classList.contains('open')) {
        toggleSimulationPanel(true);
    }
    
    console.log('✅ Simulation updated successfully');
    showNotification("Simulation updated. Process positions and impacts refreshed.", "success");
}

function applySimulationVisuals(newSimulatedNodeData = null) {
    if (!isSimulationModeActive || simulationTargets.length === 0) return;

    svgLayer.innerHTML = '';
    simulationGhostLayer.innerHTML = '';
    currentImpactPaths = [];

    // Krok 1: Reset wizualny
    diagramPane.querySelectorAll('.process-node').forEach(node => {
        node.className = 'process-node can-hover';
        const layout = nodeLayouts[node.dataset.id];
        if (layout && layout.process) {
            const procData = layout.process;
            const processType = (procData["Process Type"] || "standard").toLowerCase();
            let baseColor = configColors.node;
            if (processType === "blocking") baseColor = configColors.blockingNode;
            else if (processType === "informational") baseColor = configColors.informationalNode;
            else if (processType === "standard-blocking") baseColor = configColors.node; // Używa koloru standard

            node.style.backgroundColor = baseColor;
            // Standard-blocking używa obramowania w kolorze blocking
            if (processType === 'standard-blocking') {
                node.style.borderColor = shadeColor(configColors.blockingNode || '#ffcc80', -0.3);
            } else {
                node.style.borderColor = shadeColor(baseColor, -0.3);
            }
            node.style.top = `${layout.finalY}px`;
            
            // Recalculate X position based on current axis state after expansion
            if (layout.process && layout.process.WD !== undefined) {
                const processWd = layout.process.WD;
                const wdIndex = gUniqueDataWds.indexOf(processWd);
                if (wdIndex !== -1) {
                    const newXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (wdIndex * gWdColumnWidth) + (gWdColumnWidth / 2);
                    const newLeft = newXCenter - layout.width / 2;
                    node.style.left = `${newLeft}px`;
                    // Position recalculated for axis expansion
                } else {
                    // Fallback to cached position if WD not found
                    node.style.left = `${layout.finalX}px`;
                    console.log(`⚠️ Using cached position for ${layout.process["Short name"] || layout.process.ID} - WD ${processWd} not found in axis`);
                }
            } else {
                // Fallback to cached position if no WD data
                node.style.left = `${layout.finalX}px`;
            }

            node.classList.remove('standard-blocking');
            if (processType === 'standard-blocking') node.classList.add('standard-blocking');
        }
        node.classList.add('simulation-dimmed-others');
    });
    diagramPane.querySelectorAll('.simulation-temporary-node, .simulation-new-node').forEach(n => n.remove());

    // Krok 2: Przygotowanie danych symulacji
    const removedIds = new Set(simulationTargets.filter(t => t.type === 'remove').map(t => t.id));
    const activeSimulatedStates = new Map();

    simulationTargets.forEach(t => {
        if (!t.originalData) return;
        activeSimulatedStates.set(t.id, {
            id: t.id,
            sheet: t.sheet,
            type: t.type,
            wd: t.type === 'shift' ? parseInt(t.params.wd, 10) : t.originalData.WD,
            time: parseTime(t.type === 'shift' ? t.params.dueTime : t.originalData["Due time"]),
            dependencies: t.originalData.Dependencies,
            originalData: t.originalData
        });
    });

    // Krok 3: Zastosowanie styli dla głównych celów symulacji
    simulationTargets.forEach(target => {
        // Sanitize ID for CSS selector - fix for processes with spaces like "Create FA"
        const sanitizedId = target.id.replace(/[^a-zA-Z0-9_-]/g, '_');
        let targetNodeEl = diagramPane.querySelector(`.process-node[data-id="${sanitizedId}"]`);
        
        // Fallback: try with original ID if sanitized doesn't work
        if (!targetNodeEl) {
            targetNodeEl = diagramPane.querySelector(`.process-node[data-id="${target.id}"]`);
        }
        
        if (!targetNodeEl) {
            console.log(`⚠️ Target node not found for process ${target.id} (sanitized: ${sanitizedId})`);
            return;
        }
        
        // console.log(`✅ Found target node for process ${target.id}`);
        
        targetNodeEl.classList.remove('simulation-dimmed-others');
        targetNodeEl.classList.add('simulation-target-node');

        switch (target.type) {
            case 'remove':
                targetNodeEl.classList.add('simulation-removed');
                break;
            case 'shift':
                targetNodeEl.classList.add('simulation-shifted');
                const state = activeSimulatedStates.get(target.id);
                if (!state) break;
                const layout = nodeLayouts[target.id];
                if (!layout) break;

                const originalTimeSec = parseTime(target.originalData["Due time"]);
                const simTimeSec = state.time;
                const originalWd = target.originalData.WD;
                const simWd = state.wd;
                const wdChanged = simWd !== originalWd;
                
                // Enhanced time change detection - handle NaN gracefully
                const originalTimeValid = !isNaN(originalTimeSec);
                const simTimeValid = !isNaN(simTimeSec);
                const timeChanged = (originalTimeValid !== simTimeValid) || (originalTimeValid && simTimeValid && originalTimeSec !== simTimeSec);
                
                console.log(`   📊 Change detection: WD ${originalWd} → ${simWd} (${wdChanged}), Time ${originalTimeSec} → ${simTimeSec} (${timeChanged})`);

                if (wdChanged || timeChanged) {
                    console.log(`🔄 Shifting process ${target.id}: WD ${originalWd} → ${simWd}, Time ${originalTimeSec} → ${simTimeSec}`);
                    
                    let wdIndex = gUniqueDataWds.indexOf(simWd);
                    console.log(`   WD Index for ${simWd}:`, wdIndex, 'Available WDs:', gUniqueDataWds);
                    
                    // If WD doesn't exist in current data, add it and recalculate layout
                    let currentWdColumnWidth = gWdColumnWidth;
                    if (wdIndex === -1) {
                        console.log(`   ⚠️ WD ${simWd} not found in data, adding to axis...`);
                        gUniqueDataWds.push(simWd);
                        gUniqueDataWds.sort((a, b) => a - b);
                        wdIndex = gUniqueDataWds.indexOf(simWd);
                        console.log(`   ✅ WD ${simWd} added at index ${wdIndex}, New WDs:`, gUniqueDataWds);
                        
                        // Immediately recalculate column width for correct positioning
                        const newColumnCount = gUniqueDataWds.length;
                        currentWdColumnWidth = gPlotWidth / newColumnCount;
                        console.log(`   📐 Recalculated column width: ${gWdColumnWidth} → ${currentWdColumnWidth} (${newColumnCount} columns)`);
                        
                        // Update global column width for consistency
                        gWdColumnWidth = currentWdColumnWidth;
                        console.log('📊 Updated global gWdColumnWidth to:', gWdColumnWidth);
                        
                        // Schedule axis labels update without full diagram redraw
                        setTimeout(() => {
                            console.log('🔄 Updating WD axis labels only...');
                            updateWdAxisLabels();
                        }, 100);
                    }
                    
                    let idealXCenter = gYAxisLabelWidthOriginal + gDiagramPanePadding + (wdIndex * currentWdColumnWidth + currentWdColumnWidth / 2);
                    let idealYCenter = PADDING + gPlotHeight / 2;
                    
                    if (!isNaN(simTimeSec)) {
                        const binIndex = Math.min(gTimeBins.length - 1, Math.max(0, Math.floor(simTimeSec / gTimeBinSizeSec)));
                        const bin = gTimeBins[binIndex];
                        if (bin) {
                            idealYCenter = bin.yOffset + ((simTimeSec - bin.startSec) / (bin.endSec - bin.startSec + 1)) * bin.height;
                        }
                        console.log(`   ⏰ Time positioning: ${simTimeSec}s → bin ${binIndex} → Y: ${idealYCenter}`);
                    } else {
                        console.log(`   ⏰ No valid time for ${target.id}, using middle Y position: ${idealYCenter}`);
                    }
                    
                    const newLeft = idealXCenter - targetNodeEl.offsetWidth / 2;
                    const newTop = idealYCenter - targetNodeEl.offsetHeight / 2;
                    
                    console.log(`   📍 New position: (${newLeft}, ${newTop}) for WD ${simWd}`);
                    targetNodeEl.style.left = `${newLeft}px`;
                    targetNodeEl.style.top = `${newTop}px`;
                    
                    // Verification log to confirm position update
                    setTimeout(() => {
                        const actualLeft = parseInt(targetNodeEl.style.left);
                        const actualTop = parseInt(targetNodeEl.style.top);
                        console.log(`   ✅ Position verified: (${actualLeft}, ${actualTop})`);
                    }, 50);
                } else {
                    console.log(`ℹ️ No changes detected for ${target.id}, keeping original position`);
                    targetNodeEl.style.left = `${layout.finalX}px`;
                    targetNodeEl.style.top = `${layout.finalY}px`;
                }
                break;
        }
    });

    // Krok 4: Analiza i wizualizacja wpływu
    let impactListHTML = '<h4>Impact Summary:</h4><ul>';
    let hasImpact = false;
    const allProcsData = getAllProcessesFromData();

    allProcsData.forEach(proc => {
        if (removedIds.has(proc.ID) || activeSimulatedStates.has(proc.ID)) return;

        const outputNode = diagramPane.querySelector(`.process-node[data-id="${proc.ID}"]`);
        if (!outputNode) return;

        if (proc.Dependencies) {
                            const deps = String(proc.Dependencies).split(',').map(d => parseDependencyEntry(d.trim()));
            deps.forEach(dep => {
                if (removedIds.has(dep.id)) {
                    outputNode.classList.remove('simulation-dimmed-others');
                    outputNode.classList.add('simulation-output-at-risk');
                    impactListHTML += `<li><strong>Dependency Lost</strong> for ${proc["Short name"]} (from ${dep.id})</li>`;
                    hasImpact = true;
                    drawArrow(diagramPane.querySelector(`.process-node[data-id="${dep.id}"]`), outputNode, '#dc3545', 'simulation-arrow-broken', dep.type, true);
                }
                
                if (activeSimulatedStates.has(dep.id)) {
                    const sourceState = activeSimulatedStates.get(dep.id);
                    const outputTime = parseTime(proc["Due time"]);
                    
                    if (sourceState && (sourceState.wd > proc.WD || (sourceState.wd === proc.WD && !isNaN(sourceState.time) && !isNaN(outputTime) && sourceState.time > outputTime))) {
                        outputNode.classList.remove('simulation-dimmed-others');
                        outputNode.classList.add('simulation-output-at-risk');
                        impactListHTML += `<li><strong style="color:red;">Output at Risk</strong>: ${proc["Short name"]} may be delayed by shifted input from ${sourceState.originalData["Short name"]}.</li>`;
                        hasImpact = true;
                        drawArrow(diagramPane.querySelector(`.process-node[data-id="${dep.id}"]`), outputNode, '#FF8C00', 'simulation-arrow', dep.type, true);
                    } else if (sourceState) {
                        outputNode.classList.remove('simulation-dimmed-others');
                        outputNode.classList.add('simulation-ok-output');
                        drawArrow(diagramPane.querySelector(`.process-node[data-id="${dep.id}"]`), outputNode, '#28a745', 'simulation-arrow', dep.type, false);
                    }
                }
            });
        }
    });

    activeSimulatedStates.forEach(targetState => {
        if (targetState.dependencies) {
            const deps = String(targetState.dependencies).split(',').map(d => parseDependencyEntry(d.trim()));
            deps.forEach(dep => {
                const sourceProc = allProcsData.find(p => p.ID === dep.id);
                // **KLUCZOWA POPRAWKA:** Sprawdź, czy `sourceProc` istnieje, ZANIM spróbujesz go użyć.
                if (!sourceProc) return;

                const sourceState = activeSimulatedStates.get(dep.id) || { wd: sourceProc.WD, time: parseTime(sourceProc["Due time"]) };
                
                // **KLUCZOWE ZABEZPIECZENIE:** Sprawdź, czy `sourceState` został poprawnie utworzony.
                if (sourceState.wd === undefined) return;

                const sourceNode = diagramPane.querySelector(`.process-node[data-id="${sourceProc.ID}"]`);
                const targetNode = diagramPane.querySelector(`.process-node[data-id="${targetState.id}"]`);
                if (!sourceNode || !targetNode) return;

                sourceNode.classList.remove('simulation-dimmed-others');
                
                if (targetState.wd < sourceState.wd || (targetState.wd === sourceState.wd && !isNaN(targetState.time) && !isNaN(sourceState.time) && targetState.time < sourceState.time)) {
                    sourceNode.classList.add('simulation-input-conflict');
                    impactListHTML += `<li><strong style="color:red;">Input Timing Conflict</strong>: ${targetState.originalData["Short name"]} now occurs before its input from ${sourceProc["Short name"]}.</li>`;
                    hasImpact = true;
                    drawArrow(sourceNode, targetNode, '#FF4500', 'simulation-arrow', dep.type, true);
                } else {
                    sourceNode.classList.add('simulation-ok-input');
                    drawArrow(sourceNode, targetNode, '#28a745', 'simulation-arrow', dep.type, false);
                }
            });
        }
    });

    if (!hasImpact) {
        impactListHTML += '<li>No direct timing conflicts or risks identified.</li>';
    }
    impactListHTML += '</ul>';
    simulationImpactListContainer.innerHTML = impactListHTML;

    drawMiniMap();
    updateMiniMapViewPort();
}

// === KONIEC OSTATECZNEJ WERSJI FUNKCJI JAVASCRIPT ===

function endSimulation() {
    if (!isSimulationModeActive) return;
    const mainTargetBeforeEnd = simulationTargets.length > 0 ? simulationTargets[0].id : null;
    isSimulationModeActive = false;
    simulationTargets = [];
    simulatedNewProcessData = null;
    currentSimulationType = 'remove';
    previousSimulationParams = {};
    currentImpactPaths = [];
    const multiProcessManager = document.getElementById('multi-process-simulation-manager');
    if (multiProcessManager) multiProcessManager.style.display = 'none';
    const endButton = document.getElementById('end-simulation-button');
    if (endButton) endButton.style.display = 'none';
    const exportButton = document.getElementById('export-simulation-report-button');
    if (exportButton) exportButton.style.display = 'none';
    const impactContainer = document.getElementById('simulation-impact-list-container');
    if (impactContainer) impactContainer.innerHTML = '';
    toggleSimulationPanel(false);
    renderDiagramAndRestoreState();
    if (mainTargetBeforeEnd) {
        currentlySelectedProcessId = mainTargetBeforeEnd;
        selectProcess(currentlySelectedProcessId, true);
    } else {
        resetVisualStates();
    }
}
    
// NOWA WERSJA (POPRAWIONA I KOMPLETNA)
function exportSimulationReport(event) {
    if(event) event.stopPropagation(); // Zatrzymuje propagację kliknięcia

    if (!isSimulationModeActive) {
        showNotification("No active simulation to report.", "warning");
        return;
    }

    let reportContent = "Simulation Report\n";
    reportContent += "===================\n\n";
    reportContent += `Date: ${new Date().toLocaleString()}\n\n`;
    
    reportContent += "--- Processes in Simulation ---\n";
    let mainTargetIdForFilename = 'multi_process';

    simulationTargets.forEach((target, index) => {
        if (index === 0) mainTargetIdForFilename = target.id;
        reportContent += `\nProcess ${index + 1}: ${target.originalData["Short name"]} (ID: ${target.id})\n`;
        reportContent += `  - Type: ${target.type.charAt(0).toUpperCase() + target.type.slice(1)}\n`;
        if (target.type === 'shift') {
            reportContent += `  - Shifted to WD: ${target.params.wd}, Time: ${target.params.dueTime || 'Not Changed'}\n`;
        }
    });

    reportContent += "\n\n--- Impact Summary ---\n";

    const impactLists = simulationImpactListContainer.querySelectorAll('ul');
    if (impactLists.length > 0 && simulationImpactListContainer.textContent.includes('Impact')) {
         const items = simulationImpactListContainer.querySelectorAll('li');
         if (items.length > 0) {
             items.forEach(li => {
                 reportContent += `- ${li.textContent.trim()}\n`;
             });
         } else {
             reportContent += "- No specific impacts listed in the panel.\n";
         }
    } else {
        reportContent += "No specific impacts listed in the panel.\n";
    }

    const blob = new Blob([reportContent], { type: 'text/plain;charset=utf-8' });
    const filename = `simulation_report_${mainTargetIdForFilename}_${new Date().toISOString().slice(0,10)}.txt`;
    
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    
    // <<< POCZĄTEK KLUCZOWEJ ZMIANY >>>
    isProgrammaticClick = true; // Ustaw flagę przed syntetycznym kliknięciem
    link.click();
    setTimeout(() => {
        isProgrammaticClick = false; // Zresetuj flagę po chwili
    }, 100);
    // <<< KONIEC KLUCZOWEJ ZMIANY >>>
    
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
    showNotification("Simulation report exported.", "success");
}
    function storeCurrentSimulationParams() {
        previousSimulationParams = {
            type: activeSimulationTypeInput.value,
            shiftWd: simulationNewWdInput.value,
            shiftDueTime: simulationNewDueTimeInput.value,
            addId: document.getElementById('sim-add-id').value,
            addShortName: document.getElementById('sim-add-short-name').value,
            addWd: document.getElementById('sim-add-wd').value,
            addDueTime: document.getElementById('sim-add-due-time').value,
            addDependencies: document.getElementById('sim-add-dependencies').value,
            addProcessType: document.getElementById('sim-add-process-type').value
        };
    }

    function undoSimulationParameters() {
        if (Object.keys(previousSimulationParams).length === 0) {
            showNotification("No previous parameters to undo.", "info");
            return;
        }

        activeSimulationTypeInput.value = previousSimulationParams.type || 'remove';
        currentSimulationType = activeSimulationTypeInput.value;

        simulationTypeSelectorGroup.querySelectorAll('.simulation-type-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.simtype === currentSimulationType);
        });


        simulationNewWdInput.value = previousSimulationParams.shiftWd || '';
        simulationNewDueTimeInput.value = previousSimulationParams.shiftDueTime || '';
        document.getElementById('sim-add-id').value = previousSimulationParams.addId || '';
        document.getElementById('sim-add-short-name').value = previousSimulationParams.addShortName || '';
        document.getElementById('sim-add-wd').value = previousSimulationParams.addWd || '';
        document.getElementById('sim-add-due-time').value = previousSimulationParams.addDueTime || '';
        document.getElementById('sim-add-dependencies').value = previousSimulationParams.addDependencies || '';
        document.getElementById('sim-add-process-type').value = previousSimulationParams.addProcessType || 'standard';

        if (currentSimulationType === 'shift') {
            simulationShiftInputsDiv.style.display = 'block';
            simulationAddInputsDiv.style.display = 'none';
        } else if (currentSimulationType === 'add') {
            simulationShiftInputsDiv.style.display = 'none';
            simulationAddInputsDiv.style.display = 'block';
        } else {
            simulationShiftInputsDiv.style.display = 'none';
            simulationAddInputsDiv.style.display = 'none';
        }
        showNotification("Simulation parameters restored to previous state.", "info");
    }

// NOWA WERSJA (POPRAWIONA)
// NOWA WERSJA (POPRAWIONA)
function saveSimulationScenario(event) {
    if(event) event.stopPropagation(); // Zapobiega zamknięciu panelu

    if (!isSimulationModeActive || simulationTargets.length === 0) {
        showNotification("There is nothing to save. Add processes to the simulation and run it first.", "warning");
        return;
    }

    const scenarioName = prompt("Enter a name for this simulation scenario:");
    if (!scenarioName || scenarioName.trim() === "") {
        showNotification("Scenario name cannot be empty.", "warning");
        return;
    }

    // Tworzymy "czystą" kopię do zapisu, bez pełnych obiektów `originalData`
    const targetsToSave = simulationTargets.map(t => ({
        id: t.id,
        sheet: t.sheet,
        type: t.type,
        params: t.params
    }));

    const scenario = {
        name: scenarioName.trim(),
        // Zamiast pojedynczych pól, zapisujemy całą tablicę skonfigurowanych celów
        simulationTargets: targetsToSave 
    };

    let savedScenarios = JSON.parse(localStorage.getItem(SIMULATION_SCENARIOS_STORAGE_KEY)) || {};
    savedScenarios[scenario.name] = scenario;
    localStorage.setItem(SIMULATION_SCENARIOS_STORAGE_KEY, JSON.stringify(savedScenarios));

    showNotification(`Simulation scenario "${scenario.name}" saved.`, "success");
    populateScenarioSelector();
}

    function populateScenarioSelector() {
        const savedScenarios = JSON.parse(localStorage.getItem(SIMULATION_SCENARIOS_STORAGE_KEY)) || {};
        simulationScenarioSelector.innerHTML = '<option value="">- Select Scenario -</option>';
        Object.keys(savedScenarios).sort().forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            simulationScenarioSelector.appendChild(option);
        });
    }


function deleteSpecificSimScenario(scenarioName) {
    let savedScenarios = JSON.parse(localStorage.getItem(SIMULATION_SCENARIOS_STORAGE_KEY)) || {};
    if (savedScenarios[scenarioName]) {
        delete savedScenarios[scenarioName];
        localStorage.setItem(SIMULATION_SCENARIOS_STORAGE_KEY, JSON.stringify(savedScenarios));
        showNotification(`Simulation scenario "${scenarioName}" deleted.`, "info");
        populateScenarioSelector(); // Odśwież główną listę
        populateDeleteSimScenarioDropdown(); // Odśwież listę do usuwania (na wypadek ponownego otwarcia)
    } else {
        showNotification(`Error: Could not find scenario "${scenarioName}" to delete.`, "error");
    }
}

// NOWA WERSJA (POPRAWIONA)
function loadSelectedSimulationScenario(event) {
    event.stopPropagation(); // Zapobiega zamknięciu panelu

    const scenarioName = simulationScenarioSelector.value;
    if (!scenarioName) {
        showNotification("Please select a scenario to load.", "info");
        return;
    }
    const savedScenarios = JSON.parse(localStorage.getItem(SIMULATION_SCENARIOS_STORAGE_KEY)) || {};
    const scenario = savedScenarios[scenarioName];

    if (!scenario || !scenario.simulationTargets) {
        showNotification(`Error: Could not load invalid scenario "${scenarioName}".`, "error");
        return;
    }

    const allProcs = getAllProcessesFromData();
    let targetsNotFound = [];
    
    // Odtwórz stan `simulationTargets` z zapisanego scenariusza
    const newSimulationTargets = scenario.simulationTargets.map(st => {
        const originalData = allProcs.find(p => p.ID === st.id && p._sourceSheet === st.sheet);
        if (!originalData) {
            targetsNotFound.push(st.id);
            return null;
        }
        return { ...st, originalData };
    }).filter(t => t !== null); // Usuń cele, których nie znaleziono

    if (targetsNotFound.length > 0) {
        showNotification(`Warning: Could not find the following processes from the scenario: ${targetsNotFound.join(', ')}. They were not added to the simulation.`, 'warning', 10000);
    }

    if (newSimulationTargets.length === 0) {
        showNotification(`No valid processes from scenario "${scenarioName}" could be loaded.`, 'error');
        return;
    }

    simulationTargets = newSimulationTargets;

    // Odśwież UI i uruchom symulację
    updateSimulationTargetsList();
    runOrUpdateSimulation();
    showNotification(`Simulation scenario "${scenarioName}" loaded and applied.`, "success");
}


    function saveCurrentViewConfiguration() {
        const configName = prompt("Enter a name for this view configuration (e.g., 'Month-End Review', 'Daily Tasks'):");
        if (!configName || configName.trim() === "") {
            showNotification("View configuration name cannot be empty.", "warning");
            return;
        }

        const viewConfig = {
            name: configName.trim(),
            appliedFilters: JSON.parse(JSON.stringify(currentAppliedFilters)), 
            axisFilter: JSON.parse(JSON.stringify(currentAxisFilter)),       
            colors: JSON.parse(JSON.stringify(configColors)),                 
            
        };

        let savedConfigs = JSON.parse(localStorage.getItem(VIEW_CONFIGS_STORAGE_KEY)) || {};
        savedConfigs[viewConfig.name] = viewConfig;
        localStorage.setItem(VIEW_CONFIGS_STORAGE_KEY, JSON.stringify(savedConfigs));

        showNotification(`View configuration "${viewConfig.name}" saved.`, "success");
        populateViewConfigSelector(); 
        menuContent.style.display = 'none';
    }

    function populateViewConfigSelector() {
        const savedConfigs = JSON.parse(localStorage.getItem(VIEW_CONFIGS_STORAGE_KEY)) || {};
        loadViewConfigSelector.innerHTML = '<option value="">- Select View -</option>'; 

        Object.keys(savedConfigs).sort().forEach(configName => {
            const option = document.createElement('option');
            option.value = configName;
            option.textContent = configName;
            loadViewConfigSelector.appendChild(option);
        });
    }

    function loadSelectedViewConfiguration() {
        if (isSimulationModeActive) endSimulation();
        const configName = loadViewConfigSelector.value;
        if (!configName) return;

        const savedConfigs = JSON.parse(localStorage.getItem(VIEW_CONFIGS_STORAGE_KEY)) || {};
        const configToLoad = savedConfigs[configName];

        if (!configToLoad) {
            showNotification(`Error: Could not find saved view configuration "${configName}".`, 'error');
            loadViewConfigSelector.value = ""; 
            return;
        }

        currentAppliedFilters = JSON.parse(JSON.stringify(configToLoad.appliedFilters || {}));
        temporaryActiveFilters = { ...currentAppliedFilters }; 
        currentAxisFilter = JSON.parse(JSON.stringify(configToLoad.axisFilter || { type: null, value: null, valueEnd: null }));
        
        const defaultColorsObject = { 
            node: '#aedff7', lightning: '#00ff00', inputProcess: '#90ee90', outputProcess: '#ffb6c1',
            inputArrow: '#50c878', outputArrow: '#ff7f7f', inputArrowBlocking: '#FF0000',
            outputArrowBlocking: '#FF0000', inputArrowInformational: '#0000FF', outputArrowInformational: '#0000FF',
            nodeSymbolColor: '#333333', blockingNode: '#ffcc80', informationalNode: '#b3e5fc'
        };
        configColors = { ...defaultColorsObject, ...(configToLoad.colors || {}) };





        initializeColorPickers(); 

        populateFilterPanel(); 
        if (filterOptionsContainer) {
            filterOptionsContainer.querySelectorAll('select, input[type="time"]').forEach(inputEl => {
                if (inputEl.tagName === 'SELECT' && inputEl.multiple) {
                    Array.from(inputEl.options).forEach(option => option.selected = false);
                } else {
                    inputEl.value = "";
                }
                const filterKey = inputEl.dataset.filterKey;
                if (currentAppliedFilters[filterKey]) {
                     if (inputEl.tagName === 'SELECT' && inputEl.multiple) {
                        const values = Array.isArray(currentAppliedFilters[filterKey]) ? currentAppliedFilters[filterKey] : [currentAppliedFilters[filterKey]];
                        Array.from(inputEl.options).forEach(option => {
                            option.selected = values.includes(option.value);
                        });
                    } else if (filterKey === "Due time" && typeof currentAppliedFilters[filterKey] === 'object') {
                         if (inputEl.id.endsWith('-from')) inputEl.value = currentAppliedFilters[filterKey].from || '';
                         if (inputEl.id.endsWith('-to')) inputEl.value = currentAppliedFilters[filterKey].to || '';
                    } else {
                        inputEl.value = currentAppliedFilters[filterKey];
                    }
                }
            });
        }


        isTreeHighlightActive = false;
        highlightedTreeNodesIds.clear();
        currentlySelectedProcessId = null; 

        resetVisualStates(); 
        renderDiagramAndRestoreState(); 

        showNotification(`View configuration "${configName}" loaded.`, "success");
        saveStateToLocalStorage(); 
        loadViewConfigSelector.value = ""; 
    }

    function populateDeleteViewDropdown() {
        const savedConfigs = JSON.parse(localStorage.getItem(VIEW_CONFIGS_STORAGE_KEY)) || {};
        deleteViewConfigDropdown.innerHTML = ''; 

        const configNames = Object.keys(savedConfigs).sort();

        if (configNames.length === 0) {
            const noItemsMsg = document.createElement('div');
            noItemsMsg.textContent = "No views to delete.";
            noItemsMsg.style.padding = "8px 12px";
            noItemsMsg.style.color = "#777";
            noItemsMsg.style.fontSize = "0.9em";
            deleteViewConfigDropdown.appendChild(noItemsMsg);
            return;
        }

        configNames.forEach(configName => {
            const item = document.createElement('div');
            item.className = 'delete-item';
            item.textContent = configName;
            item.dataset.configName = configName;
            item.addEventListener('click', (e) => {
                e.stopPropagation(); 
                const nameToDelete = e.target.dataset.configName;
                if (confirm(`Are you sure you want to delete the view configuration "${nameToDelete}"? This cannot be undone.`)) {
                    deleteSpecificViewConfiguration(nameToDelete);
                }
                deleteViewConfigDropdown.style.display = 'none'; 
            });
            deleteViewConfigDropdown.appendChild(item);
        });
    }

    function deleteSpecificViewConfiguration(configName) {
        let savedConfigs = JSON.parse(localStorage.getItem(VIEW_CONFIGS_STORAGE_KEY)) || {};
        if (savedConfigs[configName]) {
            delete savedConfigs[configName];
            localStorage.setItem(VIEW_CONFIGS_STORAGE_KEY, JSON.stringify(savedConfigs));
            showNotification(`View configuration "${configName}" deleted.`, "info");
            populateViewConfigSelector(); 
            populateDeleteViewDropdown(); 
        } else {
            showNotification(`Error: Could not find view configuration "${configName}" to delete.`, "error");
        }
    }
	    function initPanelResizer() {
        const panel = document.getElementById('dependency-panel-container');
        const resizer = document.getElementById('dependency-panel-resizer');
        if (!panel || !resizer) return;

        let isResizing = false;
        let initialPanelWidth = 0;
        let initialMouseX = 0;

        const doResize = (e) => {
            if (!isResizing) return;
            const deltaX = e.clientX - initialMouseX;
            let newWidth = initialPanelWidth - deltaX;

            const minWidth = 300;
            const maxWidth = window.innerWidth * 0.8;

            newWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
            panel.style.width = newWidth + 'px';

            // Po zmianie rozmiaru panelu, przerysuj drzewko, aby dopasowało się do nowej szerokości
            if (currentDependencyTreeRootProcess) {
                drawDependencyTreeSVG(currentDependencyTreeRootProcess, currentTreeInputsData, currentTreeOutputsData);
            }
        };

        const stopResize = () => {
            isResizing = false;
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
            document.body.style.userSelect = ''; // Przywróć zaznaczanie tekstu
            
            // Zapisz nową szerokość
            saveStateToLocalStorage();
        };

        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isResizing = true;
            initialMouseX = e.clientX;
            initialPanelWidth = panel.offsetWidth;
            document.body.style.userSelect = 'none'; // Zablokuj zaznaczanie tekstu podczas przeciągania
            
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
        });
    }

    // Wywołaj nową funkcję na końcu inicjalizacji
    initPanelResizer();
	// START NOWYCH FUNKCJI I INICJALIZACJI

function setupThemeToggle() {
    const themeToggleButton = document.getElementById('theme-toggle-button');
    const DARK_MODE_STORAGE_KEY = 'diagramDarkMode_V23';

    function applyTheme(isDark) {
        if (isDark) {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }
        localStorage.setItem(DARK_MODE_STORAGE_KEY, isDark ? 'enabled' : 'disabled');
        refreshDiagramStyles();
        updateStickyAxesContainerPositions(); 
        updateStickyAxesLabels();
        drawMiniMap();
        updateMiniMapViewPort();
    }

    // Inicjalizacja przy ładowaniu strony
    const isInitiallyDarkMode = localStorage.getItem(DARK_MODE_STORAGE_KEY) === 'enabled';
    applyTheme(isInitiallyDarkMode);

    themeToggleButton.addEventListener('click', () => {
        const isNowDarkMode = !document.body.classList.contains('dark-mode');
        applyTheme(isNowDarkMode);

        // Jeśli przełączamy NA tryb ciemny, zastosuj dedykowany motyw
        if (isNowDarkMode) {
            // Używamy motywu "Bridgestone Inverted" (indeks 1) jako domyślnego dla dark mode
            configColors = JSON.parse(JSON.stringify(THEMES[1]));
            initializeColorPickers();
            refreshDiagramStyles();
            saveStateToLocalStorage();
            showNotification(`Dark mode enabled with '${THEMES[1].name}' theme.`, "info");
        } else {
             // Można opcjonalnie zresetować do motywu jasnego
             resetColorsToDefault();
             showNotification("Light mode enabled.", "info");
        }
    });
}

function syncColorsPanelWithConfig() {
    // Mapowanie między ID elementów w panelu a kluczami w configColors
    const colorMappings = {
        'colors-panel-node-color': 'node',
        'colors-panel-blocking-node-color': 'blockingNode',
        'colors-panel-informational-node-color': 'informationalNode',
        'colors-panel-lightning-color': 'lightning',
        'colors-panel-input-process-color': 'inputProcess',
        'colors-panel-output-process-color': 'outputProcess',
        'colors-panel-input-arrow-color': 'inputArrow',
        'colors-panel-output-arrow-color': 'outputArrow',
        'colors-panel-input-arrow-blocking-color': 'inputArrowBlocking',
        'colors-panel-output-arrow-blocking-color': 'outputArrowBlocking',
        'colors-panel-input-arrow-informational-color': 'inputArrowInformational',
        'colors-panel-output-arrow-informational-color': 'outputArrowInformational',
        'colors-panel-sim-ok-input-color': 'simOkInput',
        'colors-panel-sim-ok-output-color': 'simOkOutput',
        'colors-panel-sim-input-conflict-color': 'simInputConflict',
        'colors-panel-sim-output-at-risk-color': 'simOutputAtRisk'
    };

    Object.entries(colorMappings).forEach(([elementId, configKey]) => {
        const element = document.getElementById(elementId);
        if (element && configColors[configKey]) {
            element.value = configColors[configKey];
        }
    });
}

function setupColorsPanelListeners() {
    // Mapowanie między ID elementów w panelu a kluczami w configColors
    const colorMappings = {
        'colors-panel-node-color': 'node',
        'colors-panel-blocking-node-color': 'blockingNode',
        'colors-panel-informational-node-color': 'informationalNode',
        'colors-panel-lightning-color': 'lightning',
        'colors-panel-input-process-color': 'inputProcess',
        'colors-panel-output-process-color': 'outputProcess',
        'colors-panel-input-arrow-color': 'inputArrow',
        'colors-panel-output-arrow-color': 'outputArrow',
        'colors-panel-input-arrow-blocking-color': 'inputArrowBlocking',
        'colors-panel-output-arrow-blocking-color': 'outputArrowBlocking',
        'colors-panel-input-arrow-informational-color': 'inputArrowInformational',
        'colors-panel-output-arrow-informational-color': 'outputArrowInformational',
        'colors-panel-sim-ok-input-color': 'simOkInput',
        'colors-panel-sim-ok-output-color': 'simOkOutput',
        'colors-panel-sim-input-conflict-color': 'simInputConflict',
        'colors-panel-sim-output-at-risk-color': 'simOutputAtRisk'
    };

    Object.entries(colorMappings).forEach(([elementId, configKey]) => {
        const element = document.getElementById(elementId);
        if (element) {
            element.addEventListener('change', (e) => {
                configColors[configKey] = e.target.value;
                refreshDiagramStyles();
                saveStateToLocalStorage();
            });
        }
    });
}

function toggleColorsPanel(show) {
    if (show) {
        colorsPanel.classList.add('open');
        // Zamknij inne panele
        filterPanel.classList.remove('open');
        converterPanel.classList.remove('open');
        simulationPanel.classList.remove('open');
        tutorialPanel.classList.remove('open');
        toggleDependencyPanel(false);
        
        // Zsynchronizuj wartości w panelu z aktualnymi kolorami
        syncColorsPanelWithConfig();
    } else {
        colorsPanel.classList.remove('open');
    }
}

function setupColorControls() {
    const colorMenuButton = document.getElementById('color-controls-menu-button');
    const colorDropdown = document.getElementById('color-controls-dropdown');
    const manualBtn = document.getElementById('toggle-manual-colors-from-menu');

    // Obsługa głównego przycisku color options (otwieranie dropdown menu)
    if (colorMenuButton) {
        colorMenuButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const isDropdownOpen = colorDropdown.style.display === 'block';
            colorDropdown.style.display = isDropdownOpen ? 'none' : 'block';
        });
    }

    // Obsługa przycisku "Change Colours..." w menu
    if (manualBtn) {
        manualBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            // Use requestAnimationFrame to ensure the colors panel opens after DOM updates
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    toggleColorsPanel(true);
                });
            });
            colorDropdown.style.display = 'none'; // Zamknij dropdown menu
        });
    }

    // Obsługa pozostałych opcji w color dropdown
    const generateThemeBtn = document.getElementById('generate-theme-from-menu');
    const resetColorsBtn = document.getElementById('reset-colors-from-menu');

    if (generateThemeBtn) {
        generateThemeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            generateNewTheme();
            showNotification("New color theme generated.", "success");
            colorDropdown.style.display = 'none';
        });
    }

    if (resetColorsBtn) {
        resetColorsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            resetColorsToDefault();
            showNotification("Colors reset to default.", "success");
            colorDropdown.style.display = 'none';
        });
    }

    // Obsługa przycisku zamykania panelu kolorów
    if (closeColorsPanelButton) {
        closeColorsPanelButton.addEventListener('click', () => {
            toggleColorsPanel(false);
        });
    }

    // Obsługa przycisków akcji w panelu kolorów
    const resetButton = document.getElementById('colors-panel-reset-button');
    const generateButton = document.getElementById('colors-panel-generate-button');

    if (resetButton) {
        resetButton.addEventListener('click', () => {
            resetColorsToDefault();
            syncColorsPanelWithConfig();
            showNotification("Colors reset to default.", "success");
        });
    }

    if (generateButton) {
        generateButton.addEventListener('click', () => {
            generateNewTheme();
            syncColorsPanelWithConfig();
            showNotification("New color theme generated.", "success");
        });
    }

    // Dodaj event listenery dla wszystkich color pickerów w panelu
    setupColorsPanelListeners();
}

function setupDetailsPanel() {
    const detailsPanel = document.getElementById('process-details');
    const header = document.getElementById('details-header'); // Nasłuchujemy na cały nagłówek

    if (header) {
        header.addEventListener('click', (e) => {
            // Sprawdzamy, czy kliknięto na przycisk akcji (np. edycja) wewnątrz panelu, aby tego nie przechwycić
            if (e.target.tagName === 'BUTTON' && e.target.id !== 'details-toggle-button') {
                return;
            }
            
            // Sprawdzamy, czy panel jest w ogóle aktywny (czy wybrano proces)
            if (detailsPanel.classList.contains('active')) {
                // Przełączamy stan rozwinięcia/zwinięcia
                detailsPanel.classList.toggle('expanded');
            }
        });
    }
}

// Initialize application with Supabase data loading
async function initializeApplication() {
    // Load UI state from localStorage
    loadStateFromLocalStorage();
    
    // Initialize with sheet context
    await initializeApp();
    
    // Initialize other components
    initSimulationPanelUI();
    populateViewConfigSelector();
    populateSimulationScenarioSelector();
}

    // Missing function for simulation scenarios
    function populateSimulationScenarioSelector() {
        const savedScenarios = JSON.parse(localStorage.getItem(SIMULATION_SCENARIOS_STORAGE_KEY)) || {};
        simulationScenarioSelector.innerHTML = '<option value="">- Select Scenario -</option>';
        
        Object.keys(savedScenarios).sort().forEach(scenarioName => {
            const option = document.createElement('option');
            option.value = scenarioName;
            option.textContent = scenarioName;
            simulationScenarioSelector.appendChild(option);
        });
    }

    // Wywołanie nowych funkcji inicjalizujących
    setupThemeToggle();
    setupColorControls();
    setupDetailsPanel();
    initializeApplication();

// KONIEC NOWYCH FUNKCJI I INICJALIZACJI

    // Delikatna animacja logo co 12 sekund
    function initLogoAnimation() {
        setInterval(() => {
            const logo = document.querySelector('.flowcraft-logo');
            if (!logo) return;
            
            logo.style.animation = 'none';
            logo.offsetHeight; // Force reflow
            logo.style.animation = 'logoGlow 2s ease-in-out';
            
            setTimeout(() => {
                logo.style.animation = '';
            }, 2000);
        }, 12000);

        // Enhanced logo click animation
        const logo = document.querySelector('.flowcraft-logo');
        if (logo) {
            logo.addEventListener('click', () => {
                logo.style.animation = 'none';
                logo.offsetHeight; // Force reflow
                logo.style.animation = 'logoGlow 1s ease-in-out';
                
                setTimeout(() => {
                    logo.style.animation = '';
                }, 1000);
            });
        }
    }

    // Add subtle logo keyframes
    const style = document.createElement('style');
    style.textContent = `
        @keyframes logoGlow {
            0%, 100% { 
                filter: drop-shadow(0 0 10px rgba(0, 212, 255, 0.5));
                transform: scale(1);
            }
            50% { 
                filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.8)) drop-shadow(0 0 40px rgba(255, 0, 110, 0.3));
                transform: scale(1.05);
            }
        }
    `;
    document.head.appendChild(style);

    // Initialize logo animation after DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initLogoAnimation);
    } else {
        initLogoAnimation();
    }

    // =====================================================
    // Process status management functions moved to index.html (processes table)

</script>
<div class="page-footer">
    <img src="FlowCraft.png" alt="FlowCraft Logo" class="flowcraft-footer-logo" style="width: 24px; height: 24px; margin-right: 8px; vertical-align: middle; filter: drop-shadow(0 0 5px rgba(0, 212, 255, 0.3)); border-radius: 4px;">
    FlowCraft © 2025 - All Rights Reserved
</div>
</body>
</html>